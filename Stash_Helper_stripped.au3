Global Const $FC_NOOVERWRITE = 0
Global Const $FC_OVERWRITE = 1
Global Const $FC_CREATEPATH = 8
Global Const $FT_MODIFIED = 0
Global Const $FT_CREATED = 1
Global Const $FT_ACCESSED = 2
Global Const $FT_ARRAY = 0
Global Const $FT_STRING = 1
Global Const $FSF_CREATEBUTTON = 1
Global Const $FSF_NEWDIALOG = 2
Global Const $FSF_EDITCONTROL = 4
Global Const $FT_NONRECURSIVE = 0
Global Const $FT_RECURSIVE = 1
Global Const $FO_READ = 0
Global Const $FO_APPEND = 1
Global Const $FO_OVERWRITE = 2
Global Const $FO_CREATEPATH = 8
Global Const $FO_BINARY = 16
Global Const $FO_UNICODE = 32
Global Const $FO_UTF16_LE = 32
Global Const $FO_UTF16_BE = 64
Global Const $FO_UTF8 = 128
Global Const $FO_UTF8_NOBOM = 256
Global Const $FO_ANSI = 512
Global Const $FO_UTF16_LE_NOBOM = 1024
Global Const $FO_UTF16_BE_NOBOM = 2048
Global Const $FO_UTF8_FULL = 16384
Global Const $FO_FULLFILE_DETECT = 16384
Global Const $EOF = -1
Global Const $FD_FILEMUSTEXIST = 1
Global Const $FD_PATHMUSTEXIST = 2
Global Const $FD_MULTISELECT = 4
Global Const $FD_PROMPTCREATENEW = 8
Global Const $FD_PROMPTOVERWRITE = 16
Global Const $CREATE_NEW = 1
Global Const $CREATE_ALWAYS = 2
Global Const $OPEN_EXISTING = 3
Global Const $OPEN_ALWAYS = 4
Global Const $TRUNCATE_EXISTING = 5
Global Const $INVALID_SET_FILE_POINTER = -1
Global Const $FILE_BEGIN = 0
Global Const $FILE_CURRENT = 1
Global Const $FILE_END = 2
Global Const $FILE_ATTRIBUTE_READONLY = 0x00000001
Global Const $FILE_ATTRIBUTE_HIDDEN = 0x00000002
Global Const $FILE_ATTRIBUTE_SYSTEM = 0x00000004
Global Const $FILE_ATTRIBUTE_DIRECTORY = 0x00000010
Global Const $FILE_ATTRIBUTE_ARCHIVE = 0x00000020
Global Const $FILE_ATTRIBUTE_DEVICE = 0x00000040
Global Const $FILE_ATTRIBUTE_NORMAL = 0x00000080
Global Const $FILE_ATTRIBUTE_TEMPORARY = 0x00000100
Global Const $FILE_ATTRIBUTE_SPARSE_FILE = 0x00000200
Global Const $FILE_ATTRIBUTE_REPARSE_POINT = 0x00000400
Global Const $FILE_ATTRIBUTE_COMPRESSED = 0x00000800
Global Const $FILE_ATTRIBUTE_OFFLINE = 0x00001000
Global Const $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 0x00002000
Global Const $FILE_ATTRIBUTE_ENCRYPTED = 0x00004000
Global Const $FILE_SHARE_READ = 0x00000001
Global Const $FILE_SHARE_WRITE = 0x00000002
Global Const $FILE_SHARE_DELETE = 0x00000004
Global Const $FILE_SHARE_READWRITE = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
Global Const $FILE_SHARE_ANY = BitOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
Global Const $GENERIC_ALL = 0x10000000
Global Const $GENERIC_EXECUTE = 0x20000000
Global Const $GENERIC_WRITE = 0x40000000
Global Const $GENERIC_READ = 0x80000000
Global Const $GENERIC_READWRITE = BitOR($GENERIC_READ, $GENERIC_WRITE)
Global Const $FILE_ENCODING_UTF16LE = 32
Global Const $FE_ENTIRE_UTF8 = 1
Global Const $FE_PARTIALFIRST_UTF8 = 2
Global Const $FN_FULLPATH = 0
Global Const $FN_RELATIVEPATH = 1
Global Const $FV_COMMENTS = "Comments"
Global Const $FV_COMPANYNAME = "CompanyName"
Global Const $FV_FILEDESCRIPTION = "FileDescription"
Global Const $FV_FILEVERSION = "FileVersion"
Global Const $FV_INTERNALNAME = "InternalName"
Global Const $FV_LEGALCOPYRIGHT = "LegalCopyright"
Global Const $FV_LEGALTRADEMARKS = "LegalTrademarks"
Global Const $FV_ORIGINALFILENAME = "OriginalFilename"
Global Const $FV_PRODUCTNAME = "ProductName"
Global Const $FV_PRODUCTVERSION = "ProductVersion"
Global Const $FV_PRIVATEBUILD = "PrivateBuild"
Global Const $FV_SPECIALBUILD = "SpecialBuild"
Global Const $FRTA_NOCOUNT = 0
Global Const $FRTA_COUNT = 1
Global Const $FRTA_INTARRAYS = 2
Global Const $FRTA_ENTIRESPLIT = 4
Global Const $FLTA_FILESFOLDERS = 0
Global Const $FLTA_FILES = 1
Global Const $FLTA_FOLDERS = 2
Global Const $FLTAR_FILESFOLDERS = 0
Global Const $FLTAR_FILES = 1
Global Const $FLTAR_FOLDERS = 2
Global Const $FLTAR_NOHIDDEN = 4
Global Const $FLTAR_NOSYSTEM = 8
Global Const $FLTAR_NOLINK = 16
Global Const $FLTAR_NORECUR = 0
Global Const $FLTAR_RECUR = 1
Global Const $FLTAR_NOSORT = 0
Global Const $FLTAR_SORT = 1
Global Const $FLTAR_FASTSORT = 2
Global Const $FLTAR_NOPATH = 0
Global Const $FLTAR_RELPATH = 1
Global Const $FLTAR_FULLPATH = 2
Global Const $PATH_ORIGINAL = 0
Global Const $PATH_DRIVE = 1
Global Const $PATH_DIRECTORY = 2
Global Const $PATH_FILENAME = 3
Global Const $PATH_EXTENSION = 4
Global Const $TRAY_ITEM_EXIT = 3
Global Const $TRAY_ITEM_PAUSE = 4
Global Const $TRAY_ITEM_FIRST = 7
Global Const $TRAY_CHECKED = 1
Global Const $TRAY_UNCHECKED = 4
Global Const $TRAY_ENABLE = 64
Global Const $TRAY_DISABLE = 128
Global Const $TRAY_FOCUS = 256
Global Const $TRAY_DEFAULT = 512
Global Const $TRAY_EVENT_NONE = 0
Global Const $TRAY_EVENT_SHOWICON = -3
Global Const $TRAY_EVENT_HIDEICON = -4
Global Const $TRAY_EVENT_FLASHICON = -5
Global Const $TRAY_EVENT_NOFLASHICON = -6
Global Const $TRAY_EVENT_PRIMARYDOWN = -7
Global Const $TRAY_EVENT_PRIMARYUP = -8
Global Const $TRAY_EVENT_SECONDARYDOWN = -9
Global Const $TRAY_EVENT_SECONDARYUP = -10
Global Const $TRAY_EVENT_MOUSEOVER = -11
Global Const $TRAY_EVENT_MOUSEOUT = -12
Global Const $TRAY_EVENT_PRIMARYDOUBLE = -13
Global Const $TRAY_EVENT_SECONDARYDOUBLE = -14
Global Const $TIP_ICONNONE = 0
Global Const $TIP_ICONASTERISK = 1
Global Const $TIP_ICONEXCLAMATION = 2
Global Const $TIP_ICONHAND = 3
Global Const $TIP_NOSOUND = 16
Global Const $TRAY_ITEM_NORMAL = 0
Global Const $TRAY_ITEM_RADIO = 1
Global Const $TRAY_CLICK_SHOW = 0
Global Const $TRAY_CLICK_PRIMARYDOWN = 1
Global Const $TRAY_CLICK_PRIMARYUP = 2
Global Const $TRAY_DBLCLICK_PRIMARY= 4
Global Const $TRAY_CLICK_SECONDARYDOWN = 8
Global Const $TRAY_CLICK_SECONDARYUP = 16
Global Const $TRAY_DBLCLICK_SECONDARY= 32
Global Const $TRAY_CLICK_HOVERING= 64
Global Const $TRAY_ICONSTATE_SHOW = 1
Global Const $TRAY_ICONSTATE_HIDE = 2
Global Const $TRAY_ICONSTATE_FLASH = 4
Global Const $TRAY_ICONSTATE_STOPFLASH = 8
Global Const $TRAY_ICONSTATE_RESET = 16
Global Const $SS_LEFT = 0x0
Global Const $SS_CENTER = 0x1
Global Const $SS_RIGHT = 0x2
Global Const $SS_ICON = 0x3
Global Const $SS_BLACKRECT = 0x4
Global Const $SS_GRAYRECT = 0x5
Global Const $SS_WHITERECT = 0x6
Global Const $SS_BLACKFRAME = 0x7
Global Const $SS_GRAYFRAME = 0x8
Global Const $SS_WHITEFRAME = 0x9
Global Const $SS_SIMPLE = 0xB
Global Const $SS_LEFTNOWORDWRAP = 0xC
Global Const $SS_BITMAP = 0xE
Global Const $SS_ENHMETAFILE = 0xF
Global Const $SS_ETCHEDHORZ = 0x10
Global Const $SS_ETCHEDVERT = 0x11
Global Const $SS_ETCHEDFRAME = 0x12
Global Const $SS_REALSIZECONTROL = 0x40
Global Const $SS_NOPREFIX = 0x0080
Global Const $SS_NOTIFY = 0x0100
Global Const $SS_CENTERIMAGE = 0x0200
Global Const $SS_RIGHTJUST = 0x0400
Global Const $SS_SUNKEN = 0x1000
Global Const $GUI_SS_DEFAULT_LABEL = 0
Global Const $GUI_SS_DEFAULT_GRAPHIC = 0
Global Const $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
Global Const $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
Global Const $STM_SETICON = 0x0170
Global Const $STM_GETICON = 0x0171
Global Const $STM_SETIMAGE = 0x0172
Global Const $STM_GETIMAGE = 0x0173
Global Const $GUI_EVENT_SINGLE = 0
Global Const $GUI_EVENT_ARRAY = 1
Global Const $GUI_EVENT_NONE = 0
Global Const $GUI_EVENT_CLOSE = -3
Global Const $GUI_EVENT_MINIMIZE = -4
Global Const $GUI_EVENT_RESTORE = -5
Global Const $GUI_EVENT_MAXIMIZE = -6
Global Const $GUI_EVENT_PRIMARYDOWN = -7
Global Const $GUI_EVENT_PRIMARYUP = -8
Global Const $GUI_EVENT_SECONDARYDOWN = -9
Global Const $GUI_EVENT_SECONDARYUP = -10
Global Const $GUI_EVENT_MOUSEMOVE = -11
Global Const $GUI_EVENT_RESIZED = -12
Global Const $GUI_EVENT_DROPPED = -13
Global Const $GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $GUI_AVISTOP = 0
Global Const $GUI_AVISTART = 1
Global Const $GUI_AVICLOSE = 2
Global Const $GUI_CHECKED = 1
Global Const $GUI_INDETERMINATE = 2
Global Const $GUI_UNCHECKED = 4
Global Const $GUI_DROPACCEPTED = 8
Global Const $GUI_NODROPACCEPTED = 4096
Global Const $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
Global Const $GUI_SHOW = 16
Global Const $GUI_HIDE = 32
Global Const $GUI_ENABLE = 64
Global Const $GUI_DISABLE = 128
Global Const $GUI_FOCUS = 256
Global Const $GUI_NOFOCUS = 8192
Global Const $GUI_DEFBUTTON = 512
Global Const $GUI_EXPAND = 1024
Global Const $GUI_ONTOP = 2048
Global Const $GUI_FONTNORMAL = 0
Global Const $GUI_FONTITALIC = 2
Global Const $GUI_FONTUNDER = 4
Global Const $GUI_FONTSTRIKE = 8
Global Const $GUI_DOCKAUTO = 0x0001
Global Const $GUI_DOCKLEFT = 0x0002
Global Const $GUI_DOCKRIGHT = 0x0004
Global Const $GUI_DOCKHCENTER = 0x0008
Global Const $GUI_DOCKTOP = 0x0020
Global Const $GUI_DOCKBOTTOM = 0x0040
Global Const $GUI_DOCKVCENTER = 0x0080
Global Const $GUI_DOCKWIDTH = 0x0100
Global Const $GUI_DOCKHEIGHT = 0x0200
Global Const $GUI_DOCKSIZE = 0x0300
Global Const $GUI_DOCKMENUBAR = 0x0220
Global Const $GUI_DOCKSTATEBAR = 0x0240
Global Const $GUI_DOCKALL = 0x0322
Global Const $GUI_DOCKBORDERS = 0x0066
Global Const $GUI_GR_CLOSE = 1
Global Const $GUI_GR_LINE = 2
Global Const $GUI_GR_BEZIER = 4
Global Const $GUI_GR_MOVE = 6
Global Const $GUI_GR_COLOR = 8
Global Const $GUI_GR_RECT = 10
Global Const $GUI_GR_ELLIPSE = 12
Global Const $GUI_GR_PIE = 14
Global Const $GUI_GR_DOT = 16
Global Const $GUI_GR_PIXEL = 18
Global Const $GUI_GR_HINT = 20
Global Const $GUI_GR_REFRESH = 22
Global Const $GUI_GR_PENSIZE = 24
Global Const $GUI_GR_NOBKCOLOR = -2
Global Const $GUI_BKCOLOR_DEFAULT = -1
Global Const $GUI_BKCOLOR_TRANSPARENT = -2
Global Const $GUI_BKCOLOR_LV_ALTERNATE = 0xFE000000
Global Const $GUI_READ_DEFAULT = 0
Global Const $GUI_READ_EXTENDED = 1
Global Const $GUI_CURSOR_NOOVERRIDE = 0
Global Const $GUI_CURSOR_OVERRIDE = 1
Global Const $GUI_WS_EX_PARENTDRAG = 0x00100000
Global Const $WC_ANIMATE = 'SysAnimate32'
Global Const $WC_BUTTON = 'Button'
Global Const $WC_COMBOBOX = 'ComboBox'
Global Const $WC_COMBOBOXEX = 'ComboBoxEx32'
Global Const $WC_DATETIMEPICK = 'SysDateTimePick32'
Global Const $WC_EDIT = 'Edit'
Global Const $WC_HEADER = 'SysHeader32'
Global Const $WC_HOTKEY = 'msctls_hotkey32'
Global Const $WC_IPADDRESS = 'SysIPAddress32'
Global Const $WC_LINK = 'SysLink'
Global Const $WC_LISTBOX = 'ListBox'
Global Const $WC_LISTVIEW = 'SysListView32'
Global Const $WC_MONTHCAL = 'SysMonthCal32'
Global Const $WC_NATIVEFONTCTL = 'NativeFontCtl'
Global Const $WC_PAGESCROLLER = 'SysPager'
Global Const $WC_PROGRESS = 'msctls_progress32'
Global Const $WC_REBAR = 'ReBarWindow32'
Global Const $WC_SCROLLBAR = 'ScrollBar'
Global Const $WC_STATIC = 'Static'
Global Const $WC_STATUSBAR = 'msctls_statusbar32'
Global Const $WC_TABCONTROL = 'SysTabControl32'
Global Const $WC_TOOLBAR = 'ToolbarWindow32'
Global Const $WC_TOOLTIPS = 'tooltips_class32'
Global Const $WC_TRACKBAR = 'msctls_trackbar32'
Global Const $WC_TREEVIEW = 'SysTreeView32'
Global Const $WC_UPDOWN = 'msctls_updown32'
Global Const $WS_OVERLAPPED = 0
Global Const $WS_TILED = $WS_OVERLAPPED
Global Const $WS_MAXIMIZEBOX = 0x00010000
Global Const $WS_MINIMIZEBOX = 0x00020000
Global Const $WS_TABSTOP = 0x00010000
Global Const $WS_GROUP = 0x00020000
Global Const $WS_SIZEBOX = 0x00040000
Global Const $WS_THICKFRAME = $WS_SIZEBOX
Global Const $WS_SYSMENU = 0x00080000
Global Const $WS_HSCROLL = 0x00100000
Global Const $WS_VSCROLL = 0x00200000
Global Const $WS_DLGFRAME = 0x00400000
Global Const $WS_BORDER = 0x00800000
Global Const $WS_CAPTION = 0x00C00000
Global Const $WS_OVERLAPPEDWINDOW = BitOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
Global Const $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
Global Const $WS_MAXIMIZE = 0x01000000
Global Const $WS_CLIPCHILDREN = 0x02000000
Global Const $WS_CLIPSIBLINGS = 0x04000000
Global Const $WS_DISABLED = 0x08000000
Global Const $WS_VISIBLE = 0x10000000
Global Const $WS_MINIMIZE = 0x20000000
Global Const $WS_ICONIC = $WS_MINIMIZE
Global Const $WS_CHILD = 0x40000000
Global Const $WS_CHILDWINDOW = $WS_CHILD
Global Const $WS_POPUP = 0x80000000
Global Const $WS_POPUPWINDOW = 0x80880000
Global Const $DS_3DLOOK = 0x0004
Global Const $DS_ABSALIGN = 0x0001
Global Const $DS_CENTER = 0x0800
Global Const $DS_CENTERMOUSE = 0x1000
Global Const $DS_CONTEXTHELP = 0x2000
Global Const $DS_CONTROL = 0x0400
Global Const $DS_FIXEDSYS = 0x0008
Global Const $DS_LOCALEDIT = 0x0020
Global Const $DS_MODALFRAME = 0x0080
Global Const $DS_NOFAILCREATE = 0x0010
Global Const $DS_NOIDLEMSG = 0x0100
Global Const $DS_SETFONT = 0x0040
Global Const $DS_SETFOREGROUND = 0x0200
Global Const $DS_SHELLFONT = BitOR($DS_FIXEDSYS, $DS_SETFONT)
Global Const $DS_SYSMODAL = 0x0002
Global Const $WS_EX_ACCEPTFILES = 0x00000010
Global Const $WS_EX_APPWINDOW = 0x00040000
Global Const $WS_EX_COMPOSITED = 0x02000000
Global Const $WS_EX_CONTROLPARENT = 0x10000
Global Const $WS_EX_CLIENTEDGE = 0x00000200
Global Const $WS_EX_CONTEXTHELP = 0x00000400
Global Const $WS_EX_DLGMODALFRAME = 0x00000001
Global Const $WS_EX_LAYERED = 0x00080000
Global Const $WS_EX_LAYOUTRTL = 0x400000
Global Const $WS_EX_LEFT = 0x00000000
Global Const $WS_EX_LEFTSCROLLBAR = 0x00004000
Global Const $WS_EX_LTRREADING = 0x00000000
Global Const $WS_EX_MDICHILD = 0x00000040
Global Const $WS_EX_NOACTIVATE = 0x08000000
Global Const $WS_EX_NOINHERITLAYOUT = 0x00100000
Global Const $WS_EX_NOPARENTNOTIFY = 0x00000004
Global Const $WS_EX_RIGHT = 0x00001000
Global Const $WS_EX_RIGHTSCROLLBAR = 0x00000000
Global Const $WS_EX_RTLREADING = 0x2000
Global Const $WS_EX_STATICEDGE = 0x00020000
Global Const $WS_EX_TOOLWINDOW = 0x00000080
Global Const $WS_EX_TOPMOST = 0x00000008
Global Const $WS_EX_TRANSPARENT = 0x00000020
Global Const $WS_EX_WINDOWEDGE = 0x00000100
Global Const $WS_EX_OVERLAPPEDWINDOW = BitOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
Global Const $WS_EX_PALETTEWINDOW = BitOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
Global Const $WM_NULL = 0x0000
Global Const $WM_CREATE = 0x0001
Global Const $WM_DESTROY = 0x0002
Global Const $WM_MOVE = 0x0003
Global Const $WM_SIZEWAIT = 0x0004
Global Const $WM_SIZE = 0x0005
Global Const $WM_ACTIVATE = 0x0006
Global Const $WM_SETFOCUS = 0x0007
Global Const $WM_KILLFOCUS = 0x0008
Global Const $WM_SETVISIBLE = 0x0009
Global Const $WM_ENABLE = 0x000A
Global Const $WM_SETREDRAW = 0x000B
Global Const $WM_SETTEXT = 0x000C
Global Const $WM_GETTEXT = 0x000D
Global Const $WM_GETTEXTLENGTH = 0x000E
Global Const $WM_PAINT = 0x000F
Global Const $WM_CLOSE = 0x0010
Global Const $WM_QUERYENDSESSION = 0x0011
Global Const $WM_QUIT = 0x0012
Global Const $WM_ERASEBKGND = 0x0014
Global Const $WM_QUERYOPEN = 0x0013
Global Const $WM_SYSCOLORCHANGE = 0x0015
Global Const $WM_ENDSESSION = 0x0016
Global Const $WM_SYSTEMERROR = 0x0017
Global Const $WM_SHOWWINDOW = 0x0018
Global Const $WM_CTLCOLOR = 0x0019
Global Const $WM_SETTINGCHANGE = 0x001A
Global Const $WM_WININICHANGE = 0x001A
Global Const $WM_DEVMODECHANGE = 0x001B
Global Const $WM_ACTIVATEAPP = 0x001C
Global Const $WM_FONTCHANGE = 0x001D
Global Const $WM_TIMECHANGE = 0x001E
Global Const $WM_CANCELMODE = 0x001F
Global Const $WM_SETCURSOR = 0x0020
Global Const $WM_MOUSEACTIVATE = 0x0021
Global Const $WM_CHILDACTIVATE = 0x0022
Global Const $WM_QUEUESYNC = 0x0023
Global Const $WM_GETMINMAXINFO = 0x0024
Global Const $WM_LOGOFF = 0x0025
Global Const $WM_PAINTICON = 0x0026
Global Const $WM_ICONERASEBKGND = 0x0027
Global Const $WM_NEXTDLGCTL = 0x0028
Global Const $WM_ALTTABACTIVE = 0x0029
Global Const $WM_SPOOLERSTATUS = 0x002A
Global Const $WM_DRAWITEM = 0x002B
Global Const $WM_MEASUREITEM = 0x002C
Global Const $WM_DELETEITEM = 0x002D
Global Const $WM_VKEYTOITEM = 0x002E
Global Const $WM_CHARTOITEM = 0x002F
Global Const $WM_SETFONT = 0x0030
Global Const $WM_GETFONT = 0x0031
Global Const $WM_SETHOTKEY = 0x0032
Global Const $WM_GETHOTKEY = 0x0033
Global Const $WM_FILESYSCHANGE = 0x0034
Global Const $WM_ISACTIVEICON = 0x0035
Global Const $WM_QUERYPARKICON = 0x0036
Global Const $WM_QUERYDRAGICON = 0x0037
Global Const $WM_WINHELP = 0x0038
Global Const $WM_COMPAREITEM = 0x0039
Global Const $WM_FULLSCREEN = 0x003A
Global Const $WM_CLIENTSHUTDOWN = 0x003B
Global Const $WM_DDEMLEVENT = 0x003C
Global Const $WM_GETOBJECT = 0x003D
Global Const $WM_CALCSCROLL = 0x003F
Global Const $WM_TESTING = 0x0040
Global Const $WM_COMPACTING = 0x0041
Global Const $WM_OTHERWINDOWCREATED = 0x0042
Global Const $WM_OTHERWINDOWDESTROYED = 0x0043
Global Const $WM_COMMNOTIFY = 0x0044
Global Const $WM_MEDIASTATUSCHANGE = 0x0045
Global Const $WM_WINDOWPOSCHANGING = 0x0046
Global Const $WM_WINDOWPOSCHANGED = 0x0047
Global Const $WM_POWER = 0x0048
Global Const $WM_COPYGLOBALDATA = 0x0049
Global Const $WM_COPYDATA = 0x004A
Global Const $WM_CANCELJOURNAL = 0x004B
Global Const $WM_LOGONNOTIFY = 0x004C
Global Const $WM_KEYF1 = 0x004D
Global Const $WM_NOTIFY = 0x004E
Global Const $WM_ACCESS_WINDOW = 0x004F
Global Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
Global Const $WM_INPUTLANGCHANGE = 0x0051
Global Const $WM_TCARD = 0x0052
Global Const $WM_HELP = 0x0053
Global Const $WM_USERCHANGED = 0x0054
Global Const $WM_NOTIFYFORMAT = 0x0055
Global Const $WM_QM_ACTIVATE = 0x0060
Global Const $WM_HOOK_DO_CALLBACK = 0x0061
Global Const $WM_SYSCOPYDATA = 0x0062
Global Const $WM_FINALDESTROY = 0x0070
Global Const $WM_MEASUREITEM_CLIENTDATA = 0x0071
Global Const $WM_CONTEXTMENU = 0x007B
Global Const $WM_STYLECHANGING = 0x007C
Global Const $WM_STYLECHANGED = 0x007D
Global Const $WM_DISPLAYCHANGE = 0x007E
Global Const $WM_GETICON = 0x007F
Global Const $WM_SETICON = 0x0080
Global Const $WM_NCCREATE = 0x0081
Global Const $WM_NCDESTROY = 0x0082
Global Const $WM_NCCALCSIZE = 0x0083
Global Const $WM_NCHITTEST = 0x0084
Global Const $WM_NCPAINT = 0x0085
Global Const $WM_NCACTIVATE = 0x0086
Global Const $WM_GETDLGCODE = 0x0087
Global Const $WM_SYNCPAINT = 0x0088
Global Const $WM_SYNCTASK = 0x0089
Global Const $WM_KLUDGEMINRECT = 0x008B
Global Const $WM_LPKDRAWSWITCHWND = 0x008C
Global Const $WM_UAHDESTROYWINDOW = 0x0090
Global Const $WM_UAHDRAWMENU = 0x0091
Global Const $WM_UAHDRAWMENUITEM = 0x0092
Global Const $WM_UAHINITMENU = 0x0093
Global Const $WM_UAHMEASUREMENUITEM = 0x0094
Global Const $WM_UAHNCPAINTMENUPOPUP = 0x0095
Global Const $WM_NCMOUSEMOVE = 0x00A0
Global Const $WM_NCLBUTTONDOWN = 0x00A1
Global Const $WM_NCLBUTTONUP = 0x00A2
Global Const $WM_NCLBUTTONDBLCLK = 0x00A3
Global Const $WM_NCRBUTTONDOWN = 0x00A4
Global Const $WM_NCRBUTTONUP = 0x00A5
Global Const $WM_NCRBUTTONDBLCLK = 0x00A6
Global Const $WM_NCMBUTTONDOWN = 0x00A7
Global Const $WM_NCMBUTTONUP = 0x00A8
Global Const $WM_NCMBUTTONDBLCLK = 0x00A9
Global Const $WM_NCXBUTTONDOWN = 0x00AB
Global Const $WM_NCXBUTTONUP = 0x00AC
Global Const $WM_NCXBUTTONDBLCLK = 0x00AD
Global Const $WM_NCUAHDRAWCAPTION = 0x00AE
Global Const $WM_NCUAHDRAWFRAME = 0x00AF
Global Const $WM_INPUT_DEVICE_CHANGE = 0x00FE
Global Const $WM_INPUT = 0x00FF
Global Const $WM_KEYDOWN = 0x0100
Global Const $WM_KEYFIRST = 0x0100
Global Const $WM_KEYUP = 0x0101
Global Const $WM_CHAR = 0x0102
Global Const $WM_DEADCHAR = 0x0103
Global Const $WM_SYSKEYDOWN = 0x0104
Global Const $WM_SYSKEYUP = 0x0105
Global Const $WM_SYSCHAR = 0x0106
Global Const $WM_SYSDEADCHAR = 0x0107
Global Const $WM_YOMICHAR = 0x0108
Global Const $WM_KEYLAST = 0x0109
Global Const $WM_UNICHAR = 0x0109
Global Const $WM_CONVERTREQUEST = 0x010A
Global Const $WM_CONVERTRESULT = 0x010B
Global Const $WM_IM_INFO = 0x010C
Global Const $WM_IME_STARTCOMPOSITION = 0x010D
Global Const $WM_IME_ENDCOMPOSITION = 0x010E
Global Const $WM_IME_COMPOSITION = 0x010F
Global Const $WM_IME_KEYLAST = 0x010F
Global Const $WM_INITDIALOG = 0x0110
Global Const $WM_COMMAND = 0x0111
Global Const $WM_SYSCOMMAND = 0x0112
Global Const $WM_TIMER = 0x0113
Global Const $WM_HSCROLL = 0x0114
Global Const $WM_VSCROLL = 0x0115
Global Const $WM_INITMENU = 0x0116
Global Const $WM_INITMENUPOPUP = 0x0117
Global Const $WM_SYSTIMER = 0x0118
Global Const $WM_GESTURE = 0x0119
Global Const $WM_GESTURENOTIFY = 0x011A
Global Const $WM_GESTUREINPUT = 0x011B
Global Const $WM_GESTURENOTIFIED = 0x011C
Global Const $WM_MENUSELECT = 0x011F
Global Const $WM_MENUCHAR = 0x0120
Global Const $WM_ENTERIDLE = 0x0121
Global Const $WM_MENURBUTTONUP = 0x0122
Global Const $WM_MENUDRAG = 0x0123
Global Const $WM_MENUGETOBJECT = 0x0124
Global Const $WM_UNINITMENUPOPUP = 0x0125
Global Const $WM_MENUCOMMAND = 0x0126
Global Const $WM_CHANGEUISTATE = 0x0127
Global Const $WM_UPDATEUISTATE = 0x0128
Global Const $WM_QUERYUISTATE = 0x0129
Global Const $WM_LBTRACKPOINT = 0x0131
Global Const $WM_CTLCOLORMSGBOX = 0x0132
Global Const $WM_CTLCOLOREDIT = 0x0133
Global Const $WM_CTLCOLORLISTBOX = 0x0134
Global Const $WM_CTLCOLORBTN = 0x0135
Global Const $WM_CTLCOLORDLG = 0x0136
Global Const $WM_CTLCOLORSCROLLBAR = 0x0137
Global Const $WM_CTLCOLORSTATIC = 0x0138
Global Const $MN_GETHMENU = 0x01E1
Global Const $WM_PARENTNOTIFY = 0x0210
Global Const $WM_ENTERMENULOOP = 0x0211
Global Const $WM_EXITMENULOOP = 0x0212
Global Const $WM_NEXTMENU = 0x0213
Global Const $WM_SIZING = 0x0214
Global Const $WM_CAPTURECHANGED = 0x0215
Global Const $WM_MOVING = 0x0216
Global Const $WM_POWERBROADCAST = 0x0218
Global Const $WM_DEVICECHANGE = 0x0219
Global Const $WM_MDICREATE = 0x0220
Global Const $WM_MDIDESTROY = 0x0221
Global Const $WM_MDIACTIVATE = 0x0222
Global Const $WM_MDIRESTORE = 0x0223
Global Const $WM_MDINEXT = 0x0224
Global Const $WM_MDIMAXIMIZE = 0x0225
Global Const $WM_MDITILE = 0x0226
Global Const $WM_MDICASCADE = 0x0227
Global Const $WM_MDIICONARRANGE = 0x0228
Global Const $WM_MDIGETACTIVE = 0x0229
Global Const $WM_DROPOBJECT = 0x022A
Global Const $WM_QUERYDROPOBJECT = 0x022B
Global Const $WM_BEGINDRAG = 0x022C
Global Const $WM_DRAGLOOP = 0x022D
Global Const $WM_DRAGSELECT = 0x022E
Global Const $WM_DRAGMOVE = 0x022F
Global Const $WM_MDISETMENU = 0x0230
Global Const $WM_ENTERSIZEMOVE = 0x0231
Global Const $WM_EXITSIZEMOVE = 0x0232
Global Const $WM_DROPFILES = 0x0233
Global Const $WM_MDIREFRESHMENU = 0x0234
Global Const $WM_TOUCH = 0x0240
Global Const $WM_IME_SETCONTEXT = 0x0281
Global Const $WM_IME_NOTIFY = 0x0282
Global Const $WM_IME_CONTROL = 0x0283
Global Const $WM_IME_COMPOSITIONFULL = 0x0284
Global Const $WM_IME_SELECT = 0x0285
Global Const $WM_IME_CHAR = 0x0286
Global Const $WM_IME_SYSTEM = 0x0287
Global Const $WM_IME_REQUEST = 0x0288
Global Const $WM_IME_KEYDOWN = 0x0290
Global Const $WM_IME_KEYUP = 0x0291
Global Const $WM_NCMOUSEHOVER = 0x02A0
Global Const $WM_MOUSEHOVER = 0x02A1
Global Const $WM_NCMOUSELEAVE = 0x02A2
Global Const $WM_MOUSELEAVE = 0x02A3
Global Const $WM_WTSSESSION_CHANGE = 0x02B1
Global Const $WM_TABLET_FIRST = 0x02C0
Global Const $WM_TABLET_LAST = 0x02DF
Global Const $WM_CUT = 0x0300
Global Const $WM_COPY = 0x0301
Global Const $WM_PASTE = 0x0302
Global Const $WM_CLEAR = 0x0303
Global Const $WM_UNDO = 0x0304
Global Const $WM_PALETTEISCHANGING = 0x0310
Global Const $WM_HOTKEY = 0x0312
Global Const $WM_PALETTECHANGED = 0x0311
Global Const $WM_SYSMENU = 0x0313
Global Const $WM_HOOKMSG = 0x0314
Global Const $WM_EXITPROCESS = 0x0315
Global Const $WM_WAKETHREAD = 0x0316
Global Const $WM_PRINT = 0x0317
Global Const $WM_PRINTCLIENT = 0x0318
Global Const $WM_APPCOMMAND = 0x0319
Global Const $WM_QUERYNEWPALETTE = 0x030F
Global Const $WM_THEMECHANGED = 0x031A
Global Const $WM_UAHINIT = 0x031B
Global Const $WM_DESKTOPNOTIFY = 0x031C
Global Const $WM_CLIPBOARDUPDATE = 0x031D
Global Const $WM_DWMCOMPOSITIONCHANGED = 0x031E
Global Const $WM_DWMNCRENDERINGCHANGED = 0x031F
Global Const $WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320
Global Const $WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321
Global Const $WM_DWMEXILEFRAME = 0x0322
Global Const $WM_DWMSENDICONICTHUMBNAIL = 0x0323
Global Const $WM_MAGNIFICATION_STARTED = 0x0324
Global Const $WM_MAGNIFICATION_ENDED = 0x0325
Global Const $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 0x0326
Global Const $WM_DWMTHUMBNAILSIZECHANGED = 0x0327
Global Const $WM_MAGNIFICATION_OUTPUT = 0x0328
Global Const $WM_MEASURECONTROL = 0x0330
Global Const $WM_GETACTIONTEXT = 0x0331
Global Const $WM_FORWARDKEYDOWN = 0x0333
Global Const $WM_FORWARDKEYUP = 0x0334
Global Const $WM_GETTITLEBARINFOEX = 0x033F
Global Const $WM_NOTIFYWOW = 0x0340
Global Const $WM_HANDHELDFIRST = 0x0358
Global Const $WM_HANDHELDLAST = 0x035F
Global Const $WM_AFXFIRST = 0x0360
Global Const $WM_AFXLAST = 0x037F
Global Const $WM_PENWINFIRST = 0x0380
Global Const $WM_PENWINLAST = 0x038F
Global Const $WM_DDE_INITIATE = 0x03E0
Global Const $WM_DDE_TERMINATE = 0x03E1
Global Const $WM_DDE_ADVISE = 0x03E2
Global Const $WM_DDE_UNADVISE = 0x03E3
Global Const $WM_DDE_ACK = 0x03E4
Global Const $WM_DDE_DATA = 0x03E5
Global Const $WM_DDE_REQUEST = 0x03E6
Global Const $WM_DDE_POKE = 0x03E7
Global Const $WM_DDE_EXECUTE = 0x03E8
Global Const $WM_DBNOTIFICATION = 0x03FD
Global Const $WM_NETCONNECT = 0x03FE
Global Const $WM_HIBERNATE = 0x03FF
Global Const $WM_USER = 0x0400
Global Const $WM_APP = 0x8000
Global Const $NM_FIRST = 0
Global Const $NM_OUTOFMEMORY = $NM_FIRST - 1
Global Const $NM_CLICK = $NM_FIRST - 2
Global Const $NM_DBLCLK = $NM_FIRST - 3
Global Const $NM_RETURN = $NM_FIRST - 4
Global Const $NM_RCLICK = $NM_FIRST - 5
Global Const $NM_RDBLCLK = $NM_FIRST - 6
Global Const $NM_SETFOCUS = $NM_FIRST - 7
Global Const $NM_KILLFOCUS = $NM_FIRST - 8
Global Const $NM_CUSTOMDRAW = $NM_FIRST - 12
Global Const $NM_HOVER = $NM_FIRST - 13
Global Const $NM_NCHITTEST = $NM_FIRST - 14
Global Const $NM_KEYDOWN = $NM_FIRST - 15
Global Const $NM_RELEASEDCAPTURE = $NM_FIRST - 16
Global Const $NM_SETCURSOR = $NM_FIRST - 17
Global Const $NM_CHAR = $NM_FIRST - 18
Global Const $NM_TOOLTIPSCREATED = $NM_FIRST - 19
Global Const $NM_LDOWN = $NM_FIRST - 20
Global Const $NM_RDOWN = $NM_FIRST - 21
Global Const $NM_THEMECHANGED = $NM_FIRST - 22
Global Const $WM_MOUSEFIRST = 0x0200
Global Const $WM_MOUSEMOVE = 0x0200
Global Const $WM_LBUTTONDOWN = 0x0201
Global Const $WM_LBUTTONUP = 0x0202
Global Const $WM_LBUTTONDBLCLK = 0x0203
Global Const $WM_RBUTTONDOWN = 0x0204
Global Const $WM_RBUTTONUP = 0x0205
Global Const $WM_RBUTTONDBLCLK = 0x0206
Global Const $WM_MBUTTONDOWN = 0x0207
Global Const $WM_MBUTTONUP = 0x0208
Global Const $WM_MBUTTONDBLCLK = 0x0209
Global Const $WM_MOUSEWHEEL = 0x020A
Global Const $WM_XBUTTONDOWN = 0x020B
Global Const $WM_XBUTTONUP = 0x020C
Global Const $WM_XBUTTONDBLCLK = 0x020D
Global Const $WM_MOUSEHWHEEL = 0x020E
Global Const $PS_SOLID = 0
Global Const $PS_DASH = 1
Global Const $PS_DOT = 2
Global Const $PS_DASHDOT = 3
Global Const $PS_DASHDOTDOT = 4
Global Const $PS_NULL = 5
Global Const $PS_INSIDEFRAME = 6
Global Const $PS_USERSTYLE = 7
Global Const $PS_ALTERNATE = 8
Global Const $PS_ENDCAP_ROUND = 0x00000000
Global Const $PS_ENDCAP_SQUARE = 0x00000100
Global Const $PS_ENDCAP_FLAT = 0x00000200
Global Const $PS_JOIN_BEVEL = 0x00001000
Global Const $PS_JOIN_MITER = 0x00002000
Global Const $PS_JOIN_ROUND = 0x00000000
Global Const $PS_GEOMETRIC = 0x00010000
Global Const $PS_COSMETIC = 0x00000000
Global Const $LWA_ALPHA = 0x2
Global Const $LWA_COLORKEY = 0x1
Global Const $RGN_AND = 1
Global Const $RGN_OR = 2
Global Const $RGN_XOR = 3
Global Const $RGN_DIFF = 4
Global Const $RGN_COPY = 5
Global Const $ERRORREGION = 0
Global Const $NULLREGION = 1
Global Const $SIMPLEREGION = 2
Global Const $COMPLEXREGION = 3
Global Const $TRANSPARENT = 1
Global Const $OPAQUE = 2
Global Const $CCM_FIRST = 0x2000
Global Const $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
Global Const $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
Global Const $CCM_SETBKCOLOR = $CCM_FIRST + 1
Global Const $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
Global Const $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
Global Const $CCM_GETDROPTARGET = $CCM_FIRST + 4
Global Const $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
Global Const $GA_PARENT = 1
Global Const $GA_ROOT = 2
Global Const $GA_ROOTOWNER = 3
Global Const $SM_CXSCREEN = 0
Global Const $SM_CYSCREEN = 1
Global Const $SM_CXVSCROLL = 2
Global Const $SM_CYHSCROLL = 3
Global Const $SM_CYCAPTION = 4
Global Const $SM_CXBORDER = 5
Global Const $SM_CYBORDER = 6
Global Const $SM_CXFIXEDFRAME = 7
Global Const $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
Global Const $SM_CYFIXEDFRAME = 8
Global Const $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
Global Const $SM_CYVTHUMB = 9
Global Const $SM_CXHTHUMB = 10
Global Const $SM_CXICON = 11
Global Const $SM_CYICON = 12
Global Const $SM_CXCURSOR = 13
Global Const $SM_CYCURSOR = 14
Global Const $SM_CYMENU = 15
Global Const $SM_CXFULLSCREEN = 16
Global Const $SM_CYFULLSCREEN = 17
Global Const $SM_CYKANJIWINDOW = 18
Global Const $SM_MOUSEPRESENT = 19
Global Const $SM_CYVSCROLL = 20
Global Const $SM_CXHSCROLL = 21
Global Const $SM_DEBUG = 22
Global Const $SM_SWAPBUTTON = 23
Global Const $SM_RESERVED1 = 24
Global Const $SM_RESERVED2 = 25
Global Const $SM_RESERVED3 = 26
Global Const $SM_RESERVED4 = 27
Global Const $SM_CXMIN = 28
Global Const $SM_CYMIN = 29
Global Const $SM_CXSIZE = 30
Global Const $SM_CYSIZE = 31
Global Const $SM_CXSIZEFRAME = 32
Global Const $SM_CXFRAME = $SM_CXSIZEFRAME
Global Const $SM_CYSIZEFRAME = 33
Global Const $SM_CYFRAME = $SM_CYSIZEFRAME
Global Const $SM_CXMINTRACK = 34
Global Const $SM_CYMINTRACK = 35
Global Const $SM_CXDOUBLECLK = 36
Global Const $SM_CYDOUBLECLK = 37
Global Const $SM_CXICONSPACING = 38
Global Const $SM_CYICONSPACING = 39
Global Const $SM_MENUDROPALIGNMENT = 40
Global Const $SM_PENWINDOWS = 41
Global Const $SM_DBCSENABLED = 42
Global Const $SM_CMOUSEBUTTONS = 43
Global Const $SM_SECURE = 44
Global Const $SM_CXEDGE = 45
Global Const $SM_CYEDGE = 46
Global Const $SM_CXMINSPACING = 47
Global Const $SM_CYMINSPACING = 48
Global Const $SM_CXSMICON = 49
Global Const $SM_CYSMICON = 50
Global Const $SM_CYSMCAPTION = 51
Global Const $SM_CXSMSIZE = 52
Global Const $SM_CYSMSIZE = 53
Global Const $SM_CXMENUSIZE = 54
Global Const $SM_CYMENUSIZE = 55
Global Const $SM_ARRANGE = 56
Global Const $SM_CXMINIMIZED = 57
Global Const $SM_CYMINIMIZED = 58
Global Const $SM_CXMAXTRACK = 59
Global Const $SM_CYMAXTRACK = 60
Global Const $SM_CXMAXIMIZED = 61
Global Const $SM_CYMAXIMIZED = 62
Global Const $SM_NETWORK = 63
Global Const $SM_CLEANBOOT = 67
Global Const $SM_CXDRAG = 68
Global Const $SM_CYDRAG = 69
Global Const $SM_SHOWSOUNDS = 70
Global Const $SM_CXMENUCHECK = 71
Global Const $SM_CYMENUCHECK = 72
Global Const $SM_SLOWMACHINE = 73
Global Const $SM_MIDEASTENABLED = 74
Global Const $SM_MOUSEWHEELPRESENT = 75
Global Const $SM_XVIRTUALSCREEN = 76
Global Const $SM_YVIRTUALSCREEN = 77
Global Const $SM_CXVIRTUALSCREEN = 78
Global Const $SM_CYVIRTUALSCREEN = 79
Global Const $SM_CMONITORS = 80
Global Const $SM_SAMEDISPLAYFORMAT = 81
Global Const $SM_IMMENABLED = 82
Global Const $SM_CXFOCUSBORDER = 83
Global Const $SM_CYFOCUSBORDER = 84
Global Const $SM_TABLETPC = 86
Global Const $SM_MEDIACENTER = 87
Global Const $SM_STARTER = 88
Global Const $SM_SERVERR2 = 89
Global Const $SM_CMETRICS = 90
Global Const $SM_REMOTESESSION = 0x1000
Global Const $SM_SHUTTINGDOWN = 0x2000
Global Const $SM_REMOTECONTROL = 0x2001
Global Const $SM_CARETBLINKINGENABLED = 0x2002
Global Const $BLACKNESS = 0x00000042
Global Const $CAPTUREBLT = 0X40000000
Global Const $DSTINVERT = 0x00550009
Global Const $MERGECOPY = 0x00C000CA
Global Const $MERGEPAINT = 0x00BB0226
Global Const $NOMIRRORBITMAP = 0X80000000
Global Const $NOTSRCCOPY = 0x00330008
Global Const $NOTSRCERASE = 0x001100A6
Global Const $PATCOPY = 0x00F00021
Global Const $PATINVERT = 0x005A0049
Global Const $PATPAINT = 0x00FB0A09
Global Const $SRCAND = 0x008800C6
Global Const $SRCCOPY = 0x00CC0020
Global Const $SRCERASE = 0x00440328
Global Const $SRCINVERT = 0x00660046
Global Const $SRCPAINT = 0x00EE0086
Global Const $WHITENESS = 0x00FF0062
Global Const $DT_BOTTOM = 0x8
Global Const $DT_CALCRECT = 0x400
Global Const $DT_CENTER = 0x1
Global Const $DT_EDITCONTROL = 0x2000
Global Const $DT_END_ELLIPSIS = 0x8000
Global Const $DT_EXPANDTABS = 0x40
Global Const $DT_EXTERNALLEADING = 0x200
Global Const $DT_HIDEPREFIX = 0x100000
Global Const $DT_INTERNAL = 0x1000
Global Const $DT_LEFT = 0x0
Global Const $DT_MODIFYSTRING = 0x10000
Global Const $DT_NOCLIP = 0x100
Global Const $DT_NOFULLWIDTHCHARBREAK = 0x80000
Global Const $DT_NOPREFIX = 0x800
Global Const $DT_PATH_ELLIPSIS = 0x4000
Global Const $DT_PREFIXONLY = 0x200000
Global Const $DT_RIGHT = 0x2
Global Const $DT_RTLREADING = 0x20000
Global Const $DT_SINGLELINE = 0x20
Global Const $DT_TABSTOP = 0x80
Global Const $DT_TOP = 0x0
Global Const $DT_VCENTER = 0x4
Global Const $DT_WORDBREAK = 0x10
Global Const $DT_WORD_ELLIPSIS = 0x40000
Global Const $RDW_ERASE = 0x0004
Global Const $RDW_FRAME = 0x0400
Global Const $RDW_INTERNALPAINT = 0x0002
Global Const $RDW_INVALIDATE = 0x0001
Global Const $RDW_NOERASE = 0x0020
Global Const $RDW_NOFRAME = 0x0800
Global Const $RDW_NOINTERNALPAINT = 0x0010
Global Const $RDW_VALIDATE = 0x0008
Global Const $RDW_ERASENOW = 0x0200
Global Const $RDW_UPDATENOW = 0x0100
Global Const $RDW_ALLCHILDREN = 0x0080
Global Const $RDW_NOCHILDREN = 0x0040
Global Const $WM_RENDERFORMAT = 0x0305
Global Const $WM_RENDERALLFORMATS = 0x0306
Global Const $WM_DESTROYCLIPBOARD = 0x0307
Global Const $WM_DRAWCLIPBOARD = 0x0308
Global Const $WM_PAINTCLIPBOARD = 0x0309
Global Const $WM_VSCROLLCLIPBOARD = 0x030A
Global Const $WM_SIZECLIPBOARD = 0x030B
Global Const $WM_ASKCBFORMATNAME = 0x030C
Global Const $WM_CHANGECBCHAIN = 0x030D
Global Const $WM_HSCROLLCLIPBOARD = 0x030E
Global Const $HTERROR = -2
Global Const $HTTRANSPARENT = -1
Global Const $HTNOWHERE = 0
Global Const $HTCLIENT = 1
Global Const $HTCAPTION = 2
Global Const $HTSYSMENU = 3
Global Const $HTGROWBOX = 4
Global Const $HTSIZE = $HTGROWBOX
Global Const $HTMENU = 5
Global Const $HTHSCROLL = 6
Global Const $HTVSCROLL = 7
Global Const $HTMINBUTTON = 8
Global Const $HTMAXBUTTON = 9
Global Const $HTLEFT = 10
Global Const $HTRIGHT = 11
Global Const $HTTOP = 12
Global Const $HTTOPLEFT = 13
Global Const $HTTOPRIGHT = 14
Global Const $HTBOTTOM = 15
Global Const $HTBOTTOMLEFT = 16
Global Const $HTBOTTOMRIGHT = 17
Global Const $HTBORDER = 18
Global Const $HTREDUCE = $HTMINBUTTON
Global Const $HTZOOM = $HTMAXBUTTON
Global Const $HTSIZEFIRST = $HTLEFT
Global Const $HTSIZELAST = $HTBOTTOMRIGHT
Global Const $HTOBJECT = 19
Global Const $HTCLOSE = 20
Global Const $HTHELP = 21
Global Const $COLOR_SCROLLBAR = 0
Global Const $COLOR_BACKGROUND = 1
Global Const $COLOR_ACTIVECAPTION = 2
Global Const $COLOR_INACTIVECAPTION = 3
Global Const $COLOR_MENU = 4
Global Const $COLOR_WINDOW = 5
Global Const $COLOR_WINDOWFRAME = 6
Global Const $COLOR_MENUTEXT = 7
Global Const $COLOR_WINDOWTEXT = 8
Global Const $COLOR_CAPTIONTEXT = 9
Global Const $COLOR_ACTIVEBORDER = 10
Global Const $COLOR_INACTIVEBORDER = 11
Global Const $COLOR_APPWORKSPACE = 12
Global Const $COLOR_HIGHLIGHT = 13
Global Const $COLOR_HIGHLIGHTTEXT = 14
Global Const $COLOR_BTNFACE = 15
Global Const $COLOR_BTNSHADOW = 16
Global Const $COLOR_GRAYTEXT = 17
Global Const $COLOR_BTNTEXT = 18
Global Const $COLOR_INACTIVECAPTIONTEXT = 19
Global Const $COLOR_BTNHIGHLIGHT = 20
Global Const $COLOR_3DDKSHADOW = 21
Global Const $COLOR_3DLIGHT = 22
Global Const $COLOR_INFOTEXT = 23
Global Const $COLOR_INFOBK = 24
Global Const $COLOR_HOTLIGHT = 26
Global Const $COLOR_GRADIENTACTIVECAPTION = 27
Global Const $COLOR_GRADIENTINACTIVECAPTION = 28
Global Const $COLOR_MENUHILIGHT = 29
Global Const $COLOR_MENUBAR = 30
Global Const $COLOR_DESKTOP = 1
Global Const $COLOR_3DFACE = 15
Global Const $COLOR_3DSHADOW = 16
Global Const $COLOR_3DHIGHLIGHT = 20
Global Const $COLOR_3DHILIGHT = 20
Global Const $COLOR_BTNHILIGHT = 20
Global Const $HINST_COMMCTRL = -1
Global Const $IDB_STD_SMALL_COLOR = 0
Global Const $IDB_STD_LARGE_COLOR = 1
Global Const $IDB_VIEW_SMALL_COLOR = 4
Global Const $IDB_VIEW_LARGE_COLOR = 5
Global Const $IDB_HIST_SMALL_COLOR = 8
Global Const $IDB_HIST_LARGE_COLOR = 9
Global Const $STARTF_FORCEOFFFEEDBACK = 0x80
Global Const $STARTF_FORCEONFEEDBACK = 0x40
Global Const $STARTF_PREVENTPINNING = 0x00002000
Global Const $STARTF_RUNFULLSCREEN = 0x20
Global Const $STARTF_TITLEISAPPID = 0x00001000
Global Const $STARTF_TITLEISLINKNAME = 0x00000800
Global Const $STARTF_USECOUNTCHARS = 0x8
Global Const $STARTF_USEFILLATTRIBUTE = 0x10
Global Const $STARTF_USEHOTKEY = 0x200
Global Const $STARTF_USEPOSITION = 0x4
Global Const $STARTF_USESHOWWINDOW = 0x1
Global Const $STARTF_USESIZE = 0x2
Global Const $STARTF_USESTDHANDLES = 0x100
Global Const $CDDS_PREPAINT = 0x00000001
Global Const $CDDS_POSTPAINT = 0x00000002
Global Const $CDDS_PREERASE = 0x00000003
Global Const $CDDS_POSTERASE = 0x00000004
Global Const $CDDS_ITEM = 0x00010000
Global Const $CDDS_ITEMPREPAINT = 0x00010001
Global Const $CDDS_ITEMPOSTPAINT = 0x00010002
Global Const $CDDS_ITEMPREERASE = 0x00010003
Global Const $CDDS_ITEMPOSTERASE = 0x00010004
Global Const $CDDS_SUBITEM = 0x00020000
Global Const $CDIS_SELECTED = 0x0001
Global Const $CDIS_GRAYED = 0x0002
Global Const $CDIS_DISABLED = 0x0004
Global Const $CDIS_CHECKED = 0x0008
Global Const $CDIS_FOCUS = 0x0010
Global Const $CDIS_DEFAULT = 0x0020
Global Const $CDIS_HOT = 0x0040
Global Const $CDIS_MARKED = 0x0080
Global Const $CDIS_INDETERMINATE = 0x0100
Global Const $CDIS_SHOWKEYBOARDCUES = 0x0200
Global Const $CDIS_NEARHOT = 0x0400
Global Const $CDIS_OTHERSIDEHOT = 0x0800
Global Const $CDIS_DROPHILITED = 0x1000
Global Const $CDRF_DODEFAULT = 0x00000000
Global Const $CDRF_NEWFONT = 0x00000002
Global Const $CDRF_SKIPDEFAULT = 0x00000004
Global Const $CDRF_NOTIFYPOSTPAINT = 0x00000010
Global Const $CDRF_NOTIFYITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYSUBITEMDRAW = 0x00000020
Global Const $CDRF_NOTIFYPOSTERASE = 0x00000040
Global Const $CDRF_DOERASE = 0x00000008
Global Const $CDRF_SKIPPOSTPAINT = 0x00000100
Global Const $GUI_SS_DEFAULT_GUI = BitOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
Global Const $RT_ACCELERATOR = 9
Global Const $RT_ANICURSOR = 21
Global Const $RT_ANIICON = 22
Global Const $RT_BITMAP = 2
Global Const $RT_CURSOR = 1
Global Const $RT_DIALOG = 5
Global Const $RT_DLGINCLUDE = 17
Global Const $RT_FONT = 8
Global Const $RT_FONTDIR = 7
Global Const $RT_GROUP_CURSOR = 12
Global Const $RT_GROUP_ICON = 14
Global Const $RT_HTML = 23
Global Const $RT_ICON = 3
Global Const $RT_MANIFEST = 24
Global Const $RT_MENU = 4
Global Const $RT_MESSAGETABLE = 11
Global Const $RT_PLUGPLAY = 19
Global Const $RT_RCDATA = 10
Global Const $RT_STRING = 6
Global Const $RT_VERSION = 16
Global Const $RT_VXD = 20
Global Const $FILE_VER_GET_LOCALISED = 0x01
Global Const $FILE_VER_GET_NEUTRAL = 0x02
Global Const $FILE_VER_GET_PREFETCHED = 0x04
Global Const $OBM_TRTYPE = 32732
Global Const $OBM_LFARROWI = 32734
Global Const $OBM_RGARROWI = 32735
Global Const $OBM_DNARROWI = 32736
Global Const $OBM_UPARROWI = 32737
Global Const $OBM_COMBO = 32738
Global Const $OBM_MNARROW = 32739
Global Const $OBM_LFARROWD = 32740
Global Const $OBM_RGARROWD = 32741
Global Const $OBM_DNARROWD = 32742
Global Const $OBM_UPARROWD = 32743
Global Const $OBM_RESTORED = 32744
Global Const $OBM_ZOOMD = 32745
Global Const $OBM_REDUCED = 32746
Global Const $OBM_RESTORE = 32747
Global Const $OBM_ZOOM = 32748
Global Const $OBM_REDUCE = 32749
Global Const $OBM_LFARROW = 32750
Global Const $OBM_RGARROW = 32751
Global Const $OBM_DNARROW = 32752
Global Const $OBM_UPARROW = 32753
Global Const $OBM_CLOSE = 32754
Global Const $OBM_OLD_RESTORE = 32755
Global Const $OBM_OLD_ZOOM = 32756
Global Const $OBM_OLD_REDUCE = 32757
Global Const $OBM_BTNCORNERS = 32758
Global Const $OBM_CHECKBOXES = 32759
Global Const $OBM_CHECK = 32760
Global Const $OBM_BTSIZE = 32761
Global Const $OBM_OLD_LFARROW = 32762
Global Const $OBM_OLD_RGARROW = 32763
Global Const $OBM_OLD_DNARROW = 32764
Global Const $OBM_OLD_UPARROW = 32765
Global Const $OBM_SIZE = 32766
Global Const $OBM_OLD_CLOSE = 32767
Global Const $OIC_SAMPLE = 32512
Global Const $OIC_HAND = 32513
Global Const $OIC_QUES = 32514
Global Const $OIC_BANG = 32515
Global Const $OIC_NOTE = 32516
Global Const $OIC_WINLOGO = 32517
Global Const $OIC_WARNING = $OIC_BANG
Global Const $OIC_ERROR = $OIC_HAND
Global Const $OIC_INFORMATION = $OIC_NOTE
Global Const $DONT_RESOLVE_DLL_REFERENCES = 0x01
Global Const $LOAD_LIBRARY_AS_DATAFILE = 0x02
Global Const $LOAD_WITH_ALTERED_SEARCH_PATH = 0x08
Global Const $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 0x00000010
Global Const $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 0x00000040
Global Const $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 0x00000020
Global Const $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 0x00000200
Global Const $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 0x00001000
Global Const $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 0x00000100
Global Const $LOAD_LIBRARY_SEARCH_SYSTEM32 = 0x00000800
Global Const $LOAD_LIBRARY_SEARCH_USER_DIRS = 0x00000400
Global Const $OCR_NORMAL = 32512
Global Const $OCR_IBEAM = 32513
Global Const $OCR_WAIT = 32514
Global Const $OCR_CROSS = 32515
Global Const $OCR_UP = 32516
Global Const $OCR_SIZE = 32640
Global Const $OCR_ICON = 32641
Global Const $OCR_SIZENWSE = 32642
Global Const $OCR_SIZENESW = 32643
Global Const $OCR_SIZEWE = 32644
Global Const $OCR_SIZENS = 32645
Global Const $OCR_SIZEALL = 32646
Global Const $OCR_ICOCUR = 32647
Global Const $OCR_NO = 32648
Global Const $OCR_HAND = 32649
Global Const $OCR_APPSTARTING = 32650
Global Const $OCR_HELP = 32651
Global Const $VS_FF_DEBUG = 0x00000001
Global Const $VS_FF_INFOINFERRED = 0x00000010
Global Const $VS_FF_PATCHED = 0x00000004
Global Const $VS_FF_PRERELEASE = 0x00000002
Global Const $VS_FF_PRIVATEBUILD = 0x00000008
Global Const $VS_FF_SPECIALBUILD = 0x00000020
Global Const $VOS_DOS = 0x00010000
Global Const $VOS_NT = 0x00040000
Global Const $VOS__WINDOWS16 = 0x00000001
Global Const $VOS__WINDOWS32 = 0x00000004
Global Const $VOS_OS216 = 0x00020000
Global Const $VOS_OS232 = 0x00030000
Global Const $VOS__PM16 = 0x00000002
Global Const $VOS__PM32 = 0x00000003
Global Const $VOS_UNKNOWN = 0x00000000
Global Const $VOS_DOS_WINDOWS16 = 0x00010001
Global Const $VOS_DOS_WINDOWS32 = 0x00010004
Global Const $VOS_NT_WINDOWS32 = 0x00040004
Global Const $VOS_OS216_PM16 = 0x00020002
Global Const $VOS_OS232_PM32 = 0x00030003
Global Const $VFT_APP = 0x00000001
Global Const $VFT_DLL = 0x00000002
Global Const $VFT_DRV = 0x00000003
Global Const $VFT_FONT = 0x00000004
Global Const $VFT_STATIC_LIB = 0x00000007
Global Const $VFT_UNKNOWN = 0x00000000
Global Const $VFT_VXD = 0x00000005
Global Const $VFT2_DRV_COMM = 0x0000000A
Global Const $VFT2_DRV_DISPLAY = 0x00000004
Global Const $VFT2_DRV_INSTALLABLE = 0x00000008
Global Const $VFT2_DRV_KEYBOARD = 0x00000002
Global Const $VFT2_DRV_LANGUAGE = 0x00000003
Global Const $VFT2_DRV_MOUSE = 0x00000005
Global Const $VFT2_DRV_NETWORK = 0x00000006
Global Const $VFT2_DRV_PRINTER = 0x00000001
Global Const $VFT2_DRV_SOUND = 0x00000009
Global Const $VFT2_DRV_SYSTEM = 0x00000007
Global Const $VFT2_DRV_VERSIONED_PRINTER = 0x0000000C
Global Const $VFT2_UNKNOWN = 0x00000000
Global Const $VFT2_FONT_RASTER = 0x00000001
Global Const $VFT2_FONT_TRUETYPE = 0x00000003
Global Const $VFT2_FONT_VECTOR = 0x00000002
Global Const $BS_GROUPBOX = 0x0007
Global Const $BS_BOTTOM = 0x0800
Global Const $BS_CENTER = 0x0300
Global Const $BS_DEFPUSHBUTTON = 0x0001
Global Const $BS_LEFT = 0x0100
Global Const $BS_MULTILINE = 0x2000
Global Const $BS_PUSHBOX = 0x000A
Global Const $BS_PUSHLIKE = 0x1000
Global Const $BS_RIGHT = 0x0200
Global Const $BS_RIGHTBUTTON = 0x0020
Global Const $BS_TOP = 0x0400
Global Const $BS_VCENTER = 0x0C00
Global Const $BS_FLAT = 0x8000
Global Const $BS_ICON = 0x0040
Global Const $BS_BITMAP = 0x0080
Global Const $BS_NOTIFY = 0x4000
Global Const $BS_SPLITBUTTON = 0x0000000C
Global Const $BS_DEFSPLITBUTTON = 0x0000000D
Global Const $BS_COMMANDLINK = 0x0000000E
Global Const $BS_DEFCOMMANDLINK = 0x0000000F
Global Const $BCSIF_GLYPH = 0x0001
Global Const $BCSIF_IMAGE = 0x0002
Global Const $BCSIF_STYLE = 0x0004
Global Const $BCSIF_SIZE = 0x0008
Global Const $BCSS_NOSPLIT = 0x0001
Global Const $BCSS_STRETCH = 0x0002
Global Const $BCSS_ALIGNLEFT = 0x0004
Global Const $BCSS_IMAGE = 0x0008
Global Const $BUTTON_IMAGELIST_ALIGN_LEFT = 0
Global Const $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
Global Const $BUTTON_IMAGELIST_ALIGN_TOP = 2
Global Const $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
Global Const $BUTTON_IMAGELIST_ALIGN_CENTER = 4
Global Const $BS_3STATE = 0x0005
Global Const $BS_AUTO3STATE = 0x0006
Global Const $BS_AUTOCHECKBOX = 0x0003
Global Const $BS_CHECKBOX = 0x0002
Global Const $BS_RADIOBUTTON = 0x4
Global Const $BS_AUTORADIOBUTTON = 0x0009
Global Const $BS_OWNERDRAW = 0xB
Global Const $GUI_SS_DEFAULT_BUTTON = 0
Global Const $GUI_SS_DEFAULT_CHECKBOX = 0
Global Const $GUI_SS_DEFAULT_GROUP = 0
Global Const $GUI_SS_DEFAULT_RADIO = 0
Global Const $BCM_FIRST = 0x1600
Global Const $BCM_GETIDEALSIZE = ($BCM_FIRST + 0x0001)
Global Const $BCM_GETIMAGELIST = ($BCM_FIRST + 0x0003)
Global Const $BCM_GETNOTE = ($BCM_FIRST + 0x000A)
Global Const $BCM_GETNOTELENGTH = ($BCM_FIRST + 0x000B)
Global Const $BCM_GETSPLITINFO = ($BCM_FIRST + 0x0008)
Global Const $BCM_GETTEXTMARGIN = ($BCM_FIRST + 0x0005)
Global Const $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 0x0006)
Global Const $BCM_SETIMAGELIST = ($BCM_FIRST + 0x0002)
Global Const $BCM_SETNOTE = ($BCM_FIRST + 0x0009)
Global Const $BCM_SETSHIELD = ($BCM_FIRST + 0x000C)
Global Const $BCM_SETSPLITINFO = ($BCM_FIRST + 0x0007)
Global Const $BCM_SETTEXTMARGIN = ($BCM_FIRST + 0x0004)
Global Const $BM_CLICK = 0xF5
Global Const $BM_GETCHECK = 0xF0
Global Const $BM_GETIMAGE = 0xF6
Global Const $BM_GETSTATE = 0xF2
Global Const $BM_SETCHECK = 0xF1
Global Const $BM_SETDONTCLICK = 0xF8
Global Const $BM_SETIMAGE = 0xF7
Global Const $BM_SETSTATE = 0xF3
Global Const $BM_SETSTYLE = 0xF4
Global Const $BCN_FIRST = -1250
Global Const $BCN_DROPDOWN = ($BCN_FIRST + 0x0002)
Global Const $BCN_HOTITEMCHANGE = ($BCN_FIRST + 0x0001)
Global Const $BN_CLICKED = 0
Global Const $BN_PAINT = 1
Global Const $BN_HILITE = 2
Global Const $BN_UNHILITE = 3
Global Const $BN_DISABLE = 4
Global Const $BN_DOUBLECLICKED = 5
Global Const $BN_SETFOCUS = 6
Global Const $BN_KILLFOCUS = 7
Global Const $BN_PUSHED = $BN_HILITE
Global Const $BN_UNPUSHED = $BN_UNHILITE
Global Const $BN_DBLCLK = $BN_DOUBLECLICKED
Global Const $BST_CHECKED = 0x1
Global Const $BST_INDETERMINATE = 0x2
Global Const $BST_UNCHECKED = 0x0
Global Const $BST_FOCUS = 0x8
Global Const $BST_PUSHED = 0x4
Global Const $BST_DONTCLICK = 0x000080
Func _SendMessage($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageW", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Func _SendMessageA($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iReturn = 0, $wParamType = "wparam", $lParamType = "lparam", $sReturnType = "lresult")
Local $aResult = DllCall("user32.dll", $sReturnType, "SendMessageA", "hwnd", $hWnd, "uint", $iMsg, $wParamType, $wParam, $lParamType, $lParam)
If @error Then Return SetError(@error, @extended, "")
If $iReturn >= 0 And $iReturn <= 4 Then Return $aResult[$iReturn]
Return $aResult
EndFunc
Global Const $OPT_COORDSRELATIVE = 0
Global Const $OPT_COORDSABSOLUTE = 1
Global Const $OPT_COORDSCLIENT = 2
Global Const $OPT_ERRORSILENT = 0
Global Const $OPT_ERRORFATAL = 1
Global Const $OPT_CAPSNOSTORE = 0
Global Const $OPT_CAPSSTORE = 1
Global Const $OPT_MATCHSTART = 1
Global Const $OPT_MATCHANY = 2
Global Const $OPT_MATCHEXACT = 3
Global Const $OPT_MATCHADVANCED = 4
Global Const $CCS_TOP = 0x01
Global Const $CCS_NOMOVEY = 0x02
Global Const $CCS_BOTTOM = 0x03
Global Const $CCS_NORESIZE = 0x04
Global Const $CCS_NOPARENTALIGN = 0x08
Global Const $CCS_NOHILITE = 0x10
Global Const $CCS_ADJUSTABLE = 0x20
Global Const $CCS_NODIVIDER = 0x40
Global Const $CCS_VERT = 0x0080
Global Const $CCS_LEFT = 0x0081
Global Const $CCS_NOMOVEX = 0x0082
Global Const $CCS_RIGHT = 0x0083
Global Const $DT_DRIVETYPE = 1
Global Const $DT_SSDSTATUS = 2
Global Const $DT_BUSTYPE = 3
Global Const $PROXY_IE = 0
Global Const $PROXY_NONE = 1
Global Const $PROXY_SPECIFIED = 2
Global Const $OBJID_WINDOW = 0x00000000
Global Const $OBJID_TITLEBAR = 0xFFFFFFFE
Global Const $OBJID_SIZEGRIP = 0xFFFFFFF9
Global Const $OBJID_CARET = 0xFFFFFFF8
Global Const $OBJID_CURSOR = 0xFFFFFFF7
Global Const $OBJID_ALERT = 0xFFFFFFF6
Global Const $OBJID_SOUND = 0xFFFFFFF5
Global Const $DLG_CENTERONTOP = 0
Global Const $DLG_NOTITLE = 1
Global Const $DLG_NOTONTOP = 2
Global Const $DLG_TEXTLEFT = 4
Global Const $DLG_TEXTRIGHT = 8
Global Const $DLG_MOVEABLE = 16
Global Const $DLG_TEXTVCENTER = 32
Global Const $IDC_UNKNOWN = 0
Global Const $IDC_APPSTARTING = 1
Global Const $IDC_ARROW = 2
Global Const $IDC_CROSS = 3
Global Const $IDC_HAND = 32649
Global Const $IDC_HELP = 4
Global Const $IDC_IBEAM = 5
Global Const $IDC_ICON = 6
Global Const $IDC_NO = 7
Global Const $IDC_SIZE = 8
Global Const $IDC_SIZEALL = 9
Global Const $IDC_SIZENESW = 10
Global Const $IDC_SIZENS = 11
Global Const $IDC_SIZENWSE = 12
Global Const $IDC_SIZEWE = 13
Global Const $IDC_UPARROW = 14
Global Const $IDC_WAIT = 15
Global Const $IDI_APPLICATION = 32512
Global Const $IDI_ASTERISK = 32516
Global Const $IDI_EXCLAMATION = 32515
Global Const $IDI_HAND = 32513
Global Const $IDI_QUESTION = 32514
Global Const $IDI_WINLOGO = 32517
Global Const $IDI_SHIELD = 32518
Global Const $IDI_ERROR = $IDI_HAND
Global Const $IDI_INFORMATION = $IDI_ASTERISK
Global Const $IDI_WARNING = $IDI_EXCLAMATION
Global Const $SD_LOGOFF = 0
Global Const $SD_SHUTDOWN = 1
Global Const $SD_REBOOT = 2
Global Const $SD_FORCE = 4
Global Const $SD_POWERDOWN = 8
Global Const $SD_FORCEHUNG = 16
Global Const $SD_STANDBY = 32
Global Const $SD_HIBERNATE = 64
Global Const $STDIN_CHILD = 1
Global Const $STDOUT_CHILD = 2
Global Const $STDERR_CHILD = 4
Global Const $STDERR_MERGED = 8
Global Const $STDIO_INHERIT_PARENT = 0x10
Global Const $RUN_CREATE_NEW_CONSOLE = 0x00010000
Global Const $UBOUND_DIMENSIONS = 0
Global Const $UBOUND_ROWS = 1
Global Const $UBOUND_COLUMNS = 2
Global Const $MOUSEEVENTF_ABSOLUTE = 0x8000
Global Const $MOUSEEVENTF_MOVE = 0x0001
Global Const $MOUSEEVENTF_LEFTDOWN = 0x0002
Global Const $MOUSEEVENTF_LEFTUP = 0x0004
Global Const $MOUSEEVENTF_RIGHTDOWN = 0x0008
Global Const $MOUSEEVENTF_RIGHTUP = 0x0010
Global Const $MOUSEEVENTF_MIDDLEDOWN = 0x0020
Global Const $MOUSEEVENTF_MIDDLEUP = 0x0040
Global Const $MOUSEEVENTF_WHEEL = 0x0800
Global Const $MOUSEEVENTF_XDOWN = 0x0080
Global Const $MOUSEEVENTF_XUP = 0x0100
Global Const $REG_NONE = 0
Global Const $REG_SZ = 1
Global Const $REG_EXPAND_SZ = 2
Global Const $REG_BINARY = 3
Global Const $REG_DWORD = 4
Global Const $REG_DWORD_LITTLE_ENDIAN = 4
Global Const $REG_DWORD_BIG_ENDIAN = 5
Global Const $REG_LINK = 6
Global Const $REG_MULTI_SZ = 7
Global Const $REG_RESOURCE_LIST = 8
Global Const $REG_FULL_RESOURCE_DESCRIPTOR = 9
Global Const $REG_RESOURCE_REQUIREMENTS_LIST = 10
Global Const $REG_QWORD = 11
Global Const $REG_QWORD_LITTLE_ENDIAN = 11
Global Const $HWND_BOTTOM = 1
Global Const $HWND_NOTOPMOST = -2
Global Const $HWND_TOP = 0
Global Const $HWND_TOPMOST = -1
Global Const $SWP_NOSIZE = 0x0001
Global Const $SWP_NOMOVE = 0x0002
Global Const $SWP_NOZORDER = 0x0004
Global Const $SWP_NOREDRAW = 0x0008
Global Const $SWP_NOACTIVATE = 0x0010
Global Const $SWP_FRAMECHANGED = 0x0020
Global Const $SWP_DRAWFRAME = 0x0020
Global Const $SWP_SHOWWINDOW = 0x0040
Global Const $SWP_HIDEWINDOW = 0x0080
Global Const $SWP_NOCOPYBITS = 0x0100
Global Const $SWP_NOOWNERZORDER = 0x0200
Global Const $SWP_NOREPOSITION = 0x0200
Global Const $SWP_NOSENDCHANGING = 0x0400
Global Const $SWP_DEFERERASE = 0x2000
Global Const $SWP_ASYNCWINDOWPOS = 0x4000
Global Const $KEYWORD_DEFAULT = 1
Global Const $KEYWORD_NULL = 2
Global Const $DECLARED_LOCAL = -1
Global Const $DECLARED_UNKNOWN = 0
Global Const $DECLARED_GLOBAL = 1
Global Const $ASSIGN_CREATE = 0
Global Const $ASSIGN_FORCELOCAL = 1
Global Const $ASSIGN_FORCEGLOBAL = 2
Global Const $ASSIGN_EXISTFAIL = 4
Global Const $BI_ENABLE = 0
Global Const $BI_DISABLE = 1
Global Const $BREAK_ENABLE = 1
Global Const $BREAK_DISABLE = 0
Global Const $CDTRAY_OPEN = "open"
Global Const $CDTRAY_CLOSED = "closed"
Global Const $SEND_DEFAULT = 0
Global Const $SEND_RAW = 1
Global Const $DIR_DEFAULT = 0
Global Const $DIR_EXTENDED= 1
Global Const $DIR_NORECURSE = 2
Global Const $DIR_REMOVE= 1
Global Const $DT_ALL = "ALL"
Global Const $DT_CDROM = "CDROM"
Global Const $DT_REMOVABLE = "REMOVABLE"
Global Const $DT_FIXED = "FIXED"
Global Const $DT_NETWORK = "NETWORK"
Global Const $DT_RAMDISK = "RAMDISK"
Global Const $DT_UNKNOWN = "UNKNOWN"
Global Const $DT_UNDEFINED = 1
Global Const $DT_FAT = "FAT"
Global Const $DT_FAT32 = "FAT32"
Global Const $DT_EXFAT = "exFAT"
Global Const $DT_NTFS = "NTFS"
Global Const $DT_NWFS = "NWFS"
Global Const $DT_CDFS = "CDFS"
Global Const $DT_UDF = "UDF"
Global Const $DMA_DEFAULT = 0
Global Const $DMA_PERSISTENT = 1
Global Const $DMA_AUTHENTICATION = 8
Global Const $DS_UNKNOWN = "UNKNOWN"
Global Const $DS_READY = "READY"
Global Const $DS_NOTREADY = "NOTREADY"
Global Const $DS_INVALID = "INVALID"
Global Const $MOUSE_CLICK_LEFT = "left"
Global Const $MOUSE_CLICK_RIGHT = "right"
Global Const $MOUSE_CLICK_MIDDLE = "middle"
Global Const $MOUSE_CLICK_MAIN = "main"
Global Const $MOUSE_CLICK_MENU = "menu"
Global Const $MOUSE_CLICK_PRIMARY = "primary"
Global Const $MOUSE_CLICK_SECONDARY = "secondary"
Global Const $MOUSE_WHEEL_UP = "up"
Global Const $MOUSE_WHEEL_DOWN = "down"
Global Const $NUMBER_AUTO = 0
Global Const $NUMBER_32BIT = 1
Global Const $NUMBER_64BIT = 2
Global Const $NUMBER_DOUBLE = 3
Global Const $OBJ_NAME = 1
Global Const $OBJ_STRING = 2
Global Const $OBJ_PROGID = 3
Global Const $OBJ_FILE = 4
Global Const $OBJ_MODULE = 5
Global Const $OBJ_CLSID = 6
Global Const $OBJ_IID = 7
Global Const $EXITCLOSE_NORMAL = 0
Global Const $EXITCLOSE_BYEXIT = 1
Global Const $EXITCLOSE_BYCLICK = 2
Global Const $EXITCLOSE_BYLOGOFF = 3
Global Const $EXITCLOSE_BYSHUTDOWN = 4
Global Const $PROCESS_STATS_MEMORY = 0
Global Const $PROCESS_STATS_IO = 1
Global Const $PROCESS_LOW = 0
Global Const $PROCESS_BELOWNORMAL = 1
Global Const $PROCESS_NORMAL = 2
Global Const $PROCESS_ABOVENORMAL = 3
Global Const $PROCESS_HIGH = 4
Global Const $PROCESS_REALTIME = 5
Global Const $RUN_LOGON_NOPROFILE = 0
Global Const $RUN_LOGON_PROFILE = 1
Global Const $RUN_LOGON_NETWORK = 2
Global Const $RUN_LOGON_INHERIT = 4
Global Const $SOUND_NOWAIT = 0
Global Const $SOUND_WAIT = 1
Global Const $SHEX_OPEN = "open"
Global Const $SHEX_EDIT = "edit"
Global Const $SHEX_PRINT = "print"
Global Const $SHEX_PROPERTIES = "properties"
Global Const $TCP_DATA_DEFAULT = 0
Global Const $TCP_DATA_BINARY = 1
Global Const $UDP_OPEN_DEFAULT = 0
Global Const $UDP_OPEN_BROADCAST = 1
Global Const $UDP_DATA_DEFAULT = 0
Global Const $UDP_DATA_BINARY = 1
Global Const $UDP_DATA_ARRAY = 2
Global Const $TIP_NOICON = 0
Global Const $TIP_INFOICON = 1
Global Const $TIP_WARNINGICON = 2
Global Const $TIP_ERRORICON = 3
Global Const $TIP_BALLOON = 1
Global Const $TIP_CENTER = 2
Global Const $TIP_FORCEVISIBLE = 4
Global Const $WINDOWS_NOONTOP = 0
Global Const $WINDOWS_ONTOP = 1
Global Const $WIN_STATE_EXISTS = 1
Global Const $WIN_STATE_VISIBLE  = 2
Global Const $WIN_STATE_ENABLED = 4
Global Const $WIN_STATE_ACTIVE = 8
Global Const $WIN_STATE_MINIMIZED = 16
Global Const $WIN_STATE_MAXIMIZED = 32
Global Const $_UDF_GlobalIDs_OFFSET = 2
Global Const $_UDF_GlobalID_MAX_WIN = 16
Global Const $_UDF_STARTID = 10000
Global Const $_UDF_GlobalID_MAX_IDS = 55535
Global Const $__UDFGUICONSTANT_WS_TABSTOP = 0x00010000
Global Const $__UDFGUICONSTANT_WS_VISIBLE = 0x10000000
Global Const $__UDFGUICONSTANT_WS_CHILD = 0x40000000
Global $__g_aUDF_GlobalIDs_Used[$_UDF_GlobalID_MAX_WIN][$_UDF_GlobalID_MAX_IDS + $_UDF_GlobalIDs_OFFSET + 1]
Func __UDF_GetNextGlobalID($hWnd)
Local $nCtrlID, $iUsedIndex = -1, $bAllUsed = True
If Not WinExists($hWnd) Then Return SetError(-1, -1, 0)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] <> 0 Then
If Not WinExists($__g_aUDF_GlobalIDs_Used[$iIndex][0]) Then
For $x = 0 To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Next
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
EndIf
EndIf
Next
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
If $iUsedIndex = -1 Then
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = 0 Then
$__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd
$__g_aUDF_GlobalIDs_Used[$iIndex][1] = $_UDF_STARTID
$bAllUsed = False
$iUsedIndex = $iIndex
ExitLoop
EndIf
Next
EndIf
If $iUsedIndex = -1 And $bAllUsed Then Return SetError(16, 0, 0)
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] = $_UDF_STARTID + $_UDF_GlobalID_MAX_IDS Then
For $iIDIndex = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = 0 Then
$nCtrlID = ($iIDIndex - $_UDF_GlobalIDs_OFFSET) + 10000
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][$iIDIndex] = $nCtrlID
Return $nCtrlID
EndIf
Next
Return SetError(-1, $_UDF_GlobalID_MAX_IDS, 0)
EndIf
$nCtrlID = $__g_aUDF_GlobalIDs_Used[$iUsedIndex][1]
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][1] += 1
$__g_aUDF_GlobalIDs_Used[$iUsedIndex][($nCtrlID - 10000) + $_UDF_GlobalIDs_OFFSET] = $nCtrlID
Return $nCtrlID
EndFunc
Func __UDF_FreeGlobalID($hWnd, $iGlobalID)
If $iGlobalID - $_UDF_STARTID < 0 Or $iGlobalID - $_UDF_STARTID > $_UDF_GlobalID_MAX_IDS Then Return SetError(-1, 0, False)
For $iIndex = 0 To $_UDF_GlobalID_MAX_WIN - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][0] = $hWnd Then
For $x = $_UDF_GlobalIDs_OFFSET To UBound($__g_aUDF_GlobalIDs_Used, $UBOUND_COLUMNS) - 1
If $__g_aUDF_GlobalIDs_Used[$iIndex][$x] = $iGlobalID Then
$__g_aUDF_GlobalIDs_Used[$iIndex][$x] = 0
Return True
EndIf
Next
Return SetError(-3, 0, False)
EndIf
Next
Return SetError(-2, 0, False)
EndFunc
Global Const $STR_NOCASESENSE = 0
Global Const $STR_CASESENSE = 1
Global Const $STR_NOCASESENSEBASIC = 2
Global Const $STR_STRIPLEADING = 1
Global Const $STR_STRIPTRAILING = 2
Global Const $STR_STRIPSPACES = 4
Global Const $STR_STRIPALL = 8
Global Const $STR_CHRSPLIT = 0
Global Const $STR_ENTIRESPLIT = 1
Global Const $STR_NOCOUNT = 2
Global Const $STR_REGEXPMATCH = 0
Global Const $STR_REGEXPARRAYMATCH = 1
Global Const $STR_REGEXPARRAYFULLMATCH = 2
Global Const $STR_REGEXPARRAYGLOBALMATCH = 3
Global Const $STR_REGEXPARRAYGLOBALFULLMATCH = 4
Global Const $STR_ENDISSTART = 0
Global Const $STR_ENDNOTSTART = 1
Global Const $SB_ANSI = 1
Global Const $SB_UTF16LE = 2
Global Const $SB_UTF16BE = 3
Global Const $SB_UTF8 = 4
Global Const $SE_UTF16 = 0
Global Const $SE_ANSI = 1
Global Const $SE_UTF8 = 2
Global Const $STR_UTF16 = 0
Global Const $STR_UCS2 = 1
Global Const $tagPOINT = "struct;long X;long Y;endstruct"
Global Const $tagRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
Global Const $tagSIZE = "struct;long X;long Y;endstruct"
Global Const $tagMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
Global Const $tagFILETIME = "struct;dword Lo;dword Hi;endstruct"
Global Const $tagSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
Global Const $tagTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
Global Const $tagNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
Global Const $tagCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" &  "int Indent;lparam Param"
Global Const $tagNMCBEDRAGBEGIN = $tagNMHDR & ";int ItemID;wchar szText[260]"
Global Const $tagNMCBEENDEDIT = $tagNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
Global Const $tagNMCOMBOBOXEX = $tagNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" &  "int SelectedImage;int OverlayImage;int Indent;lparam Param"
Global Const $tagDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" &  "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" &  "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
Global Const $tagNMDATETIMECHANGE = $tagNMHDR & ";dword Flag;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMEFORMAT = $tagNMHDR & ";ptr Format;" & $tagSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
Global Const $tagNMDATETIMEFORMATQUERY = $tagNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
Global Const $tagNMDATETIMEKEYDOWN = $tagNMHDR & ";int VirtKey;ptr Format;" & $tagSYSTEMTIME
Global Const $tagNMDATETIMESTRING = $tagNMHDR & ";ptr UserString;" & $tagSYSTEMTIME & ";dword Flags"
Global Const $tagEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" &  "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" &  "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
Global Const $tagGDIP_EFFECTPARAMS_Blur = "float Radius; bool ExpandEdge"
Global Const $tagGDIP_EFFECTPARAMS_BrightnessContrast = "int BrightnessLevel; int ContrastLevel"
Global Const $tagGDIP_EFFECTPARAMS_ColorBalance = "int CyanRed; int MagentaGreen; int YellowBlue"
Global Const $tagGDIP_EFFECTPARAMS_ColorCurve = "int Adjustment; int Channel; int AdjustValue"
Global Const $tagGDIP_EFFECTPARAMS_ColorLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
Global Const $tagGDIP_EFFECTPARAMS_HueSaturationLightness = "int HueLevel; int SaturationLevel; int LightnessLevel"
Global Const $tagGDIP_EFFECTPARAMS_Levels = "int Highlight; int Midtone; int Shadow"
Global Const $tagGDIP_EFFECTPARAMS_RedEyeCorrection = "uint NumberOfAreas; ptr Areas"
Global Const $tagGDIP_EFFECTPARAMS_Sharpen = "float Radius; float Amount"
Global Const $tagGDIP_EFFECTPARAMS_Tint = "int Hue; int Amount"
Global Const $tagGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
Global Const $tagGDIPCOLORMATRIX = "float m[25]"
Global Const $tagGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
Global Const $tagGDIPENCODERPARAMS = "uint Count;" & $tagGDIPENCODERPARAM
Global Const $tagGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
Global Const $tagGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
Global Const $tagGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
Global Const $tagGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" &  "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
Global Const $tagGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
Global Const $tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $tagNMHDDISPINFO = $tagNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
Global Const $tagNMHDFILTERBTNCLICK = $tagNMHDR & ";int Item;" & $tagRECT
Global Const $tagNMHEADER = $tagNMHDR & ";int Item;int Button;ptr pItem"
Global Const $tagGETIPAddress = "byte Field4;byte Field3;byte Field2;byte Field1"
Global Const $tagNMIPADDRESS = $tagNMHDR & ";int Field;int Value"
Global Const $tagLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $tagPOINT & ";uint Direction;endstruct"
Global Const $tagLVHITTESTINFO = $tagPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
Global Const $tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
Global Const $tagNMLISTVIEW = $tagNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" &  "struct;long ActionX;long ActionY;endstruct;lparam Param"
Global Const $tagNMLVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword dwDrawStage;handle hdc;" & $tagRECT &  ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" &  ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" &  "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
Global Const $tagNMLVDISPINFO = $tagNMHDR & ";" & $tagLVITEM
Global Const $tagNMLVFINDITEM = $tagNMHDR & ";int Start;" & $tagLVFINDINFO
Global Const $tagNMLVGETINFOTIP = $tagNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
Global Const $tagNMITEMACTIVATE = $tagNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" &  $tagPOINT & ";lparam lParam;uint KeyFlags"
Global Const $tagNMLVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMLVSCROLL = $tagNMHDR & ";int DX;int DY"
Global Const $tagMCHITTESTINFO = "uint Size;" & $tagPOINT & ";uint Hit;" & $tagSYSTEMTIME &  ";" & $tagRECT & ";int iOffset;int iRow;int iCol"
Global Const $tagMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short Span"
Global Const $tagMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds;short MinSet;short MaxSet"
Global Const $tagMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" &  "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" &  "word MaxMSeconds"
Global Const $tagNMDAYSTATE = $tagNMHDR & ";" & $tagSYSTEMTIME & ";int DayState;ptr pDayState"
Global Const $tagNMSELCHANGE = $tagNMHDR &  ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" &  "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
Global Const $tagNMOBJECTNOTIFY = $tagNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
Global Const $tagNMTCKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" &  "int Children;lparam Param;endstruct"
Global Const $tagTVITEMEX = "struct;" & $tagTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
Global Const $tagNMTREEVIEW = $tagNMHDR & ";uint Action;" &  "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" &  "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" &  "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" &  "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" &  "struct;long PointX;long PointY;endstruct"
Global Const $tagNMTVCUSTOMDRAW = "struct;" & $tagNMHDR & ";dword DrawStage;handle HDC;" & $tagRECT &  ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" &  ";dword ClrText;dword ClrTextBk;int Level"
Global Const $tagNMTVDISPINFO = $tagNMHDR & ";" & $tagTVITEM
Global Const $tagNMTVGETINFOTIP = $tagNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
Global Const $tagNMTVITEMCHANGE = $tagNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
Global Const $tagTVHITTESTINFO = $tagPOINT & ";uint Flags;handle Item"
Global Const $tagNMTVKEYDOWN = "align 1;" & $tagNMHDR & ";word VKey;uint Flags"
Global Const $tagNMMOUSE = $tagNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $tagPOINT & ";lparam HitInfo"
Global Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Global Const $tagIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $tagRECT
Global Const $tagMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
Global Const $tagMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" &  "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
Global Const $tagREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" &  "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" &  "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVersion = "WIN_XP") ? "" : ";" & $tagRECT & ";uint uChevronState")
Global Const $tagNMREBARAUTOBREAK = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
Global Const $tagNMRBAUTOSIZE = $tagNMHDR & ";bool fChanged;" &  "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" &  "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
Global Const $tagNMREBAR = $tagNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
Global Const $tagNMREBARCHEVRON = $tagNMHDR & ";uint uBand;uint wID;lparam lParam;" & $tagRECT & ";lparam lParamNM"
Global Const $tagNMREBARCHILDSIZE = $tagNMHDR & ";uint uBand;uint wID;" &  "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" &  "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
Global Const $tagCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
Global Const $tagNMTOOLBAR = $tagNMHDR & ";int iItem;" &  "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" &  ";int cchText;ptr pszText;" & $tagRECT
Global Const $tagNMTBHOTITEM = $tagNMHDR & ";int idOld;int idNew;dword dwFlags"
Global Const $tagTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
Global Const $tagTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
Global Const $tagNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
Global Const $tagOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
Global Const $tagOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" &  "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" &  "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" &  "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
Global Const $tagBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" &  "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
Global Const $tagBITMAPINFO = $tagBITMAPINFOHEADER & ";dword biRGBQuad[1]"
Global Const $tagBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
Global Const $tagGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
Global Const $tagWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
Global Const $tagWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
Global Const $tagSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
Global Const $tagSCROLLBARINFO = "dword cbSize;" & $tagRECT & ";int dxyLineButton;int xyThumbTop;" &  "int xyThumbBottom;int reserved;dword rgstate[6]"
Global Const $tagLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" &  "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
Global Const $tagKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
Global Const $tagPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
Global Const $tagSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" &  "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" &  "handle StdOutput;handle StdError"
Global Const $tagSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
Global Const $tagWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
Global Const $tagTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" &  "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" &  "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" &  "byte tmPitchAndFamily;byte tmCharSet"
Global Const $MB_OK = 0
Global Const $MB_OKCANCEL = 1
Global Const $MB_ABORTRETRYIGNORE = 2
Global Const $MB_YESNOCANCEL = 3
Global Const $MB_YESNO = 4
Global Const $MB_RETRYCANCEL = 5
Global Const $MB_CANCELTRYCONTINUE = 6
Global Const $MB_HELP = 0x4000
Global Const $MB_ICONSTOP = 16
Global Const $MB_ICONERROR = 16
Global Const $MB_ICONHAND = 16
Global Const $MB_ICONQUESTION = 32
Global Const $MB_ICONEXCLAMATION = 48
Global Const $MB_ICONWARNING = 48
Global Const $MB_ICONINFORMATION = 64
Global Const $MB_ICONASTERISK = 64
Global Const $MB_USERICON = 0x00000080
Global Const $MB_DEFBUTTON1 = 0
Global Const $MB_DEFBUTTON2 = 256
Global Const $MB_DEFBUTTON3 = 512
Global Const $MB_DEFBUTTON4 = 768
Global Const $MB_APPLMODAL = 0
Global Const $MB_SYSTEMMODAL = 4096
Global Const $MB_TASKMODAL = 8192
Global Const $MB_DEFAULT_DESKTOP_ONLY = 0x00020000
Global Const $MB_RIGHT = 0x00080000
Global Const $MB_RTLREADING = 0x00100000
Global Const $MB_SETFOREGROUND = 0x00010000
Global Const $MB_TOPMOST = 0x00040000
Global Const $MB_SERVICE_NOTIFICATION = 0x00200000
Global Const $MB_RIGHTJUSTIFIED = $MB_RIGHT
Global Const $IDTIMEOUT = -1
Global Const $IDOK = 1
Global Const $IDCANCEL = 2
Global Const $IDABORT = 3
Global Const $IDRETRY = 4
Global Const $IDIGNORE = 5
Global Const $IDYES = 6
Global Const $IDNO = 7
Global Const $IDCLOSE = 8
Global Const $IDHELP = 9
Global Const $IDTRYAGAIN = 10
Global Const $IDCONTINUE = 11
#Region Global Variables and Constants
Global $__g_vEnum, $__g_vExt = 0
Global $__g_iRGBMode = 1
Global Const $tagOSVERSIONINFO = 'struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct'
Global Const $IMAGE_BITMAP = 0
Global Const $IMAGE_ICON = 1
Global Const $IMAGE_CURSOR = 2
Global Const $IMAGE_ENHMETAFILE = 3
Global Const $LR_DEFAULTCOLOR = 0x0000
Global Const $LR_MONOCHROME = 0x0001
Global Const $LR_COLOR = 0x0002
Global Const $LR_COPYRETURNORG = 0x0004
Global Const $LR_COPYDELETEORG = 0x0008
Global Const $LR_LOADFROMFILE = 0x0010
Global Const $LR_LOADTRANSPARENT = 0x0020
Global Const $LR_DEFAULTSIZE = 0x0040
Global Const $LR_VGACOLOR = 0x0080
Global Const $LR_LOADMAP3DCOLORS = 0x1000
Global Const $LR_CREATEDIBSECTION = 0x2000
Global Const $LR_COPYFROMRESOURCE = 0x4000
Global Const $LR_SHARED = 0x8000
Global Const $__tagCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
Global Const $__WINVER = __WINVER()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateFile($sFileName, $iCreation, $iAccess = 4, $iShare = 0, $iAttributes = 0, $tSecurity = 0)
Local $iDA = 0, $iSM = 0, $iCD = 0, $iFA = 0
If BitAND($iAccess, 1) <> 0 Then $iDA = BitOR($iDA, $GENERIC_EXECUTE)
If BitAND($iAccess, 2) <> 0 Then $iDA = BitOR($iDA, $GENERIC_READ)
If BitAND($iAccess, 4) <> 0 Then $iDA = BitOR($iDA, $GENERIC_WRITE)
If BitAND($iShare, 1) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_DELETE)
If BitAND($iShare, 2) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_READ)
If BitAND($iShare, 4) <> 0 Then $iSM = BitOR($iSM, $FILE_SHARE_WRITE)
Switch $iCreation
Case 0
$iCD = $CREATE_NEW
Case 1
$iCD = $CREATE_ALWAYS
Case 2
$iCD = $OPEN_EXISTING
Case 3
$iCD = $OPEN_ALWAYS
Case 4
$iCD = $TRUNCATE_EXISTING
EndSwitch
If BitAND($iAttributes, 1) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_ARCHIVE)
If BitAND($iAttributes, 2) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_HIDDEN)
If BitAND($iAttributes, 4) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_READONLY)
If BitAND($iAttributes, 8) <> 0 Then $iFA = BitOR($iFA, $FILE_ATTRIBUTE_SYSTEM)
Local $aResult = DllCall("kernel32.dll", "handle", "CreateFileW", "wstr", $sFileName, "dword", $iDA, "dword", $iSM,  "struct*", $tSecurity, "dword", $iCD, "dword", $iFA, "ptr", 0)
If @error Or ($aResult[0] = Ptr(-1)) Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FreeLibrary($hModule)
Local $aResult = DllCall("kernel32.dll", "bool", "FreeLibrary", "handle", $hModule)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCursorInfo()
Local $tCursor = DllStructCreate($__tagCURSORINFO)
Local $iCursor = DllStructGetSize($tCursor)
DllStructSetData($tCursor, "Size", $iCursor)
Local $aRet = DllCall("user32.dll", "bool", "GetCursorInfo", "struct*", $tCursor)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aCursor[5]
$aCursor[0] = True
$aCursor[1] = DllStructGetData($tCursor, "Flags") <> 0
$aCursor[2] = DllStructGetData($tCursor, "hCursor")
$aCursor[3] = DllStructGetData($tCursor, "X")
$aCursor[4] = DllStructGetData($tCursor, "Y")
Return $aCursor
EndFunc
Func _WinAPI_GetDlgCtrlID($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetDlgCtrlID", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetModuleHandle($sModuleName)
Local $sModuleNameType = "wstr"
If $sModuleName = "" Then
$sModuleName = 0
$sModuleNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "GetModuleHandleW", $sModuleNameType, $sModuleName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetString($pString, $bUnicode = True)
Local $iLength = _WinAPI_StrLen($pString, $bUnicode)
If @error Or Not $iLength Then Return SetError(@error + 10, @extended, '')
Local $tString = DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($iLength, DllStructGetData($tString, 1))
EndFunc
Func _WinAPI_IsWow64Process($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', ($__WINVER < 0x0600 ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsWow64Process', 'handle', $hProcess[0], 'bool*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, False)
Return $aRet[2]
EndFunc
Func _WinAPI_LoadImage($hInstance, $sImage, $iType, $iXDesired, $iYDesired, $iLoad)
Local $aResult, $sImageType = "int"
If IsString($sImage) Then $sImageType = "wstr"
$aResult = DllCall("user32.dll", "handle", "LoadImageW", "handle", $hInstance, $sImageType, $sImage, "uint", $iType,  "int", $iXDesired, "int", $iYDesired, "uint", $iLoad)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadLibrary($sFileName)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sFileName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_PathIsDirectory($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsDirectoryW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ReadFile($hFile, $pBuffer, $iToRead, ByRef $iRead, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToRead,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[4]
Return $aResult[0]
EndFunc
Func _WinAPI_StrLen($pString, $bUnicode = True)
Local $W = ''
If $bUnicode Then $W = 'W'
Local $aRet = DllCall('kernel32.dll', 'int', 'lstrlen' & $W, 'struct*', $pString)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchColor($iColor)
If $iColor = -1 Then Return $iColor
Return BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndFunc
Func _WinAPI_WriteFile($hFile, $pBuffer, $iToWrite, ByRef $iWritten, $tOverlapped = 0)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteFile", "handle", $hFile, "struct*", $pBuffer, "dword", $iToWrite,  "dword*", 0, "struct*", $tOverlapped)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[4]
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __CheckErrorArrayBounds(Const ByRef $aData, ByRef $iStart, ByRef $iEnd, $nDim = 1, $iDim = $UBOUND_DIMENSIONS)
If Not IsArray($aData) Then Return SetError(1, 0, 1)
If UBound($aData, $iDim) <> $nDim Then Return SetError(2, 0, 1)
If $iStart < 0 Then $iStart = 0
Local $iUBound = UBound($aData) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart > $iEnd Then Return SetError(4, 0, 1)
Return 0
EndFunc
Func __CheckErrorCloseHandle($aRet, $hFile, $bLastError = False, $iCurErr = @error, $iCurExt = @extended)
If Not $iCurErr And Not $aRet[0] Then $iCurErr = 10
Local $aLastError = DllCall("kernel32.dll", "dword", "GetLastError")
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hFile)
If $iCurErr Then DllCall("kernel32.dll", "none", "SetLastError", "dword", $aLastError[0])
If $bLastError Then $iCurExt = $aLastError[0]
Return SetError($iCurErr, $iCurExt, $iCurErr)
EndFunc
Func __DLL($sPath, $bPin = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', ($bPin ? 0x0001 : 0x0002), "wstr", $sPath, 'ptr*', 0)
If Not $aRet[3] Then
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryW", "wstr", $sPath)
If Not $aResult[0] Then Return 0
EndIf
Return 1
EndFunc
Func __EnumWindowsProc($hWnd, $bVisible)
Local $aResult
If $bVisible Then
$aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If Not $aResult[0] Then
Return 1
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hWnd
$aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
$__g_vEnum[$__g_vEnum[0][0]][1] = $aResult[2]
Return 1
EndFunc
Func __FatalExit($iCode, $sText = '')
If $sText Then MsgBox($MB_SYSTEMMODAL, 'AutoIt', $sText)
DllCall('kernel32.dll', 'none', 'FatalExit', 'int', $iCode)
EndFunc
Func __Inc(ByRef $aData, $iIncrement = 100)
Select
Case UBound($aData, $UBOUND_COLUMNS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0][0] + 1][UBound($aData, $UBOUND_COLUMNS)]
Else
$aData[0][0] += 1
If $aData[0][0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0][0] + $iIncrement][UBound($aData, $UBOUND_COLUMNS)]
EndIf
EndIf
Case UBound($aData, $UBOUND_ROWS)
If $iIncrement < 0 Then
ReDim $aData[$aData[0] + 1]
Else
$aData[0] += 1
If $aData[0] > UBound($aData) - 1 Then
ReDim $aData[$aData[0] + $iIncrement]
EndIf
EndIf
Case Else
Return 0
EndSelect
Return 1
EndFunc
Func __RGB($iColor)
If $__g_iRGBMode Then
$iColor = _WinAPI_SwitchColor($iColor)
EndIf
Return $iColor
EndFunc
Func __WINVER()
Local $tOSVI = DllStructCreate($tagOSVERSIONINFO)
DllStructSetData($tOSVI, 1, DllStructGetSize($tOSVI))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVI)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return BitOR(BitShift(DllStructGetData($tOSVI, 2), -8), DllStructGetData($tOSVI, 3))
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CharToOem($sStr)
Local $aRet = DllCall('user32.dll', 'bool', 'CharToOemW', 'wstr', $sStr, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_ClientToScreen($hWnd, ByRef $tPoint)
Local $aRet = DllCall("user32.dll", "bool", "ClientToScreen", "hwnd", $hWnd, "struct*", $tPoint)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_DWordToFloat($iValue)
Local $tDWord = DllStructCreate('dword')
Local $tFloat = DllStructCreate('float', DllStructGetPtr($tDWord))
DllStructSetData($tDWord, 1, $iValue)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_DWordToInt($iValue)
Local $tData = DllStructCreate('int')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_FloatToDWord($iValue)
Local $tFloat = DllStructCreate('float')
Local $tDWord = DllStructCreate('dword', DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $iValue)
Return DllStructGetData($tDWord, 1)
EndFunc
Func _WinAPI_FloatToInt($nFloat)
Local $tFloat = DllStructCreate("float")
Local $tInt = DllStructCreate("int", DllStructGetPtr($tFloat))
DllStructSetData($tFloat, 1, $nFloat)
Return DllStructGetData($tInt, 1)
EndFunc
Func _WinAPI_GetXYFromPoint(ByRef $tPoint, ByRef $iX, ByRef $iY)
$iX = DllStructGetData($tPoint, "X")
$iY = DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_GUIDFromString($sGUID)
Local $tGUID = DllStructCreate($tagGUID)
_WinAPI_GUIDFromStringEx($sGUID, $tGUID)
If @error Then Return SetError(@error + 10, @extended, 0)
Return $tGUID
EndFunc
Func _WinAPI_GUIDFromStringEx($sGUID, $tGUID)
Local $aResult = DllCall("ole32.dll", "long", "CLSIDFromString", "wstr", $sGUID, "struct*", $tGUID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_HashData($pMemory, $iSize, $iLength = 32)
If ($iLength <= 0) Or ($iLength > 256) Then Return SetError(11, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aRet = DllCall('shlwapi.dll', 'uint', 'HashData', 'struct*', $pMemory, 'dword', $iSize, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_HashString($sString, $bCaseSensitive = True, $iLength = 32)
Local $iLengthS = StringLen($sString)
If Not $iLengthS Or ($iLength > 256) Then Return SetError(12, 0, 0)
Local $tString = DllStructCreate('wchar[' & ($iLengthS + 1) & ']')
If Not $bCaseSensitive Then
$sString = StringLower($sString)
EndIf
DllStructSetData($tString, 1, $sString)
Local $sHash = _WinAPI_HashData($tString, 2 * $iLengthS, $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return $sHash
EndFunc
Func _WinAPI_HiByte($iValue)
Return BitAND(BitShift($iValue, 8), 0xFF)
EndFunc
Func _WinAPI_HiDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 2)
EndFunc
Func _WinAPI_HiWord($iLong)
Return BitShift($iLong, 16)
EndFunc
Func _WinAPI_IntToDWord($iValue)
Local $tData = DllStructCreate('dword')
DllStructSetData($tData, 1, $iValue)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_IntToFloat($iInt)
Local $tInt = DllStructCreate("int")
Local $tFloat = DllStructCreate("float", DllStructGetPtr($tInt))
DllStructSetData($tInt, 1, $iInt)
Return DllStructGetData($tFloat, 1)
EndFunc
Func _WinAPI_LoByte($iValue)
Return BitAND($iValue, 0xFF)
EndFunc
Func _WinAPI_LoDWord($iValue)
Local $tInt64 = DllStructCreate('int64')
Local $tQWord = DllStructCreate('dword;dword', DllStructGetPtr($tInt64))
DllStructSetData($tInt64, 1, $iValue)
Return DllStructGetData($tQWord, 1)
EndFunc
Func _WinAPI_LoWord($iLong)
Return BitAND($iLong, 0xFFFF)
EndFunc
Func _WinAPI_LongMid($iValue, $iStart, $iCount)
Return BitAND(BitShift($iValue, $iStart), BitOR(BitShift(BitShift(0x7FFFFFFF, 32 - ($iCount + 1)), 1), BitShift(1, -($iCount - 1))))
EndFunc
Func _WinAPI_MAKELANGID($iLngIDPrimary, $iLngIDSub)
Return BitOR(BitShift($iLngIDSub, -10), $iLngIDPrimary)
EndFunc
Func _WinAPI_MAKELCID($iLngID, $iSortID)
Return BitOR(BitShift($iSortID, -16), $iLngID)
EndFunc
Func _WinAPI_MakeLong($iLo, $iHi)
Return BitOR(BitShift($iHi, -16), BitAND($iLo, 0xFFFF))
EndFunc
Func _WinAPI_MakeQWord($iLoDWORD, $iHiDWORD)
Local $tInt64 = DllStructCreate("uint64")
Local $tDwords = DllStructCreate("dword;dword", DllStructGetPtr($tInt64))
DllStructSetData($tDwords, 1, $iLoDWORD)
DllStructSetData($tDwords, 2, $iHiDWORD)
Return DllStructGetData($tInt64, 1)
EndFunc
Func _WinAPI_MakeWord($iLo, $iHi)
Local $tWord = DllStructCreate('ushort')
Local $tByte = DllStructCreate('byte;byte', DllStructGetPtr($tWord))
DllStructSetData($tByte, 1, $iHi)
DllStructSetData($tByte, 2, $iLo)
Return DllStructGetData($tWord, 1)
EndFunc
Func _WinAPI_MultiByteToWideChar($vText, $iCodePage = 0, $iFlags = 0, $bRetString = False)
Local $sTextType = "str"
If Not IsString($vText) Then $sTextType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags,  $sTextType, $vText, "int", -1, "ptr", 0, "int", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $iOut = $aResult[0]
Local $tOut = DllStructCreate("wchar[" & $iOut & "]")
$aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, $sTextType, $vText,  "int", -1, "struct*", $tOut, "int", $iOut)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, 0)
If $bRetString Then Return DllStructGetData($tOut, 1)
Return $tOut
EndFunc
Func _WinAPI_MultiByteToWideCharEx($sText, $pText, $iCodePage = 0, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "int", "MultiByteToWideChar", "uint", $iCodePage, "dword", $iFlags, "STR", $sText,  "int", -1, "struct*", $pText, "int", (StringLen($sText) + 1) * 2)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_OemToChar($sStr)
Local $aRet = DllCall('user32.dll', 'bool', 'OemToChar', 'str', $sStr, 'str', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PointFromRect(ByRef $tRECT, $bCenter = True)
Local $iX1 = DllStructGetData($tRECT, "Left")
Local $iY1 = DllStructGetData($tRECT, "Top")
Local $iX2 = DllStructGetData($tRECT, "Right")
Local $iY2 = DllStructGetData($tRECT, "Bottom")
If $bCenter Then
$iX1 = $iX1 + (($iX2 - $iX1) / 2)
$iY1 = $iY1 + (($iY2 - $iY1) / 2)
EndIf
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iX1)
DllStructSetData($tPoint, "Y", $iY1)
Return $tPoint
EndFunc
Func _WinAPI_PrimaryLangId($iLngID)
Return BitAND($iLngID, 0x3FF)
EndFunc
Func _WinAPI_ScreenToClient($hWnd, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShortToWord($iValue)
Return BitAND($iValue, 0x0000FFFF)
EndFunc
Func _WinAPI_StrFormatByteSize($iSize)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'StrFormatByteSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_StrFormatByteSizeEx($iSize)
Local $aSymbol = DllCall('kernel32.dll', 'int', 'GetLocaleInfoW', 'dword', 0x0400, 'dword', 0x000F, 'wstr', '', 'int', 2048)
If @error Then Return SetError(@error + 10, @extended, '')
Local $sSize = _WinAPI_StrFormatByteSize(0)
If @error Then Return SetError(@error, @extended, '')
Return StringReplace($sSize, '0', StringRegExpReplace(Number($iSize), '(?<=\d)(?=(\d{3})+\z)', $aSymbol[3]))
EndFunc
Func _WinAPI_StrFormatKBSize($iSize)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'StrFormatKBSizeW', 'int64', $iSize, 'wstr', '', 'uint', 1024)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_StrFromTimeInterval($iTime, $iDigits = 7)
Local $aRet = DllCall('shlwapi.dll', 'int', 'StrFromTimeIntervalW', 'wstr', '', 'uint', 1024, 'dword', $iTime,  'int', $iDigits)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return StringStripWS($aRet[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_StringFromGUID($tGUID)
Local $aResult = DllCall("ole32.dll", "int", "StringFromGUID2", "struct*", $tGUID, "wstr", "", "int", 40)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_SubLangId($iLngID)
Return BitShift($iLngID, 10)
EndFunc
Func _WinAPI_SwapDWord($iValue)
Local $tStruct1 = DllStructCreate('dword;dword')
Local $tStruct2 = DllStructCreate('byte[4];byte[4]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 4
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 5 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapQWord($iValue)
Local $tStruct1 = DllStructCreate('int64;int64')
Local $tStruct2 = DllStructCreate('byte[8];byte[8]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 8
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 9 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_SwapWord($iValue)
Local $tStruct1 = DllStructCreate('word;word')
Local $tStruct2 = DllStructCreate('byte[2];byte[2]', DllStructGetPtr($tStruct1))
DllStructSetData($tStruct1, 1, $iValue)
For $i = 1 To 2
DllStructSetData($tStruct2, 2, DllStructGetData($tStruct2, 1, 3 - $i), $i)
Next
Return DllStructGetData($tStruct1, 2)
EndFunc
Func _WinAPI_WideCharToMultiByte($vUnicode, $iCodePage = 0, $bRetNoStruct = True, $bRetBinary = False)
Local $sUnicodeType = "wstr"
If Not IsString($vUnicode) Then $sUnicodeType = "struct*"
Local $aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode, "int", -1,  "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 20, @extended, "")
Local $tMultiByte = DllStructCreate((($bRetBinary) ? ("byte") : ("char")) & "[" & $aResult[0] & "]")
$aResult = DllCall("kernel32.dll", "int", "WideCharToMultiByte", "uint", $iCodePage, "dword", 0, $sUnicodeType, $vUnicode,  "int", -1, "struct*", $tMultiByte, "int", $aResult[0], "ptr", 0, "ptr", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
If $bRetNoStruct Then Return DllStructGetData($tMultiByte, 1)
Return $tMultiByte
EndFunc
Func _WinAPI_WordToShort($iValue)
If BitAND($iValue, 0x00008000) Then
Return BitOR($iValue, 0xFFFF8000)
EndIf
Return BitAND($iValue, 0x00007FFF)
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $DUPLICATE_CLOSE_SOURCE = 0x00000001
Global Const $DUPLICATE_SAME_ACCESS = 0x00000002
Global Const $OBJ_BITMAP = 7
Global Const $OBJ_BRUSH = 2
Global Const $OBJ_COLORSPACE = 14
Global Const $OBJ_DC = 3
Global Const $OBJ_ENHMETADC = 12
Global Const $OBJ_ENHMETAFILE = 13
Global Const $OBJ_EXTPEN = 11
Global Const $OBJ_FONT = 6
Global Const $OBJ_MEMDC = 10
Global Const $OBJ_METADC = 4
Global Const $OBJ_METAFILE = 9
Global Const $OBJ_PAL = 5
Global Const $OBJ_PEN = 1
Global Const $OBJ_REGION = 8
Global Const $NULL_BRUSH = 5
Global Const $NULL_PEN = 8
Global Const $BLACK_BRUSH = 4
Global Const $DKGRAY_BRUSH = 3
Global Const $DC_BRUSH = 18
Global Const $GRAY_BRUSH = 2
Global Const $HOLLOW_BRUSH = $NULL_BRUSH
Global Const $LTGRAY_BRUSH = 1
Global Const $WHITE_BRUSH = 0
Global Const $BLACK_PEN = 7
Global Const $DC_PEN = 19
Global Const $WHITE_PEN = 6
Global Const $ANSI_FIXED_FONT = 11
Global Const $ANSI_VAR_FONT = 12
Global Const $DEVICE_DEFAULT_FONT = 14
Global Const $DEFAULT_GUI_FONT = 17
Global Const $OEM_FIXED_FONT = 10
Global Const $SYSTEM_FONT = 13
Global Const $SYSTEM_FIXED_FONT = 16
Global Const $DEFAULT_PALETTE = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CloseHandle($hObject)
Local $aResult = DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteObject($hObject)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hObject)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DuplicateHandle($hSourceProcessHandle, $hSourceHandle, $hTargetProcessHandle, $iDesiredAccess, $iInheritHandle, $iOptions)
Local $aResult = DllCall("kernel32.dll", "bool", "DuplicateHandle",  "handle", $hSourceProcessHandle,  "handle", $hSourceHandle,  "handle", $hTargetProcessHandle,  "handle*", 0,  "dword", $iDesiredAccess,  "bool", $iInheritHandle,  "dword", $iOptions)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[4]
EndFunc
Func _WinAPI_GetCurrentObject($hDC, $iType)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetCurrentObject', 'handle', $hDC, 'uint', $iType)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObject($hObject, $iSize, $pObject)
Local $aResult = DllCall("gdi32.dll", "int", "GetObjectW", "handle", $hObject, "int", $iSize, "struct*", $pObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetObjectInfoByHandle($hObject)
Local $tagPUBLIC_OBJECT_BASIC_INFORMATION = 'ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]'
Local $tPOBI = DllStructCreate($tagPUBLIC_OBJECT_BASIC_INFORMATION)
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 0, 'struct*', $tPOBI,  'ulong', DllStructGetSize($tPOBI), 'ptr', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tPOBI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetObjectNameByHandle($hObject)
Local $tagUNICODE_STRING = 'struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct'
Local $tagPUBLIC_OBJECT_TYPE_INFORMATION = 'struct;' & $tagUNICODE_STRING & ';ulong Reserved[22];endstruct'
Local $tPOTI = DllStructCreate($tagPUBLIC_OBJECT_TYPE_INFORMATION & ';byte[32]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQueryObject', 'handle', $hObject, 'uint', 2, 'struct*', $tPOTI,  'ulong', DllStructGetSize($tPOTI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $pData = DllStructGetData($tPOTI, 3)
If Not $pData Then Return SetError(11, 0, '')
Return _WinAPI_GetString($pData)
EndFunc
Func _WinAPI_GetObjectType($hObject)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetObjectType', 'handle', $hObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetStdHandle($iStdHandle)
If $iStdHandle < 0 Or $iStdHandle > 2 Then Return SetError(2, 0, -1)
Local Const $aHandle[3] = [-10, -11, -12]
Local $aResult = DllCall("kernel32.dll", "handle", "GetStdHandle", "dword", $aHandle[$iStdHandle])
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_GetStockObject($iObject)
Local $aResult = DllCall("gdi32.dll", "handle", "GetStockObject", "int", $iObject)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SelectObject($hDC, $hGDIObj)
Local $aResult = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hGDIObj)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetHandleInformation($hObject, $iMask, $iFlags)
Local $aResult = DllCall("kernel32.dll", "bool", "SetHandleInformation", "handle", $hObject, "dword", $iMask, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global $__g_hHeap = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateBuffer($iLength, $pBuffer = 0, $bAbort = True)
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
Return $pBuffer
EndFunc
Func _WinAPI_CreateBufferFromStruct($tStruct, $pBuffer = 0, $bAbort = True)
If Not IsDllStruct($tStruct) Then Return SetError(1, 0, 0)
$pBuffer = __HeapReAlloc($pBuffer, DllStructGetSize($tStruct), 0, $bAbort)
If @error Then Return SetError(@error + 100, @extended, 0)
_WinAPI_MoveMemory($pBuffer, $tStruct, DllStructGetSize($tStruct))
Return $pBuffer
EndFunc
Func _WinAPI_CreateString($sString, $pString = 0, $iLength = -1, $bUnicode = True, $bAbort = True)
$iLength = Number($iLength)
If $iLength >= 0 Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $iSize = $iLength + 1
If $bUnicode Then
$iSize *= 2
EndIf
$pString = __HeapReAlloc($pString, $iSize, 0, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
DllStructSetData(DllStructCreate(($bUnicode ? 'wchar' : 'char') & '[' & ($iLength + 1) & ']', $pString), 1, $sString)
Return SetExtended($iLength, $pString)
EndFunc
Func _WinAPI_EqualMemory($pSource1, $pSource2, $iLength)
If _WinAPI_IsBadReadPtr($pSource1, $iLength) Then Return SetError(11, @extended, 0)
If _WinAPI_IsBadReadPtr($pSource2, $iLength) Then Return SetError(12, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'ulong_ptr', 'RtlCompareMemory', 'struct*', $pSource1, 'struct*', $pSource2, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return Number($aRet[0] = $iLength)
EndFunc
Func _WinAPI_FillMemory($pMemory, $iLength, $iValue = 0)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlFillMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength, 'byte', $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_FreeMemory($pMemory)
If Not __HeapFree($pMemory, 1) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetMemorySize($pMemory)
Local $iResult = __HeapSize($pMemory, 1)
If @error Then Return SetError(@error, @extended, 0)
Return $iResult
EndFunc
Func _WinAPI_GlobalMemoryStatus()
Local Const $tagMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" &  "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" &  "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
Local $tMem = DllStructCreate($tagMEMORYSTATUSEX)
DllStructSetData($tMem, 1, DllStructGetSize($tMem))
Local $aRet = DllCall("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $tMem)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMem[7]
$aMem[0] = DllStructGetData($tMem, 2)
$aMem[1] = DllStructGetData($tMem, 3)
$aMem[2] = DllStructGetData($tMem, 4)
$aMem[3] = DllStructGetData($tMem, 5)
$aMem[4] = DllStructGetData($tMem, 6)
$aMem[5] = DllStructGetData($tMem, 7)
$aMem[6] = DllStructGetData($tMem, 8)
Return $aMem
EndFunc
Func _WinAPI_IsBadCodePtr($pAddress)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadCodePtr', 'struct*', $pAddress)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadReadPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadReadPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadStringPtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadStringPtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsBadWritePtr($pAddress, $iLength)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsBadWritePtr', 'struct*', $pAddress, 'uint_ptr', $iLength)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsMemory($pMemory)
Local $bResult = __HeapValidate($pMemory)
Return SetError(@error, @extended, $bResult)
EndFunc
Func _WinAPI_LocalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "handle", "LocalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveMemory($pDestination, $pSource, $iLength)
If _WinAPI_IsBadReadPtr($pSource, $iLength) Then Return SetError(10, @extended, 0)
If _WinAPI_IsBadWritePtr($pDestination, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlMoveMemory', 'struct*', $pDestination, 'struct*', $pSource, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_ReadProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iRead)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", $hProcess,  "ptr", $pBaseAddress, "struct*", $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iRead = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_WriteProcessMemory($hProcess, $pBaseAddress, $pBuffer, $iSize, ByRef $iWritten, $sBuffer = "ptr")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", $hProcess, "ptr", $pBaseAddress,  $sBuffer, $pBuffer, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
$iWritten = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_ZeroMemory($pMemory, $iLength)
If _WinAPI_IsBadWritePtr($pMemory, $iLength) Then Return SetError(11, @extended, 0)
DllCall('ntdll.dll', 'none', 'RtlZeroMemory', 'struct*', $pMemory, 'ulong_ptr', $iLength)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __HeapAlloc($iSize, $bAbort = False)
Local $aRet
If Not $__g_hHeap Then
$aRet = DllCall('kernel32.dll', 'handle', 'HeapCreate', 'dword', 0, 'ulong_ptr', 0, 'ulong_ptr', 0)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
$__g_hHeap = $aRet[0]
EndIf
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 30, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func __HeapFree(ByRef $pMemory, $bCheck = False, $iCurErr = @error, $iCurExt = @extended)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapFree', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or Not $aRet[0] Then Return SetError(@error + 40, @extended, 0)
$pMemory = 0
Return SetError($iCurErr, $iCurExt, 1)
EndFunc
Func __HeapReAlloc($pMemory, $iSize, $bAmount = False, $bAbort = False)
Local $aRet, $pRet
If __HeapValidate($pMemory) Then
If $bAmount And (__HeapSize($pMemory) >= $iSize) Then Return SetExtended(1, Ptr($pMemory))
$aRet = DllCall('kernel32.dll', 'ptr', 'HeapReAlloc', 'handle', $__g_hHeap, 'dword', 0x00000008, 'ptr', $pMemory,  'ulong_ptr', $iSize)
If @error Or Not $aRet[0] Then
If $bAbort Then __FatalExit(1, 'Error allocating memory.')
Return SetError(@error + 20, @extended, Ptr($pMemory))
EndIf
$pRet = $aRet[0]
Else
$pRet = __HeapAlloc($iSize, $bAbort)
If @error Then Return SetError(@error, @extended, 0)
EndIf
Return $pRet
EndFunc
Func __HeapSize($pMemory, $bCheck = False)
If $bCheck And (Not __HeapValidate($pMemory)) Then Return SetError(@error, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'ulong_ptr', 'HeapSize', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Or ($aRet[0] = Ptr(-1)) Then Return SetError(@error + 50, @extended, 0)
Return $aRet[0]
EndFunc
Func __HeapValidate($pMemory)
If (Not $__g_hHeap) Or (Not Ptr($pMemory)) Then Return SetError(9, 0, False)
Local $aRet = DllCall('kernel32.dll', 'int', 'HeapValidate', 'handle', $__g_hHeap, 'dword', 0, 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Internal Functions
Global Const $SND_APPLICATION = 0x00000080
Global Const $SND_ALIAS = 0x00010000
Global Const $SND_ALIAS_ID = 0x00110000
Global Const $SND_ASYNC = 0x00000001
Global Const $SND_FILENAME = 0x00020000
Global Const $SND_LOOP = 0x00000008
Global Const $SND_MEMORY = 0x00000004
Global Const $SND_NODEFAULT = 0x00000002
Global Const $SND_NOSTOP = 0x00000010
Global Const $SND_NOWAIT = 0x00002000
Global Const $SND_PURGE = 0x00000040
Global Const $SND_RESOURCE = 0x00040004
Global Const $SND_SENTRY = 0x00080000
Global Const $SND_SYNC = 0x00000000
Global Const $SND_SYSTEM = 0x00200000
Global Const $SND_SYSTEM_NOSTOP = 0x00200010
Global Const $SND_ALIAS_SYSTEMASTERISK = 'SystemAsterisk'
Global Const $SND_ALIAS_SYSTEMDEFAULT = 'SystemDefault'
Global Const $SND_ALIAS_SYSTEMEXCLAMATION = 'SystemExclamation'
Global Const $SND_ALIAS_SYSTEMEXIT = 'SystemExit'
Global Const $SND_ALIAS_SYSTEMHAND = 'SystemHand'
Global Const $SND_ALIAS_SYSTEMQUESTION = 'SystemQuestion'
Global Const $SND_ALIAS_SYSTEMSTART = 'SystemStart'
Global Const $SND_ALIAS_SYSTEMWELCOME = 'SystemWelcome'
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ArrayToStruct(Const ByRef $aData, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aData, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'wchar[' & (StringLen($aData[$i]) + 1) & '];'
Next
Local $tData = DllStructCreate($tagStruct & 'wchar[1]')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tData, $iCount, $aData[$i])
$iCount += 1
Next
DllStructSetData($tData, $iCount, ChrW(0))
Return $tData
EndFunc
Func _WinAPI_CreateMargins($iLeftWidth, $iRightWidth, $iTopHeight, $iBottomHeight)
Local $tMARGINS = DllStructCreate($tagMARGINS)
DllStructSetData($tMARGINS, 1, $iLeftWidth)
DllStructSetData($tMARGINS, 2, $iRightWidth)
DllStructSetData($tMARGINS, 3, $iTopHeight)
DllStructSetData($tMARGINS, 4, $iBottomHeight)
Return $tMARGINS
EndFunc
Func _WinAPI_CreatePoint($iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
DllStructSetData($tPOINT, 1, $iX)
DllStructSetData($tPOINT, 2, $iY)
Return $tPOINT
EndFunc
Func _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iLeft)
DllStructSetData($tRECT, 2, $iTop)
DllStructSetData($tRECT, 3, $iRight)
DllStructSetData($tRECT, 4, $iBottom)
Return $tRECT
EndFunc
Func _WinAPI_CreateRectEx($iX, $iY, $iWidth, $iHeight)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, $iX)
DllStructSetData($tRECT, 2, $iY)
DllStructSetData($tRECT, 3, $iX + $iWidth)
DllStructSetData($tRECT, 4, $iY + $iHeight)
Return $tRECT
EndFunc
Func _WinAPI_CreateSize($iWidth, $iHeight)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, $iWidth)
DllStructSetData($tSIZE, 2, $iHeight)
Return $tSIZE
EndFunc
Func _WinAPI_CopyStruct($tStruct, $sStruct = '')
Local $iSize = DllStructGetSize($tStruct)
If Not $iSize Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & $iSize & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < $iSize Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct, $iSize)
Return $tResult
EndFunc
Func _WinAPI_GetExtended()
Return $__g_vExt
EndFunc
Func _WinAPI_GetMousePos($bToClient = False, $hWnd = 0)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
If $bToClient And Not _WinAPI_ScreenToClient($hWnd, $tPoint) Then Return SetError(@error + 20, @extended, 0)
Return $tPoint
EndFunc
Func _WinAPI_GetMousePosX($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "X")
EndFunc
Func _WinAPI_GetMousePosY($bToClient = False, $hWnd = 0)
Local $tPoint = _WinAPI_GetMousePos($bToClient, $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPoint, "Y")
EndFunc
Func _WinAPI_MulDiv($iNumber, $iNumerator, $iDenominator)
Local $aResult = DllCall("kernel32.dll", "int", "MulDiv", "int", $iNumber, "int", $iNumerator, "int", $iDenominator)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_PlaySound($sSound, $iFlags = $SND_SYSTEM_NOSTOP, $hInstance = 0)
Local $sTypeOfSound = 'ptr'
If $sSound Then
If IsString($sSound) Then
$sTypeOfSound = 'wstr'
EndIf
Else
$sSound = 0
$iFlags = 0
EndIf
Local $aRet = DllCall('winmm.dll', 'bool', 'PlaySoundW', $sTypeOfSound, $sSound, 'handle', $hInstance, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StringLenA(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenA", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_StringLenW(Const ByRef $tString)
Local $aResult = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $tString)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_StructToArray(ByRef $tStruct, $iItems = 0)
Local $iSize = 2 * Floor(DllStructGetSize($tStruct) / 2)
Local $pStruct = DllStructGetPtr($tStruct)
If Not $iSize Or Not $pStruct Then Return SetError(1, 0, 0)
Local $tData, $iLength, $iOffset = 0
Local $aResult[101] = [0]
While 1
$iLength = _WinAPI_StrLen($pStruct + $iOffset)
If Not $iLength Then
ExitLoop
EndIf
If 2 * (1 + $iLength) + $iOffset > $iSize Then Return SetError(3, 0, 0)
$tData = DllStructCreate('wchar[' & (1 + $iLength) & ']', $pStruct + $iOffset)
If @error Then Return SetError(@error + 10, 0, 0)
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tData, 1)
If $aResult[0] = $iItems Then
ExitLoop
EndIf
$iOffset += 2 * (1 + $iLength)
If $iOffset >= $iSize Then Return SetError(3, 0, 0)
WEnd
If Not $aResult[0] Then Return SetError(2, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_UnionStruct($tStruct1, $tStruct2, $sStruct = '')
Local $aSize[2] = [DllStructGetSize($tStruct1), DllStructGetSize($tStruct2)]
If Not $aSize[0] Or Not $aSize[1] Then Return SetError(1, 0, 0)
Local $tResult
If Not StringStripWS($sStruct, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) Then
$tResult = DllStructCreate('byte[' & ($aSize[0] + $aSize[1]) & ']')
Else
$tResult = DllStructCreate($sStruct)
EndIf
If DllStructGetSize($tResult) < ($aSize[0] + $aSize[1]) Then Return SetError(2, 0, 0)
_WinAPI_MoveMemory($tResult, $tStruct1, $aSize[0])
_WinAPI_MoveMemory(DllStructGetPtr($tResult) + $aSize[0], $tStruct2, $aSize[1])
Return $tResult
EndFunc
#EndRegion Public Functions
#Region Global Variables and Constants
Global Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Global Const $tagBITMAPV5HEADER = 'struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct'
Global Const $tagDIBSECTION = $tagBITMAP & ';' & $tagBITMAPINFOHEADER & ';dword dsBitfields[3];ptr dshSection;dword dsOffset'
Global Const $TMPF_FIXED_PITCH = 0x01
Global Const $TMPF_VECTOR = 0x02
Global Const $TMPF_TRUETYPE = 0x04
Global Const $TMPF_DEVICE = 0x08
Global Const $__WINAPICONSTANT_FW_NORMAL = 400
Global Const $__WINAPICONSTANT_DEFAULT_CHARSET = 1
Global Const $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
Global Const $__WINAPICONSTANT_DEFAULT_QUALITY = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BitBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $iROP)
Local $aResult = DllCall("gdi32.dll", "bool", "BitBlt", "handle", $hDestDC, "int", $iXDest, "int", $iYDest, "int", $iWidth,  "int", $iHeight, "handle", $hSrcDC, "int", $iXSrc, "int", $iYSrc, "dword", $iROP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CombineRgn($hRgnDest, $hRgnSrc1, $hRgnSrc2, $iCombineMode)
Local $aResult = DllCall("gdi32.dll", "int", "CombineRgn", "handle", $hRgnDest, "handle", $hRgnSrc1, "handle", $hRgnSrc2,  "int", $iCombineMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CopyBitmap($hBitmap)
$hBitmap = _WinAPI_CopyImage($hBitmap, 0, 0, 0, 0x2000)
Return SetError(@error, @extended, $hBitmap)
EndFunc
Func _WinAPI_CopyImage($hImage, $iType = 0, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CopyImage', 'handle', $hImage, 'uint', $iType,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateANDBitmap($hBitmap)
Local $iError = 0, $hDib = 0
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Do
Local $atDIB[2]
$atDIB[0] = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($atDIB[0]), $atDIB[0]))  Or (DllStructGetData($atDIB[0], 'bmBitsPixel') <> 32) Or (DllStructGetData($atDIB[0], 'biCompression')) Then
$iError = 10
ExitLoop
EndIf
$atDIB[1] = DllStructCreate($tagBITMAP)
$hDib = _WinAPI_CreateDIB(DllStructGetData($atDIB[0], 'bmWidth'), DllStructGetData($atDIB[0], 'bmHeight'), 1)
If Not _WinAPI_GetObject($hDib, DllStructGetSize($atDIB[1]), $atDIB[1]) Then
$iError = 11
ExitLoop
EndIf
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __ANDProc(), 'ptr', 0, 'uint', 0,  'wparam', DllStructGetPtr($atDIB[0]), 'lparam', DllStructGetPtr($atDIB[1]))
If @error Then
$iError = @error
ExitLoop
EndIf
If Not $aRet[0] Then
$iError = 12
ExitLoop
EndIf
$iError = 0
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
$hDib = 0
EndIf
Return SetError($iError, 0, $hDib)
EndFunc
Func _WinAPI_CreateBitmap($iWidth, $iHeight, $iPlanes = 1, $iBitsPerPel = 1, $pBits = 0)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateBitmap", "int", $iWidth, "int", $iHeight, "uint", $iPlanes,  "uint", $iBitsPerPel, "struct*", $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $hDC, "int", $iWidth, "int", $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel = 32, $tColorTable = 0, $iColorCount = 0)
Local $aRGBQ[2], $iColors, $tagRGBQ
Switch $iBitsPerPel
Case 1
$iColors = 2
Case 4
$iColors = 16
Case 8
$iColors = 256
Case Else
$iColors = 0
EndSwitch
If $iColors Then
If Not IsDllStruct($tColorTable) Then
Switch $iBitsPerPel
Case 1
$aRGBQ[0] = 0
$aRGBQ[1] = 0xFFFFFF
$tColorTable = _WinAPI_CreateDIBColorTable($aRGBQ)
Case Else
EndSwitch
Else
If $iColors > $iColorCount Then
$iColors = $iColorCount
EndIf
If (Not $iColors) Or ((4 * $iColors) > DllStructGetSize($tColorTable)) Then
Return SetError(20, 0, 0)
EndIf
EndIf
$tagRGBQ = ';dword aRGBQuad[' & $iColors & ']'
Else
$tagRGBQ = ''
EndIf
Local $tBITMAPINFO = DllStructCreate($tagBITMAPINFOHEADER & $tagRGBQ)
DllStructSetData($tBITMAPINFO, 'biSize', 40)
DllStructSetData($tBITMAPINFO, 'biWidth', $iWidth)
DllStructSetData($tBITMAPINFO, 'biHeight', $iHeight)
DllStructSetData($tBITMAPINFO, 'biPlanes', 1)
DllStructSetData($tBITMAPINFO, 'biBitCount', $iBitsPerPel)
DllStructSetData($tBITMAPINFO, 'biCompression', 0)
DllStructSetData($tBITMAPINFO, 'biSizeImage', 0)
DllStructSetData($tBITMAPINFO, 'biXPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biYPelsPerMeter', 0)
DllStructSetData($tBITMAPINFO, 'biClrUsed', $iColors)
DllStructSetData($tBITMAPINFO, 'biClrImportant', 0)
If $iColors Then
If IsDllStruct($tColorTable) Then
_WinAPI_MoveMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), $tColorTable, 4 * $iColors)
Else
_WinAPI_ZeroMemory(DllStructGetPtr($tBITMAPINFO, 'aRGBQuad'), 4 * $iColors)
EndIf
EndIf
Local $hBitmap = _WinAPI_CreateDIBSection(0, $tBITMAPINFO, 0, $__g_vExt)
If Not $hBitmap Then Return SetError(@error, @extended, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateDIBSection($hDC, $tBITMAPINFO, $iUsage, ByRef $pBits, $hSection = 0, $iOffset = 0)
$pBits = 0
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBSection', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'ptr*', 0, 'handle', $hSection, 'dword', $iOffset)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBits = $aRet[4]
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDIBColorTable(Const ByRef $aColorTable, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aColorTable, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $tColorTable = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
Local $iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tColorTable, 1, _WinAPI_SwitchColor(__RGB($aColorTable[$i])), $iCount)
$iCount += 1
Next
Return $tColorTable
EndFunc
Func _WinAPI_CreateFont($iHeight, $iWidth, $iEscape = 0, $iOrientn = 0, $iWeight = $__WINAPICONSTANT_FW_NORMAL, $bItalic = False, $bUnderline = False, $bStrikeout = False, $iCharset = $__WINAPICONSTANT_DEFAULT_CHARSET, $iOutputPrec = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $iClipPrec = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $iQuality = $__WINAPICONSTANT_DEFAULT_QUALITY, $iPitch = 0, $sFace = 'Arial')
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontW", "int", $iHeight, "int", $iWidth, "int", $iEscape,  "int", $iOrientn, "int", $iWeight, "dword", $bItalic, "dword", $bUnderline, "dword", $bStrikeout,  "dword", $iCharset, "dword", $iOutputPrec, "dword", $iClipPrec, "dword", $iQuality, "dword", $iPitch, "wstr", $sFace)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateFontIndirect($tLogFont)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $tLogFont)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRectRgn", "int", $iLeftRect, "int", $iTopRect, "int", $iRightRect,  "int", $iBottomRect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateRoundRectRgn($iLeftRect, $iTopRect, $iRightRect, $iBottomRect, $iWidthEllipse, $iHeightEllipse)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $iLeftRect, "int", $iTopRect,  "int", $iRightRect, "int", $iBottomRect, "int", $iWidthEllipse, "int", $iHeightEllipse)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateSolidBrush($iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateSolidBrush", "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetBitmapDimension($hBitmap)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return _WinAPI_CreateSize(DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'))
EndFunc
Func _WinAPI_GetSysColorBrush($iIndex)
Local $aResult = DllCall("user32.dll", "handle", "GetSysColorBrush", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetTextExtentPoint32($hDC, $sText)
Local $tSize = DllStructCreate($tagSIZE)
Local $iSize = StringLen($sText)
Local $aRet = DllCall("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $hDC, "wstr", $sText, "int", $iSize, "struct*", $tSize)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSize
EndFunc
Func _WinAPI_GetTextMetrics($hDC)
Local $tTEXTMETRIC = DllStructCreate($tagTEXTMETRIC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetTextMetricsW', 'handle', $hDC, 'struct*', $tTEXTMETRIC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tTEXTMETRIC
EndFunc
Func _WinAPI_GetWindowRgn($hWnd, $hRgn)
Local $aResult = DllCall("user32.dll", "int", "GetWindowRgn", "hwnd", $hWnd, "handle", $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_IsAlphaBitmap($hBitmap)
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
If Not $hBitmap Then Return SetError(@error + 20, @extended, 0)
Local $aRet, $iError = 0
Do
Local $tDIB = DllStructCreate($tagDIBSECTION)
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'bmBitsPixel') <> 32) Or (DllStructGetData($tDIB, 'biCompression')) Then
$iError = 1
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'int', 'CallWindowProc', 'ptr', __AlphaProc(), 'ptr', 0, 'uint', 0, 'struct*', $tDIB, 'ptr', 0)
If @error Or ($aRet[0] = -1) Then
$iError = @error + 10
ExitLoop
EndIf
Until 1
_WinAPI_DeleteObject($hBitmap)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRect(ByRef $tRECT, ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "bool", "PtInRect", "struct*", $tRECT, "struct", $tPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RedrawWindow($hWnd, $tRECT = 0, $hRegion = 0, $iFlags = 5)
Local $aResult = DllCall("user32.dll", "bool", "RedrawWindow", "hwnd", $hWnd, "struct*", $tRECT, "handle", $hRegion,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowRgn($hWnd, $hRgn, $bRedraw = True)
Local $aResult = DllCall("user32.dll", "int", "SetWindowRgn", "hwnd", $hWnd, "handle", $hRgn, "bool", $bRedraw)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __AlphaProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883' &  '7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB' &  '034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B' &  '6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24' &  '287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080' &  '7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D' &  '1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407' &  'B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302' &  '83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00' &  '007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __ANDProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C2420554157415648C7C009000000' &  '4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405' &  '4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405' &  '4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405' &  '4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405' &  '4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048' &  '21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000' &  'EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7' &  '44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100' &  '0048C74424380000000048C74424400000000048C744244800000000488BAC24' &  'A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B' &  '7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440' &  '4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24' &  '4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7' &  '442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C' &  '24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845' &  '0048FF4424604883442458F871B948C74424380000000048C744244000000000' &  '48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7' &  'D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C' &  '244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D' &  '184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24' &  '585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0' &  '010000004863C0EB034831C04883C470415E415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05' &  'B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24' &  '38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0' &  'EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000' &  '00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7' &  '042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000' &  'C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B' &  '3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480' &  '7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24' &  '0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424' &  '0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3' &  '8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000' &  '31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3' &  'FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8' &  '01000000EB0231C083C4205F5B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
Func __XORProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C050504883EC28' &  '48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074' &  '054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0' &  '4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C' &  '3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405' &  '4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C' &  '897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB' &  '034831C04883C438415F5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074' &  '0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB' &  '5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B' &  '6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303' &  '895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D' &  'C21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Internal Functions
Func __Init($dData)
Local $iLength = BinaryLen($dData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'VirtualAlloc', 'ptr', 0, 'ulong_ptr', $iLength, 'dword', 0x00001000, 'dword', 0x00000040)
If @error Or Not $aRet[0] Then __FatalExit(1, 'Error allocating memory.')
Local $tData = DllStructCreate('byte[' & $iLength & "]", $aRet[0])
DllStructSetData($tData, 1, $dData)
Return $aRet[0]
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $DI_MASK = 0x0001
Global Const $DI_IMAGE = 0x0002
Global Const $DI_NORMAL = 0x0003
Global Const $DI_COMPAT = 0x0004
Global Const $DI_DEFAULTSIZE = 0x0008
Global Const $DI_NOMIRROR = 0x0010
Global Const $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 0x00000001
Global Const $DISPLAY_DEVICE_MULTI_DRIVER = 0x00000002
Global Const $DISPLAY_DEVICE_PRIMARY_DEVICE = 0x00000004
Global Const $DISPLAY_DEVICE_MIRRORING_DRIVER = 0x00000008
Global Const $DISPLAY_DEVICE_VGA_COMPATIBLE = 0x00000010
Global Const $DISPLAY_DEVICE_REMOVABLE = 0x00000020
Global Const $DISPLAY_DEVICE_DISCONNECT = 0x02000000
Global Const $DISPLAY_DEVICE_REMOTE = 0x04000000
Global Const $DISPLAY_DEVICE_MODESPRUNED = 0x08000000
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateCompatibleDC($hDC)
Local $aResult = DllCall("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DeleteDC($hDC)
Local $aResult = DllCall("gdi32.dll", "bool", "DeleteDC", "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawEdge($hDC, $tRECT, $iEdgeType, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "DrawEdge", "handle", $hDC, "struct*", $tRECT, "uint", $iEdgeType,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawFrameControl($hDC, $tRECT, $iType, $iState)
Local $aResult = DllCall("user32.dll", "bool", "DrawFrameControl", "handle", $hDC, "struct*", $tRECT, "uint", $iType,  "uint", $iState)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIcon($hDC, $iX, $iY, $hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DrawIcon", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawIconEx($hDC, $iX, $iY, $hIcon, $iWidth = 0, $iHeight = 0, $iStep = 0, $hBrush = 0, $iFlags = 3)
Local $iOptions
Switch $iFlags
Case 1
$iOptions = $DI_MASK
Case 2
$iOptions = $DI_IMAGE
Case 3
$iOptions = $DI_NORMAL
Case 4
$iOptions = $DI_COMPAT
Case 5
$iOptions = $DI_DEFAULTSIZE
Case Else
$iOptions = $DI_NOMIRROR
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "DrawIconEx", "handle", $hDC, "int", $iX, "int", $iY, "handle", $hIcon,  "int", $iWidth, "int", $iHeight, "uint", $iStep, "handle", $hBrush, "uint", $iOptions)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_DrawText($hDC, $sText, ByRef $tRECT, $iFlags)
Local $aResult = DllCall("user32.dll", "int", "DrawTextW", "handle", $hDC, "wstr", $sText, "int", -1, "struct*", $tRECT,  "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_EnumDisplayDevices($sDevice, $iDevNum)
Local $tName = 0, $iFlags = 0, $aDevice[5]
If $sDevice <> "" Then
$tName = DllStructCreate("wchar Text[" & StringLen($sDevice) + 1 & "]")
DllStructSetData($tName, "Text", $sDevice)
EndIf
Local Const $tagDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
Local $tDevice = DllStructCreate($tagDISPLAY_DEVICE)
Local $iDevice = DllStructGetSize($tDevice)
DllStructSetData($tDevice, "Size", $iDevice)
Local $aRet = DllCall("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $tName, "dword", $iDevNum, "struct*", $tDevice, "dword", 1)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iN = DllStructGetData($tDevice, "Flags")
If BitAND($iN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iN, $DISPLAY_DEVICE_REMOVABLE) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 Then $iFlags = BitOR($iFlags, 32)
$aDevice[0] = True
$aDevice[1] = DllStructGetData($tDevice, "Name")
$aDevice[2] = DllStructGetData($tDevice, "String")
$aDevice[3] = $iFlags
$aDevice[4] = DllStructGetData($tDevice, "ID")
Return $aDevice
EndFunc
Func _WinAPI_FillRect($hDC, $tRECT, $hBrush)
Local $aResult
If IsPtr($hBrush) Then
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
Else
$aResult = DllCall("user32.dll", "int", "FillRect", "handle", $hDC, "struct*", $tRECT, "dword_ptr", $hBrush)
EndIf
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FrameRect($hDC, $tRECT, $hBrush)
Local $aResult = DllCall("user32.dll", "int", "FrameRect", "handle", $hDC, "struct*", $tRECT, "handle", $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetBkMode($hDC)
Local $aResult = DllCall("gdi32.dll", "int", "GetBkMode", "handle", $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDCEx($hWnd, $hRgn, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDCEx', 'hwnd', $hWnd, 'handle', $hRgn, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetDeviceCaps($hDC, $iIndex)
Local $aResult = DllCall("gdi32.dll", "int", "GetDeviceCaps", "handle", $hDC, "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetTextColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetTextColor', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetWindowDC($hWnd)
Local $aResult = DllCall("user32.dll", "handle", "GetWindowDC", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_PrintWindow($hWnd, $hDC, $bClient = False)
Local $aRet = DllCall('user32.dll', 'bool', 'PrintWindow', 'hwnd', $hWnd, 'handle', $hDC, 'uint', $bClient)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseDC($hWnd, $hDC)
Local $aResult = DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RestoreDC($hDC, $iID)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RestoreDC', 'handle', $hDC, 'int', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveDC($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'SaveDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBkColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetBkColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_SetBkMode($hDC, $iBkMode)
Local $aResult = DllCall("gdi32.dll", "int", "SetBkMode", "handle", $hDC, "int", $iBkMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetTextColor($hDC, $iColor)
Local $aResult = DllCall("gdi32.dll", "INT", "SetTextColor", "handle", $hDC, "INT", $iColor)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_TwipsPerPixelX()
Local $hDC, $iTwipsPerPixelX
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSX = 88
$iTwipsPerPixelX = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSX)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelX
EndFunc
Func _WinAPI_TwipsPerPixelY()
Local $hDC, $iTwipsPerPixelY
$hDC = _WinAPI_GetDC(0)
Local Const $__WINAPICONSTANT_LOGPIXELSY = 90
$iTwipsPerPixelY = 1440 / _WinAPI_GetDeviceCaps($hDC, $__WINAPICONSTANT_LOGPIXELSY)
_WinAPI_ReleaseDC(0, $hDC)
Return $iTwipsPerPixelY
EndFunc
#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Global Const $tagICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
Func _WinAPI_AddIconTransparency($hIcon, $iPercent = 50, $bDelete = False)
Local $tBITMAP, $hDib = 0, $hResult = 0
Local $ahBitmap[2]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $iError = 0
Do
$hDib = _WinAPI_CopyBitmap($ahBitmap[1])
If Not $hDib Then
$iError = 20
ExitLoop
EndIf
$tBITMAP = DllStructCreate($tagBITMAP)
If (Not _WinAPI_GetObject($hDib, DllStructGetSize($tBITMAP), $tBITMAP)) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 32) Then
$iError = 21
ExitLoop
EndIf
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'PTR', __TransparencyProc(), 'hwnd', 0,  'uint', $iPercent, 'wparam', DllStructGetPtr($tBITMAP), 'lparam', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
If $aRet[0] = -1 Then
$hResult = _WinAPI_CreateEmptyIcon(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Else
$hResult = _WinAPI_CreateIconIndirect($hDib, $ahBitmap[0])
EndIf
If Not $hResult Then $iError = 22
Until 1
If $hDib Then
_WinAPI_DeleteObject($hDib)
EndIf
For $i = 0 To 1
If $ahBitmap[$i] Then
_WinAPI_DeleteObject($ahBitmap[$i])
EndIf
Next
If $iError Then Return SetError($iError, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CopyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "handle", "CopyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_Create32BitHICON($hIcon, $bDelete = False)
Local $ahBitmap[2], $hResult = 0
Local $aDIB[2][2] = [[0, 0], [0, 0]]
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
For $i = 0 To 1
$ahBitmap[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
If _WinAPI_IsAlphaBitmap($ahBitmap[1]) Then
$aDIB[0][0] = _WinAPI_CreateANDBitmap($ahBitmap[1])
If Not @error Then
$hResult = _WinAPI_CreateIconIndirect($ahBitmap[1], $aDIB[0][0])
EndIf
Else
Local $tSIZE = _WinAPI_GetBitmapDimension($ahBitmap[1])
Local $aSize[2]
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tSIZE, $i + 1)
Next
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv, $hDstSv
For $i = 0 To 1
$aDIB[$i][0] = _WinAPI_CreateDIB($aSize[0], $aSize[1])
$aDIB[$i][1] = $__g_vExt
$hSrcSv = _WinAPI_SelectObject($hSrcDC, $ahBitmap[$i])
$hDstSv = _WinAPI_SelectObject($hDstDC, $aDIB[$i][0])
_WinAPI_BitBlt($hDstDC, 0, 0, $aSize[0], $aSize[1], $hSrcDC, 0, 0, 0x00C000CA)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_SelectObject($hDstDC, $hDstSv)
Next
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_DeleteDC($hDstDC)
$aRet = DllCall('user32.dll', 'lresult', 'CallWindowProc', 'ptr', __XORProc(), 'ptr', 0,  'uint', $aSize[0] * $aSize[1] * 4, 'wparam', $aDIB[0][1], 'lparam', $aDIB[1][1])
If Not @error And $aRet[0] Then
$hResult = _WinAPI_CreateIconIndirect($aDIB[1][0], $ahBitmap[0])
EndIf
EndIf
For $i = 0 To 1
_WinAPI_DeleteObject($ahBitmap[$i])
If $aDIB[$i][0] Then
_WinAPI_DeleteObject($aDIB[$i][0])
EndIf
Next
If Not $hResult Then Return SetError(11, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hResult
EndFunc
Func _WinAPI_CreateEmptyIcon($iWidth, $iHeight, $iBitsPerPel = 32)
Local $hXOR = _WinAPI_CreateDIB($iWidth, $iHeight, $iBitsPerPel)
Local $hAND = _WinAPI_CreateDIB($iWidth, $iHeight, 1)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hAND)
Local $hBrush = _WinAPI_CreateSolidBrush(0xFFFFFF)
Local $tRECT = _WinAPI_CreateRect(0, 0, $iWidth, $iHeight)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
_WinAPI_DeleteObject($hBrush)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Local $hIcon = _WinAPI_CreateIconIndirect($hXOR, $hAND)
Local $iError = @error
If $hXOR Then
_WinAPI_DeleteObject($hXOR)
EndIf
If $hAND Then
_WinAPI_DeleteObject($hAND)
EndIf
If Not $hIcon Then Return SetError($iError + 10, 0, 0)
Return $hIcon
EndFunc
Func _WinAPI_CreateIcon($hInstance, $iWidth, $iHeight, $iPlanes, $iBitsPixel, $pANDBits, $pXORBits)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIcon', 'handle', $hInstance, 'int', $iWidth, 'int', $iHeight,  'byte', $iPlanes, 'byte', $iBitsPixel, 'struct*', $pANDBits, 'struct*', $pXORBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconFromResourceEx($pData, $iSize, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconFromResourceEx', 'ptr', $pData, 'dword', $iSize, 'bool', $bIcon,  'dword', 0x00030000, 'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateIconIndirect($hBitmap, $hMask, $iXHotspot = 0, $iYHotspot = 0, $bIcon = True)
Local $tICONINFO = DllStructCreate($tagICONINFO)
DllStructSetData($tICONINFO, 1, $bIcon)
DllStructSetData($tICONINFO, 2, $iXHotspot)
DllStructSetData($tICONINFO, 3, $iYHotspot)
DllStructSetData($tICONINFO, 4, $hMask)
DllStructSetData($tICONINFO, 5, $hBitmap)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateIconIndirect', 'struct*', $tICONINFO)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyIcon($hIcon)
Local $aResult = DllCall("user32.dll", "bool", "DestroyIcon", "handle", $hIcon)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ExtractIcon($sIcon, $iIndex, $bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
DllCall('shell32.dll', 'uint', 'ExtractIconExW', 'wstr', $sIcon, 'int', $iIndex, 'ptr', $pLarge, 'ptr', $pSmall, 'uint', 1)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_ExtractIconEx($sFilePath, $iIndex, $paLarge, $paSmall, $iIcons)
Local $aResult = DllCall("shell32.dll", "uint", "ExtractIconExW", "wstr", $sFilePath, "int", $iIndex, "struct*", $paLarge,  "struct*", $paSmall, "uint", $iIcons)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FileIconInit($bRestore = True)
Local $aRet = DllCall('shell32.dll', 'int', 660, 'int', $bRestore)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return 1
EndFunc
Func _WinAPI_GetIconDimension($hIcon)
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hIcon, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tSIZE = _WinAPI_GetBitmapDimension(DllStructGetData($tICONINFO, 5))
For $i = 4 To 5
_WinAPI_DeleteObject(DllStructGetData($tICONINFO, $i))
Next
If Not IsDllStruct($tSIZE) Then Return SetError(20, 0, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetIconInfo($hIcon)
Local $tInfo = DllStructCreate($tagICONINFO)
Local $aRet = DllCall("user32.dll", "bool", "GetIconInfo", "handle", $hIcon, "struct*", $tInfo)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aIcon[6]
$aIcon[0] = True
$aIcon[1] = DllStructGetData($tInfo, "Icon") <> 0
$aIcon[2] = DllStructGetData($tInfo, "XHotSpot")
$aIcon[3] = DllStructGetData($tInfo, "YHotSpot")
$aIcon[4] = DllStructGetData($tInfo, "hMask")
$aIcon[5] = DllStructGetData($tInfo, "hColor")
Return $aIcon
EndFunc
Func _WinAPI_GetIconInfoEx($hIcon)
Local $tIIEX = DllStructCreate('dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]')
DllStructSetData($tIIEX, 1, DllStructGetSize($tIIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfoExW', 'handle', $hIcon, 'struct*', $tIIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[8]
For $i = 0 To 7
$aResult[$i] = DllStructGetData($tIIEX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_LoadIcon($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadIconW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIconMetric($hInstance, $sName, $iMetric)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconMetric', 'handle', $hInstance, $sTypeOfName, $sName, 'int', $iMetric, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[4]
EndFunc
Func _WinAPI_LoadIconWithScaleDown($hInstance, $sName, $iWidth, $iHeight)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('comctl32.dll', 'long', 'LoadIconWithScaleDown', 'handle', $hInstance, $sTypeOfName, $sName,  'int', $iWidth, 'int', $iHeight, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[5]
EndFunc
Func _WinAPI_LoadShell32Icon($iIconID)
Local $tIcons = DllStructCreate("ptr Data")
Local $iIcons = _WinAPI_ExtractIconEx("shell32.dll", $iIconID, 0, $tIcons, 1)
If @error Then Return SetError(@error, @extended, 0)
If $iIcons <= 0 Then Return SetError(10, 0, 0)
Return DllStructGetData($tIcons, "Data")
EndFunc
Func _WinAPI_LookupIconIdFromDirectoryEx($pData, $bIcon = True, $iXDesiredPixels = 0, $iYDesiredPixels = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'int', 'LookupIconIdFromDirectoryEx', 'ptr', $pData, 'bool', $bIcon,  'int', $iXDesiredPixels, 'int', $iYDesiredPixels, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MirrorIcon($hIcon, $bDelete = False)
If Not $bDelete Then
$hIcon = _WinAPI_CopyIcon($hIcon)
EndIf
Local $aRet = DllCall('comctl32.dll', 'int', 414, 'ptr', 0, 'ptr*', $hIcon)
If @error Or Not $aRet[0] Then
Local $iError = @error + 10
If $hIcon And Not $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return SetError($iError, 0, 0)
EndIf
Return $aRet[2]
EndFunc
#EndRegion Public Functions
#Region Embedded DLL Functions
Func __TransparencyProc()
Static $pProc = 0
If Not $pProc Then
If @AutoItX64 Then
$pProc = __Init(Binary(  '0x48894C240848895424104C894424184C894C24205541574831C0505050505050' &  '4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522' &  '488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502' &  'EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63' &  '7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF' &  '7D08C74424780000000048C74424280100000048C74424300000000048C74424' &  '3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF' &  'F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18' &  '4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C' &  '244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899' &  '48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7' &  '4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24' &  '3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0' &  'FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F' &  '5DC3'))
Else
$pProc = __Init(Binary(  '0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24' &  '28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021' &  'C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24' &  '2421DB7D08C744242400000000C7042401000000C744240400000000C7442408' &  '000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B' &  '6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24' &  '100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058' &  '8845008B6C240C807D00007407C7042400000000C74424040100000083442408' &  '047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF' &  'FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000'))
EndIf
EndIf
Return $pProc
EndFunc
#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
Global $__g_aInProcess_WinAPI[64][2] = [[0, 0]]
Global $__g_aWinList_WinAPI[64][2] = [[0, 0]]
Global Const $GW_HWNDFIRST = 0
Global Const $GW_HWNDLAST = 1
Global Const $GW_HWNDNEXT = 2
Global Const $GW_HWNDPREV = 3
Global Const $GW_OWNER = 4
Global Const $GW_CHILD = 5
Global Const $GW_ENABLEDPOPUP = 6
Global Const $GWL_WNDPROC = 0xFFFFFFFC
Global Const $GWL_HINSTANCE = 0xFFFFFFFA
Global Const $GWL_HWNDPARENT = 0xFFFFFFF8
Global Const $GWL_ID = 0xFFFFFFF4
Global Const $GWL_STYLE = 0xFFFFFFF0
Global Const $GWL_EXSTYLE = 0xFFFFFFEC
Global Const $GWL_USERDATA = 0xFFFFFFEB
Global Const $__WINAPICONSTANT_WM_SETFONT = 0x0030
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CreateWindowEx($iExStyle, $sClass, $sName, $iStyle, $iX, $iY, $iWidth, $iHeight, $hParent, $hMenu = 0, $hInstance = 0, $pParam = 0)
If $hInstance = 0 Then $hInstance = _WinAPI_GetModuleHandle("")
Local $aResult = DllCall("user32.dll", "hwnd", "CreateWindowExW", "dword", $iExStyle, "wstr", $sClass, "wstr", $sName,  "dword", $iStyle, "int", $iX, "int", $iY, "int", $iWidth, "int", $iHeight, "hwnd", $hParent, "handle", $hMenu,  "handle", $hInstance, "struct*", $pParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClientRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetDesktopWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetDesktopWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DestroyWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "DestroyWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnableWindow($hWnd, $bEnable = True)
Local $aResult = DllCall("user32.dll", "bool", "EnableWindow", "hwnd", $hWnd, "bool", $bEnable)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_EnumWindows($bVisible = True, $hWnd = Default)
__WinAPI_EnumWindowsInit()
If $hWnd = Default Then $hWnd = _WinAPI_GetDesktopWindow()
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsPopup()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
Local $sClass
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then
$sClass = _WinAPI_GetClassName($hWnd)
If $sClass = "#32768" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolbarWindow32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "ToolTips_Class32" Then
__WinAPI_EnumWindowsAdd($hWnd)
ElseIf $sClass = "BaseBar" Then
__WinAPI_EnumWindowsChild($hWnd)
EndIf
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_EnumWindowsTop()
__WinAPI_EnumWindowsInit()
Local $hWnd = _WinAPI_GetWindow(_WinAPI_GetDesktopWindow(), $GW_CHILD)
While $hWnd <> 0
If _WinAPI_IsWindowVisible($hWnd) Then __WinAPI_EnumWindowsAdd($hWnd)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
Return $__g_aWinList_WinAPI
EndFunc
Func _WinAPI_GetClassName($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetClassNameW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, '')
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetFocus()
Local $aResult = DllCall("user32.dll", "hwnd", "GetFocus")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetParent($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSysColor($iIndex)
Local $aResult = DllCall("user32.dll", "INT", "GetSysColor", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetSystemMetrics($iIndex)
Local $aResult = DllCall("user32.dll", "int", "GetSystemMetrics", "int", $iIndex)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindow($hWnd, $iCmd)
Local $aResult = DllCall("user32.dll", "hwnd", "GetWindow", "hwnd", $hWnd, "uint", $iCmd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowHeight($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetWindowLong($hWnd, $iIndex)
Local $sFuncName = "GetWindowLongW"
If @AutoItX64 Then $sFuncName = "GetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowRect($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall("user32.dll", "bool", "GetWindowRect", "hwnd", $hWnd, "struct*", $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetWindowText($hWnd)
Local $aResult = DllCall("user32.dll", "int", "GetWindowTextW", "hwnd", $hWnd, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[2])
EndFunc
Func _WinAPI_GetWindowThreadProcessId($hWnd, ByRef $iPID)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error, @extended, 0)
$iPID = $aResult[2]
Return $aResult[0]
EndFunc
Func _WinAPI_GetWindowWidth($hWnd)
Local $tRECT = _WinAPI_GetWindowRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_InProcess($hWnd, ByRef $hLastWnd)
If $hWnd = $hLastWnd Then Return True
For $iI = $__g_aInProcess_WinAPI[0][0] To 1 Step -1
If $hWnd = $__g_aInProcess_WinAPI[$iI][0] Then
If $__g_aInProcess_WinAPI[$iI][1] Then
$hLastWnd = $hWnd
Return True
Else
Return False
EndIf
EndIf
Next
Local $iPID
_WinAPI_GetWindowThreadProcessId($hWnd, $iPID)
Local $iCount = $__g_aInProcess_WinAPI[0][0] + 1
If $iCount >= 64 Then $iCount = 1
$__g_aInProcess_WinAPI[0][0] = $iCount
$__g_aInProcess_WinAPI[$iCount][0] = $hWnd
$__g_aInProcess_WinAPI[$iCount][1] = ($iPID = @AutoItPID)
Return $__g_aInProcess_WinAPI[$iCount][1]
EndFunc
Func _WinAPI_InvalidateRect($hWnd, $tRECT = 0, $bErase = True)
Local $aResult = DllCall("user32.dll", "bool", "InvalidateRect", "hwnd", $hWnd, "struct*", $tRECT, "bool", $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_IsClassName($hWnd, $sClassName)
Local $sSeparator = Opt("GUIDataSeparatorChar")
Local $aClassName = StringSplit($sClassName, $sSeparator)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $sClassCheck = _WinAPI_GetClassName($hWnd)
For $x = 1 To UBound($aClassName) - 1
If StringUpper(StringMid($sClassCheck, 1, StringLen($aClassName[$x]))) = StringUpper($aClassName[$x]) Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_IsWindowVisible($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "IsWindowVisible", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveWindow($hWnd, $iX, $iY, $iWidth, $iHeight, $bRepaint = True)
Local $aResult = DllCall("user32.dll", "bool", "MoveWindow", "hwnd", $hWnd, "int", $iX, "int", $iY, "int", $iWidth,  "int", $iHeight, "bool", $bRepaint)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFocus($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetFont($hWnd, $hFont, $bRedraw = True)
_SendMessage($hWnd, $__WINAPICONSTANT_WM_SETFONT, $hFont, $bRedraw, 0, "hwnd")
EndFunc
Func _WinAPI_SetParent($hWndChild, $hWndParent)
Local $aResult = DllCall("user32.dll", "hwnd", "SetParent", "hwnd", $hWndChild, "hwnd", $hWndParent)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPos($hWnd, $hAfter, $iX, $iY, $iCX, $iCY, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPos", "hwnd", $hWnd, "hwnd", $hAfter, "int", $iX, "int", $iY,  "int", $iCX, "int", $iCY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowText($hWnd, $sText)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowTextW", "hwnd", $hWnd, "wstr", $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowWindow($hWnd, $iCmdShow = 5)
Local $aResult = DllCall("user32.dll", "bool", "ShowWindow", "hwnd", $hWnd, "int", $iCmdShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateWindow($hWnd)
Local $aResult = DllCall("user32.dll", "bool", "UpdateWindow", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __WinAPI_EnumWindowsAdd($hWnd, $sClass = "")
If $sClass = "" Then $sClass = _WinAPI_GetClassName($hWnd)
$__g_aWinList_WinAPI[0][0] += 1
Local $iCount = $__g_aWinList_WinAPI[0][0]
If $iCount >= $__g_aWinList_WinAPI[0][1] Then
ReDim $__g_aWinList_WinAPI[$iCount + 64][2]
$__g_aWinList_WinAPI[0][1] += 64
EndIf
$__g_aWinList_WinAPI[$iCount][0] = $hWnd
$__g_aWinList_WinAPI[$iCount][1] = $sClass
EndFunc
Func __WinAPI_EnumWindowsChild($hWnd, $bVisible = True)
$hWnd = _WinAPI_GetWindow($hWnd, $GW_CHILD)
While $hWnd <> 0
If (Not $bVisible) Or _WinAPI_IsWindowVisible($hWnd) Then
__WinAPI_EnumWindowsAdd($hWnd)
__WinAPI_EnumWindowsChild($hWnd, $bVisible)
EndIf
$hWnd = _WinAPI_GetWindow($hWnd, $GW_HWNDNEXT)
WEnd
EndFunc
Func __WinAPI_EnumWindowsInit()
ReDim $__g_aWinList_WinAPI[64][2]
$__g_aWinList_WinAPI[0][0] = 0
$__g_aWinList_WinAPI[0][1] = 64
EndFunc
#EndRegion Internal Functions
Global $__g_hButtonLastWnd
Global Const $tagBUTTON_IMAGELIST = "ptr ImageList;" & $tagRECT & ";uint Align"
Global Const $tagBUTTON_SPLITINFO = "uint mask;handle himlGlyph;uint uSplitStyle;" & $tagSIZE
Global Const $__BUTTONCONSTANT_ClassName = "Button"
Global Const $__BUTTONCONSTANT_GWL_STYLE = 0xFFFFFFF0
Global Const $__BUTTONCONSTANT_WM_SETFONT = 0x0030
Global Const $__BUTTONCONSTANT_DEFAULT_GUI_FONT = 17
Func _GUICtrlButton_Click($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_CLICK)
EndFunc
Func _GUICtrlButton_Create($hWnd, $sText, $iX, $iY, $iWidth, $iHeight, $iStyle = -1, $iExStyle = -1)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If Not IsString($sText) Then
Return SetError(2, 0, 0)
EndIf
Local $iForcedStyle = BitOR($__UDFGUICONSTANT_WS_TABSTOP, $__UDFGUICONSTANT_WS_VISIBLE, $__UDFGUICONSTANT_WS_CHILD, $BS_NOTIFY)
If $iStyle = -1 Then
$iStyle = $iForcedStyle
Else
$iStyle = BitOR($iStyle, $iForcedStyle)
EndIf
If $iExStyle = -1 Then $iExStyle = 0
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hButton = _WinAPI_CreateWindowEx($iExStyle, $__BUTTONCONSTANT_ClassName, $sText, $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hButton, $__BUTTONCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__BUTTONCONSTANT_DEFAULT_GUI_FONT), True)
Return $hButton
EndFunc
Func _GUICtrlButton_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hButtonLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlButton_Enable($hWnd, $bEnable = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_EnableWindow($hWnd, $bEnable) = $bEnable
EndFunc
Func _GUICtrlButton_GetCheck($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BM_GETCHECK)
EndFunc
Func _GUICtrlButton_GetFocus($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_GetFocus() = $hWnd
EndFunc
Func _GUICtrlButton_GetIdealSize($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSize = DllStructCreate($tagSIZE), $aSize[2]
Local $iRet = _SendMessage($hWnd, $BCM_GETIDEALSIZE, 0, $tSize, 0, "wparam", "struct*")
If Not $iRet Then Return SetError(-1, -1, $aSize)
$aSize[0] = DllStructGetData($tSize, "X")
$aSize[1] = DllStructGetData($tSize, "Y")
Return $aSize
EndFunc
Func _GUICtrlButton_GetImage($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iRet = _SendMessage($hWnd, $BM_GETIMAGE, 0, 0, 0, "wparam", "lparam", "hwnd")
If $iRet <> 0x00000000 Then Return $iRet
$iRet = _SendMessage($hWnd, $BM_GETIMAGE, 1, 0, 0, "wparam", "lparam", "hwnd")
If $iRet = 0x00000000 Then Return 0
Return $iRet
EndFunc
Func _GUICtrlButton_GetImageList($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST), $aImageList[6]
If Not _SendMessage($hWnd, $BCM_GETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") Then Return SetError(-1, -1, $aImageList)
$aImageList[0] = DllStructGetData($tBUTTON_IMAGELIST, "ImageList")
$aImageList[1] = DllStructGetData($tBUTTON_IMAGELIST, "Left")
$aImageList[2] = DllStructGetData($tBUTTON_IMAGELIST, "Right")
$aImageList[3] = DllStructGetData($tBUTTON_IMAGELIST, "Top")
$aImageList[4] = DllStructGetData($tBUTTON_IMAGELIST, "Bottom")
$aImageList[5] = DllStructGetData($tBUTTON_IMAGELIST, "Align")
Return $aImageList
EndFunc
Func _GUICtrlButton_GetNote($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iLen = _GUICtrlButton_GetNoteLength($hWnd) + 1
Local $tNote = DllStructCreate("wchar Note[" & $iLen & "]")
Local $tLen = DllStructCreate("dword")
DllStructSetData($tLen, 1, $iLen)
If Not _SendMessage($hWnd, $BCM_GETNOTE, $tLen, $tNote, 0, "struct*", "struct*") Then Return SetError(-1, 0, "")
Return _WinAPI_WideCharToMultiByte($tNote)
EndFunc
Func _GUICtrlButton_GetNoteLength($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_GETNOTELENGTH)
EndFunc
Func _GUICtrlButton_GetSplitInfo($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSplitInfo = DllStructCreate($tagBUTTON_SPLITINFO), $aInfo[4]
DllStructSetData($tSplitInfo, "mask", BitOR($BCSIF_GLYPH, $BCSIF_IMAGE, $BCSIF_SIZE, $BCSIF_STYLE))
If Not _SendMessage($hWnd, $BCM_GETSPLITINFO, 0, $tSplitInfo, 0, "wparam", "struct*") Then Return SetError(-1, 0, $aInfo)
$aInfo[0] = DllStructGetData($tSplitInfo, "himlGlyph")
$aInfo[1] = DllStructGetData($tSplitInfo, "uSplitStyle")
$aInfo[2] = DllStructGetData($tSplitInfo, "X")
$aInfo[3] = DllStructGetData($tSplitInfo, "Y")
Return $aInfo
EndFunc
Func _GUICtrlButton_GetState($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BM_GETSTATE)
EndFunc
Func _GUICtrlButton_GetText($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_GetWindowText($hWnd)
Return ""
EndFunc
Func _GUICtrlButton_GetTextMargin($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT), $aRect[4]
If Not _SendMessage($hWnd, $BCM_GETTEXTMARGIN, 0, $tRECT, 0, "wparam", "struct*") Then Return SetError(-1, -1, $aRect)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlButton_SetCheck($hWnd, $iState = $BST_CHECKED)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETCHECK, $iState)
EndFunc
Func _GUICtrlButton_SetDontClick($hWnd, $bState = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETDONTCLICK, $bState)
EndFunc
Func _GUICtrlButton_SetDropDownState($hWnd, $bState = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_SETDROPDOWNSTATE, $bState) <> 0
EndFunc
Func _GUICtrlButton_SetFocus($hWnd, $bFocus = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then
If $bFocus Then
Return _WinAPI_SetFocus($hWnd) <> 0
Else
Return _WinAPI_SetFocus(_WinAPI_GetParent($hWnd)) <> 0
EndIf
EndIf
EndFunc
Func _GUICtrlButton_SetImage($hWnd, $sImageFile, $iIconID = -1, $bLarge = False)
Local $hImage, $hPrevImage
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If StringUpper(StringMid($sImageFile, StringLen($sImageFile) - 2)) = "BMP" Then
If BitAND(_WinAPI_GetWindowLong($hWnd, $__BUTTONCONSTANT_GWL_STYLE), $BS_BITMAP) = $BS_BITMAP Then
$hImage = _WinAPI_LoadImage(0, $sImageFile, 0, 0, 0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
If Not $hImage Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 0, $hImage)
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
EndIf
Else
If $iIconID = -1 Then
$hImage = _WinAPI_LoadImage(0, $sImageFile, 1, 0, 0, BitOR($LR_LOADFROMFILE, $LR_CREATEDIBSECTION))
If Not $hImage Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 1, $hImage)
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
Else
Local $tIcon = DllStructCreate("handle Handle")
Local $iRet
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sImageFile, $iIconID, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sImageFile, $iIconID, 0, $tIcon, 1)
EndIf
If Not $iRet Then Return SetError(-1, -1, False)
$hPrevImage = _SendMessage($hWnd, $BM_SETIMAGE, 1, DllStructGetData($tIcon, "Handle"))
If $hPrevImage Then
If Not _WinAPI_DeleteObject($hPrevImage) Then _WinAPI_DestroyIcon($hPrevImage)
EndIf
_WinAPI_UpdateWindow($hWnd)
Return True
EndIf
EndIf
Return False
EndFunc
Func _GUICtrlButton_SetImageList($hWnd, $hImage, $iAlign = 0, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If $iAlign < 0 Or $iAlign > 4 Then $iAlign = 0
Local $tBUTTON_IMAGELIST = DllStructCreate($tagBUTTON_IMAGELIST)
DllStructSetData($tBUTTON_IMAGELIST, "ImageList", $hImage)
DllStructSetData($tBUTTON_IMAGELIST, "Left", $iLeft)
DllStructSetData($tBUTTON_IMAGELIST, "Top", $iTop)
DllStructSetData($tBUTTON_IMAGELIST, "Right", $iRight)
DllStructSetData($tBUTTON_IMAGELIST, "Bottom", $iBottom)
DllStructSetData($tBUTTON_IMAGELIST, "Align", $iAlign)
Local $bEnabled = _GUICtrlButton_Enable($hWnd, False)
Local $iRet = _SendMessage($hWnd, $BCM_SETIMAGELIST, 0, $tBUTTON_IMAGELIST, 0, "wparam", "struct*") <> 0
_GUICtrlButton_Enable($hWnd)
If Not $bEnabled Then _GUICtrlButton_Enable($hWnd, False)
Return $iRet
EndFunc
Func _GUICtrlButton_SetNote($hWnd, $sNote)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tNote = _WinAPI_MultiByteToWideChar($sNote)
Return _SendMessage($hWnd, $BCM_SETNOTE, 0, $tNote, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_SetShield($hWnd, $bRequired = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $BCM_SETSHIELD, 0, $bRequired) = 1
EndFunc
Func _GUICtrlButton_SetSize($hWnd, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If Not _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return SetError(-1, -1, False)
Local $hParent = _WinAPI_GetParent($hWnd)
If Not $hParent Then Return SetError(-1, -1, False)
Local $aPos = WinGetPos($hWnd)
If Not IsArray($aPos) Then Return SetError(-1, -1, False)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
If Not _WinAPI_ScreenToClient($hParent, $tPoint) Then Return SetError(-1, -1, False)
Local $iRet = WinMove($hWnd, "", DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"), $iWidth, $iHeight)
Return SetError($iRet - 1, $iRet - 1, $iRet <> 0)
EndFunc
Func _GUICtrlButton_SetSplitInfo($hWnd, $hImlGlyph = -1, $iSplitStyle = $BCSS_ALIGNLEFT, $iWidth = 0, $iHeight = 0)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tSplitInfo = DllStructCreate($tagBUTTON_SPLITINFO), $iMask = 0
If $hImlGlyph <> -1 Then
$iMask = BitOR($iMask, $BCSIF_GLYPH)
DllStructSetData($tSplitInfo, "himlGlyph", $hImlGlyph)
EndIf
$iMask = BitOR($iMask, $BCSIF_STYLE)
If BitAND($iSplitStyle, $BCSS_IMAGE) = $BCSS_IMAGE Then $iMask = BitOR($iMask, $BCSIF_IMAGE)
DllStructSetData($tSplitInfo, "uSplitStyle", $iSplitStyle)
If $iWidth > 0 Or $iHeight > 0 Then
$iMask = BitOR($iMask, $BCSIF_SIZE)
DllStructSetData($tSplitInfo, "X", $iWidth)
DllStructSetData($tSplitInfo, "Y", $iHeight)
EndIf
DllStructSetData($tSplitInfo, "mask", $iMask)
Return _SendMessage($hWnd, $BCM_SETSPLITINFO, 0, $tSplitInfo, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_SetState($hWnd, $bHighlighted = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETSTATE, $bHighlighted)
EndFunc
Func _GUICtrlButton_SetStyle($hWnd, $iStyle)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_SendMessage($hWnd, $BM_SETSTYLE, $iStyle, True)
_WinAPI_UpdateWindow($hWnd)
EndFunc
Func _GUICtrlButton_SetText($hWnd, $sText)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then Return _WinAPI_SetWindowText($hWnd, $sText)
EndFunc
Func _GUICtrlButton_SetTextMargin($hWnd, $iLeft = 1, $iTop = 1, $iRight = 1, $iBottom = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
Return _SendMessage($hWnd, $BCM_SETTEXTMARGIN, 0, $tRECT, 0, "wparam", "struct*") <> 0
EndFunc
Func _GUICtrlButton_Show($hWnd, $bShow = True)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If _WinAPI_IsClassName($hWnd, $__BUTTONCONSTANT_ClassName) Then
If $bShow Then
Return _WinAPI_ShowWindow($hWnd, @SW_SHOW)
Else
Return _WinAPI_ShowWindow($hWnd, @SW_HIDE)
EndIf
EndIf
EndFunc
Global Const $GMEM_FIXED = 0x0000
Global Const $GMEM_MOVEABLE = 0x0002
Global Const $GMEM_NOCOMPACT = 0x0010
Global Const $GMEM_NODISCARD = 0x0020
Global Const $GMEM_ZEROINIT = 0x0040
Global Const $GMEM_MODIFY = 0x0080
Global Const $GMEM_DISCARDABLE = 0x0100
Global Const $GMEM_NOT_BANKED = 0x1000
Global Const $GMEM_SHARE = 0x2000
Global Const $GMEM_DDESHARE = 0x2000
Global Const $GMEM_NOTIFY = 0x4000
Global Const $GMEM_LOWER = 0x1000
Global Const $GMEM_VALID_FLAGS = 0x7F72
Global Const $GMEM_INVALID_HANDLE = 0x8000
Global Const $GPTR = BitOR($GMEM_FIXED, $GMEM_ZEROINIT)
Global Const $GHND = BitOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
Global Const $MEM_COMMIT = 0x00001000
Global Const $MEM_RESERVE = 0x00002000
Global Const $MEM_TOP_DOWN = 0x00100000
Global Const $MEM_SHARED = 0x08000000
Global Const $PAGE_NOACCESS = 0x00000001
Global Const $PAGE_READONLY = 0x00000002
Global Const $PAGE_READWRITE = 0x00000004
Global Const $PAGE_EXECUTE = 0x00000010
Global Const $PAGE_EXECUTE_READ = 0x00000020
Global Const $PAGE_EXECUTE_READWRITE = 0x00000040
Global Const $PAGE_EXECUTE_WRITECOPY = 0x00000080
Global Const $PAGE_GUARD = 0x00000100
Global Const $PAGE_NOCACHE = 0x00000200
Global Const $PAGE_WRITECOMBINE = 0x00000400
Global Const $PAGE_WRITECOPY = 0x00000008
Global Const $MEM_DECOMMIT = 0x00004000
Global Const $MEM_RELEASE = 0x00008000
Global Enum $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
Global Const $PROCESS_TERMINATE = 0x00000001
Global Const $PROCESS_CREATE_THREAD = 0x00000002
Global Const $PROCESS_SET_SESSIONID = 0x00000004
Global Const $PROCESS_VM_OPERATION = 0x00000008
Global Const $PROCESS_VM_READ = 0x00000010
Global Const $PROCESS_VM_WRITE = 0x00000020
Global Const $PROCESS_DUP_HANDLE = 0x00000040
Global Const $PROCESS_CREATE_PROCESS = 0x00000080
Global Const $PROCESS_SET_QUOTA = 0x00000100
Global Const $PROCESS_SET_INFORMATION = 0x00000200
Global Const $PROCESS_QUERY_INFORMATION = 0x00000400
Global Const $PROCESS_QUERY_LIMITED_INFORMATION = 0x1000
Global Const $PROCESS_SUSPEND_RESUME = 0x00000800
Global Const $PROCESS_ALL_ACCESS = 0x001F0FFF
Global Const $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
Global Const $SE_AUDIT_NAME = "SeAuditPrivilege"
Global Const $SE_BACKUP_NAME = "SeBackupPrivilege"
Global Const $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
Global Const $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
Global Const $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
Global Const $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
Global Const $SE_CREATE_SYMBOLIC_LINK_NAME = 'SeCreateSymbolicLinkPrivilege'
Global Const $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
Global Const $SE_DEBUG_NAME = "SeDebugPrivilege"
Global Const $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
Global Const $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
Global Const $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
Global Const $SE_INC_WORKING_SET_NAME = 'SeIncreaseWorkingSetPrivilege'
Global Const $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
Global Const $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
Global Const $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
Global Const $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
Global Const $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
Global Const $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
Global Const $SE_RELABEL_NAME = 'SeRelabelPrivilege'
Global Const $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
Global Const $SE_RESTORE_NAME = "SeRestorePrivilege"
Global Const $SE_SECURITY_NAME = "SeSecurityPrivilege"
Global Const $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
Global Const $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
Global Const $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
Global Const $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
Global Const $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
Global Const $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
Global Const $SE_TCB_NAME = "SeTcbPrivilege"
Global Const $SE_TIME_ZONE_NAME = 'SeTimeZonePrivilege'
Global Const $SE_TRUSTED_CREDMAN_ACCESS_NAME = 'SeTrustedCredManAccessPrivilege'
Global Const $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
Global Const $SE_UNDOCK_NAME = "SeUndockPrivilege"
Global Const $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 0x00000001
Global Const $SE_PRIVILEGE_ENABLED = 0x00000002
Global Const $SE_PRIVILEGE_REMOVED = 0x00000004
Global Const $SE_PRIVILEGE_USED_FOR_ACCESS = 0x80000000
Global Const $SE_GROUP_MANDATORY = 0x00000001
Global Const $SE_GROUP_ENABLED_BY_DEFAULT = 0x00000002
Global Const $SE_GROUP_ENABLED = 0x00000004
Global Const $SE_GROUP_OWNER = 0x00000008
Global Const $SE_GROUP_USE_FOR_DENY_ONLY = 0x00000010
Global Const $SE_GROUP_INTEGRITY = 0x00000020
Global Const $SE_GROUP_INTEGRITY_ENABLED = 0x00000040
Global Const $SE_GROUP_RESOURCE = 0x20000000
Global Const $SE_GROUP_LOGON_ID = 0xC0000000
Global Enum $TOKENPRIMARY = 1, $TOKENIMPERSONATION
Global Enum $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
Global Enum $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
Global Const $TOKEN_ASSIGN_PRIMARY = 0x00000001
Global Const $TOKEN_DUPLICATE = 0x00000002
Global Const $TOKEN_IMPERSONATE = 0x00000004
Global Const $TOKEN_QUERY = 0x00000008
Global Const $TOKEN_QUERY_SOURCE = 0x00000010
Global Const $TOKEN_ADJUST_PRIVILEGES = 0x00000020
Global Const $TOKEN_ADJUST_GROUPS = 0x00000040
Global Const $TOKEN_ADJUST_DEFAULT = 0x00000080
Global Const $TOKEN_ADJUST_SESSIONID = 0x00000100
Global Const $TOKEN_ALL_ACCESS = 0x000F01FF
Global Const $TOKEN_READ = 0x00020008
Global Const $TOKEN_WRITE = 0x000200E0
Global Const $TOKEN_EXECUTE = 0x00020000
Global Const $TOKEN_HAS_TRAVERSE_PRIVILEGE = 0x00000001
Global Const $TOKEN_HAS_BACKUP_PRIVILEGE = 0x00000002
Global Const $TOKEN_HAS_RESTORE_PRIVILEGE = 0x00000004
Global Const $TOKEN_HAS_ADMIN_GROUP = 0x00000008
Global Const $TOKEN_IS_RESTRICTED = 0x00000010
Global Const $TOKEN_SESSION_NOT_REFERENCED = 0x00000020
Global Const $TOKEN_SANDBOX_INERT = 0x00000040
Global Const $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 0x00000080
Global Const $RIGHTS_DELETE = 0x00010000
Global Const $READ_CONTROL = 0x00020000
Global Const $WRITE_DAC = 0x00040000
Global Const $WRITE_OWNER = 0x00080000
Global Const $SYNCHRONIZE = 0x00100000
Global Const $ACCESS_SYSTEM_SECURITY = 0x01000000
Global Const $STANDARD_RIGHTS_REQUIRED = 0x000f0000
Global Const $STANDARD_RIGHTS_READ = $READ_CONTROL
Global Const $STANDARD_RIGHTS_WRITE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
Global Const $STANDARD_RIGHTS_ALL = 0x001F0000
Global Const $SPECIFIC_RIGHTS_ALL = 0x0000FFFF
Global Enum $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
Global Enum $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
Global Const $LOGON_WITH_PROFILE = 0x00000001
Global Const $LOGON_NETCREDENTIALS_ONLY = 0x00000002
Global Enum $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
Global Const $SID_ADMINISTRATORS = "S-1-5-32-544"
Global Const $SID_USERS = "S-1-5-32-545"
Global Const $SID_GUESTS = "S-1-5-32-546"
Global Const $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
Global Const $SID_SERVER_OPERATORS = "S-1-5-32-549"
Global Const $SID_PRINT_OPERATORS = "S-1-5-32-550"
Global Const $SID_BACKUP_OPERATORS = "S-1-5-32-551"
Global Const $SID_REPLICATOR = "S-1-5-32-552"
Global Const $SID_OWNER = "S-1-3-0"
Global Const $SID_EVERYONE = "S-1-1-0"
Global Const $SID_NETWORK = "S-1-5-2"
Global Const $SID_INTERACTIVE = "S-1-5-4"
Global Const $SID_SYSTEM = "S-1-5-18"
Global Const $SID_AUTHENTICATED_USERS = "S-1-5-11"
Global Const $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
Global Const $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
Global Const $SID_NT_SERVICE = "S-1-5-80"
Global Const $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
Global Const $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
Global Const $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
Global Const $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
Global Const $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
Global Const $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
Global Const $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
Global Const $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
Global Const $SID_ALL_SERVICES = "S-1-5-80-0"
#Region Global Variables and Constants
Global Const $FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100
Global Const $FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200
Global Const $FORMAT_MESSAGE_FROM_STRING = 0x00000400
Global Const $FORMAT_MESSAGE_FROM_HMODULE = 0x00000800
Global Const $FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000
Global Const $FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000
#EndRegion Global Variables and Constants
Func _WinAPI_Beep($iFreq = 500, $iDuration = 1000)
Local $aResult = DllCall("kernel32.dll", "bool", "Beep", "dword", $iFreq, "dword", $iDuration)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FormatMessage($iFlags, $pSource, $iMessageID, $iLanguageID, ByRef $pBuffer, $iSize, $vArguments)
Local $sBufferType = "struct*"
If IsString($pBuffer) Then $sBufferType = "wstr"
Local $aResult = DllCall("kernel32.dll", "dword", "FormatMessageW", "dword", $iFlags, "struct*", $pSource, "dword", $iMessageID,  "dword", $iLanguageID, $sBufferType, $pBuffer, "dword", $iSize, "ptr", $vArguments)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
If $sBufferType = "wstr" Then $pBuffer = $aResult[5]
Return $aResult[0]
EndFunc
Func _WinAPI_GetErrorMessage($iCode, $iLanguage = 0, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aRet = DllCall('kernel32.dll', 'dword', 'FormatMessageW', 'dword', 0x1000, 'ptr', 0, 'dword', $iCode,  'dword', $iLanguage, 'wstr', '', 'dword', 4096, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return SetError($_iCurrentError, $_iCurrentExtended, StringRegExpReplace($aRet[5], '[' & @LF & ',' & @CR & ']*\Z', ''))
EndFunc
Func _WinAPI_GetLastError(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $aResult = DllCall("kernel32.dll", "dword", "GetLastError")
Return SetError($_iCurrentError, $_iCurrentExtended, $aResult[0])
EndFunc
Func _WinAPI_GetLastErrorMessage(Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $iLastError = _WinAPI_GetLastError()
Local $tBufferPtr = DllStructCreate("ptr")
Local $nCount = _WinAPI_FormatMessage(BitOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM),  0, $iLastError, 0, $tBufferPtr, 0, 0)
If @error Then Return SetError(-@error, @extended, "")
Local $sText = ""
Local $pBuffer = DllStructGetData($tBufferPtr, 1)
If $pBuffer Then
If $nCount > 0 Then
Local $tBuffer = DllStructCreate("wchar[" & ($nCount + 1) & "]", $pBuffer)
$sText = DllStructGetData($tBuffer, 1)
If StringRight($sText, 2) = @CRLF Then $sText = StringTrimRight($sText, 2)
EndIf
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pBuffer)
EndIf
Return SetError($_iCurrentError, $_iCurrentExtended, $sText)
EndFunc
Func _WinAPI_MessageBeep($iType = 1)
Local $iSound
Switch $iType
Case 1
$iSound = 0
Case 2
$iSound = 16
Case 3
$iSound = 32
Case 4
$iSound = 48
Case 5
$iSound = 64
Case Else
$iSound = -1
EndSwitch
Local $aResult = DllCall("user32.dll", "bool", "MessageBeep", "uint", $iSound)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MsgBox($iFlags, $sTitle, $sText)
BlockInput(0)
MsgBox($iFlags, $sTitle, $sText & "      ")
EndFunc
Func _WinAPI_SetLastError($iErrorCode, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
DllCall("kernel32.dll", "none", "SetLastError", "dword", $iErrorCode)
Return SetError($_iCurrentError, $_iCurrentExtended, Null)
EndFunc
Func _WinAPI_ShowError($sText, $bExit = True)
BlockInput(0)
MsgBox($MB_SYSTEMMODAL, "Error", $sText & "      ")
If $bExit Then Exit
EndFunc
Func _WinAPI_ShowLastError($sText = '', $bAbort = False, $iLanguage = 0, Const $_iCurrentError = @error, Const $_iCurrentExtended = @extended)
Local $sError
Local $iLastError = _WinAPI_GetLastError()
While 1
$sError = _WinAPI_GetErrorMessage($iLastError, $iLanguage)
If @error And $iLanguage Then
$iLanguage = 0
Else
ExitLoop
EndIf
WEnd
If StringStripWS($sText, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sText &= @CRLF & @CRLF
Else
$sText = ''
EndIf
_WinAPI_MsgBox(BitOR(0x00040000, BitShift(0x00000010, -2 * (Not $iLastError))), $iLastError, $sText & $sError)
If $iLastError Then
_WinAPI_SetLastError($iLastError)
If $bAbort Then
Exit $iLastError
EndIf
EndIf
Return SetError($_iCurrentError, $_iCurrentExtended, 1)
EndFunc
Func _WinAPI_ShowMsg($sText)
_WinAPI_MsgBox($MB_SYSTEMMODAL, "Information", $sText)
EndFunc
Func __COMErrorFormating(ByRef $oCOMError, $sPrefix = @TAB)
Local Const $STR_STRIPTRAILING = 2
Local $sError = "COM Error encountered in " & @ScriptName & " (" & $oCOMError.Scriptline & ") :" & @CRLF &  $sPrefix & "Number        " & @TAB & "= 0x" & Hex($oCOMError.Number, 8) & " (" & $oCOMError.Number & ")" & @CRLF &  $sPrefix & "WinDescription" & @TAB & "= " & StringStripWS($oCOMError.WinDescription, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Description   " & @TAB & "= " & StringStripWS($oCOMError.Description, $STR_STRIPTRAILING) & @CRLF &  $sPrefix & "Source        " & @TAB & "= " & $oCOMError.Source & @CRLF &  $sPrefix & "HelpFile      " & @TAB & "= " & $oCOMError.HelpFile & @CRLF &  $sPrefix & "HelpContext   " & @TAB & "= " & $oCOMError.HelpContext & @CRLF &  $sPrefix & "LastDllError  " & @TAB & "= " & $oCOMError.LastDllError & @CRLF &  $sPrefix & "Retcode       " & @TAB & "= 0x" & Hex($oCOMError.retcode)
Return $sError
EndFunc
Func _Security__AdjustTokenPrivileges($hToken, $bDisableAll, $tNewState, $iBufferLen, $tPrevState = 0, $pRequired = 0)
Local $aCall = DllCall("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $hToken, "bool", $bDisableAll, "struct*", $tNewState, "dword", $iBufferLen, "struct*", $tPrevState, "struct*", $pRequired)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__CreateProcessWithToken($hToken, $iLogonFlags, $sCommandLine, $iCreationFlags, $sCurDir, $tSTARTUPINFO, $tPROCESS_INFORMATION)
Local $aCall = DllCall("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $hToken, "dword", $iLogonFlags, "ptr", 0, "wstr", $sCommandLine, "dword", $iCreationFlags, "struct*", 0, "wstr", $sCurDir, "struct*", $tSTARTUPINFO, "struct*", $tPROCESS_INFORMATION)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__DuplicateTokenEx($hExistingToken, $iDesiredAccess, $iImpersonationLevel, $iTokenType)
Local $aCall = DllCall("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $hExistingToken, "dword", $iDesiredAccess, "struct*", 0, "int", $iImpersonationLevel, "int", $iTokenType, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[6]
EndFunc
Func _Security__GetAccountSid($sAccount, $sSystem = "")
Local $aAcct = _Security__LookupAccountName($sAccount, $sSystem)
If @error Then Return SetError(@error, @extended, 0)
If IsArray($aAcct) Then Return _Security__StringSidToSid($aAcct[0])
Return ''
EndFunc
Func _Security__GetLengthSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $aCall = DllCall("advapi32.dll", "dword", "GetLengthSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, 0)
Return $aCall[0]
EndFunc
Func _Security__GetTokenInformation($hToken, $iClass)
Local $aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", 0, "dword", 0, "dword*", 0)
If @error Or Not $aCall[5] Then Return SetError(@error + 10, @extended, 0)
Local $iLen = $aCall[5]
Local $tBuffer = DllStructCreate("byte[" & $iLen & "]")
$aCall = DllCall("advapi32.dll", "bool", "GetTokenInformation", "handle", $hToken, "int", $iClass, "struct*", $tBuffer, "dword", DllStructGetSize($tBuffer), "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $tBuffer
EndFunc
Func _Security__ImpersonateSelf($iLevel = $SECURITYIMPERSONATION)
Local $aCall = DllCall("advapi32.dll", "bool", "ImpersonateSelf", "int", $iLevel)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__IsValidSid($pSID)
Local $aCall = DllCall("advapi32.dll", "bool", "IsValidSid", "struct*", $pSID)
If @error Then Return SetError(@error, @extended, False)
Return Not ($aCall[0] = 0)
EndFunc
Func _Security__LookupAccountName($sAccount, $sSystem = "")
Local $tData = DllStructCreate("byte SID[256]")
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $sSystem, "wstr", $sAccount, "struct*", $tData, "dword*", DllStructGetSize($tData), "wstr", "", "dword*", DllStructGetSize($tData), "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = _Security__SidToStringSid(DllStructGetPtr($tData, "SID"))
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupAccountSid($vSID, $sSystem = "")
Local $pSID, $aAcct[3]
If IsString($vSID) Then
$pSID = _Security__StringSidToSid($vSID)
Else
$pSID = $vSID
EndIf
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, @extended, 0)
Local $sTypeSystem = "ptr"
If $sSystem Then $sTypeSystem = "wstr"
Local $aCall = DllCall("advapi32.dll", "bool", "LookupAccountSidW", $sTypeSystem, $sSystem, "struct*", $pSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $aAcct[3]
$aAcct[0] = $aCall[3]
$aAcct[1] = $aCall[5]
$aAcct[2] = $aCall[7]
Return $aAcct
EndFunc
Func _Security__LookupPrivilegeValue($sSystem, $sName)
Local $aCall = DllCall("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $sSystem, "wstr", $sName, "int64*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenProcessToken($hProcess, $iAccess)
Local $aCall = DllCall("advapi32.dll", "bool", "OpenProcessToken", "handle", $hProcess, "dword", $iAccess, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[3]
EndFunc
Func _Security__OpenThreadToken($iAccess, $hThread = 0, $bOpenAsSelf = False)
If $hThread = 0 Then
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error + 10, @extended, 0)
$hThread = $aResult[0]
EndIf
Local $aCall = DllCall("advapi32.dll", "bool", "OpenThreadToken", "handle", $hThread, "dword", $iAccess, "bool", $bOpenAsSelf, "handle*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Return $aCall[4]
EndFunc
Func _Security__OpenThreadTokenEx($iAccess, $hThread = 0, $bOpenAsSelf = False)
Local $hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then
Local Const $ERROR_NO_TOKEN = 1008
If _WinAPI_GetLastError() <> $ERROR_NO_TOKEN Then Return SetError(20, _WinAPI_GetLastError(), 0)
If Not _Security__ImpersonateSelf() Then Return SetError(@error + 10, _WinAPI_GetLastError(), 0)
$hToken = _Security__OpenThreadToken($iAccess, $hThread, $bOpenAsSelf)
If $hToken = 0 Then Return SetError(@error, _WinAPI_GetLastError(), 0)
EndIf
Return $hToken
EndFunc
Func _Security__SetPrivilege($hToken, $sPrivilege, $bEnable)
Local $iLUID = _Security__LookupPrivilegeValue("", $sPrivilege)
If $iLUID = 0 Then Return SetError(@error + 10, @extended, False)
Local Const $tagTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
Local $tCurrState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iCurrState = DllStructGetSize($tCurrState)
Local $tPrevState = DllStructCreate($tagTOKEN_PRIVILEGES)
Local $iPrevState = DllStructGetSize($tPrevState)
Local $tRequired = DllStructCreate("int Data")
DllStructSetData($tCurrState, "Count", 1)
DllStructSetData($tCurrState, "LUID", $iLUID)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tCurrState, $iCurrState, $tPrevState, $tRequired) Then Return SetError(2, @error, False)
DllStructSetData($tPrevState, "Count", 1)
DllStructSetData($tPrevState, "LUID", $iLUID)
Local $iAttributes = DllStructGetData($tPrevState, "Attributes")
If $bEnable Then
$iAttributes = BitOR($iAttributes, $SE_PRIVILEGE_ENABLED)
Else
$iAttributes = BitAND($iAttributes, BitNOT($SE_PRIVILEGE_ENABLED))
EndIf
DllStructSetData($tPrevState, "Attributes", $iAttributes)
If Not _Security__AdjustTokenPrivileges($hToken, False, $tPrevState, $iPrevState, $tCurrState, $tRequired) Then  Return SetError(3, @error, False)
Return True
EndFunc
Func _Security__SetTokenInformation($hToken, $iTokenInformation, $vTokenInformation, $iTokenInformationLength)
Local $aCall = DllCall("advapi32.dll", "bool", "SetTokenInformation", "handle", $hToken, "int", $iTokenInformation, "struct*", $vTokenInformation, "dword", $iTokenInformationLength)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, False)
Return True
EndFunc
Func _Security__SidToStringSid($pSID)
If Not _Security__IsValidSid($pSID) Then Return SetError(@error + 10, 0, "")
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $pSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, "")
Local $pStringSid = $aCall[2]
Local $aLen = DllCall("kernel32.dll", "int", "lstrlenW", "struct*", $pStringSid)
Local $sSID = DllStructGetData(DllStructCreate("wchar Text[" & $aLen[0] + 1 & "]", $pStringSid), "Text")
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pStringSid)
Return $sSID
EndFunc
Func _Security__SidTypeStr($iType)
Switch $iType
Case $SIDTYPEUSER
Return "User"
Case $SIDTYPEGROUP
Return "Group"
Case $SIDTYPEDOMAIN
Return "Domain"
Case $SIDTYPEALIAS
Return "Alias"
Case $SIDTYPEWELLKNOWNGROUP
Return "Well Known Group"
Case $SIDTYPEDELETEDACCOUNT
Return "Deleted Account"
Case $SIDTYPEINVALID
Return "Invalid"
Case $SIDTYPEUNKNOWN
Return "Unknown Type"
Case $SIDTYPECOMPUTER
Return "Computer"
Case $SIDTYPELABEL
Return "A mandatory integrity label SID"
Case Else
Return "Unknown SID Type"
EndSwitch
EndFunc
Func _Security__StringSidToSid($sSID)
Local $aCall = DllCall("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $sSID, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(@error, @extended, 0)
Local $pSID = $aCall[2]
Local $tBuffer = DllStructCreate("byte Data[" & _Security__GetLengthSid($pSID) & "]", $pSID)
Local $tSID = DllStructCreate("byte Data[" & DllStructGetSize($tBuffer) & "]")
DllStructSetData($tSID, "Data", DllStructGetData($tBuffer, "Data"))
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $pSID)
Return $tSID
EndFunc
Global Const $tagMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
Func _MemFree(ByRef $tMemMap)
Local $pMemory = DllStructGetData($tMemMap, "Mem")
Local $hProcess = DllStructGetData($tMemMap, "hProc")
Local $bResult = _MemVirtualFreeEx($hProcess, $pMemory, 0, $MEM_RELEASE)
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $bResult
EndFunc
Func _MemGlobalAlloc($iBytes, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "GlobalAlloc", "uint", $iFlags, "ulong_ptr", $iBytes)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalFree($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalFree", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemGlobalLock($hMemory)
Local $aResult = DllCall("kernel32.dll", "ptr", "GlobalLock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalSize($hMemory)
Local $aResult = DllCall("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemGlobalUnlock($hMemory)
Local $aResult = DllCall("kernel32.dll", "bool", "GlobalUnlock", "handle", $hMemory)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemInit($hWnd, $iSize, ByRef $tMemMap)
Local $aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
If @error Then Return SetError(@error + 10, @extended, 0)
Local $iProcessID = $aResult[2]
If $iProcessID = 0 Then Return SetError(1, 0, 0)
Local $iAccess = BitOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
Local $hProcess = __Mem_OpenProcess($iAccess, False, $iProcessID, True)
Local $iAlloc = BitOR($MEM_RESERVE, $MEM_COMMIT)
Local $pMemory = _MemVirtualAllocEx($hProcess, 0, $iSize, $iAlloc, $PAGE_READWRITE)
If $pMemory = 0 Then Return SetError(2, 0, 0)
$tMemMap = DllStructCreate($tagMEMMAP)
DllStructSetData($tMemMap, "hProc", $hProcess)
DllStructSetData($tMemMap, "Size", $iSize)
DllStructSetData($tMemMap, "Mem", $pMemory)
Return $pMemory
EndFunc
Func _MemMoveMemory($pSource, $pDest, $iLength)
DllCall("kernel32.dll", "none", "RtlMoveMemory", "struct*", $pDest, "struct*", $pSource, "ulong_ptr", $iLength)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _MemRead(ByRef $tMemMap, $pSrce, $pDest, $iSize)
Local $aResult = DllCall("kernel32.dll", "bool", "ReadProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pSrce, "struct*", $pDest, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemWrite(ByRef $tMemMap, $pSrce, $pDest = 0, $iSize = 0, $sSrce = "struct*")
If $pDest = 0 Then $pDest = DllStructGetData($tMemMap, "Mem")
If $iSize = 0 Then $iSize = DllStructGetData($tMemMap, "Size")
Local $aResult = DllCall("kernel32.dll", "bool", "WriteProcessMemory", "handle", DllStructGetData($tMemMap, "hProc"),  "ptr", $pDest, $sSrce, $pSrce, "ulong_ptr", $iSize, "ulong_ptr*", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualAlloc($pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualAllocEx($hProcess, $pAddress, $iSize, $iAllocation, $iProtect)
Local $aResult = DllCall("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iAllocation, "dword", $iProtect)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _MemVirtualFree($pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFree", "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _MemVirtualFreeEx($hProcess, $pAddress, $iSize, $iFreeType)
Local $aResult = DllCall("kernel32.dll", "bool", "VirtualFreeEx", "handle", $hProcess, "ptr", $pAddress, "ulong_ptr", $iSize, "dword", $iFreeType)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func __Mem_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Global Const $TCS_EX_FLATSEPARATORS = 0x00000001
Global Const $TCS_EX_REGISTERDROP = 0x00000002
Global Const $TCHT_NOWHERE = 0x00000001
Global Const $TCHT_ONITEMICON = 0x00000002
Global Const $TCHT_ONITEMLABEL = 0x00000004
Global Const $TCHT_ONITEM = 0x00000006
Global Const $TCIF_TEXT = 0x00000001
Global Const $TCIF_IMAGE = 0x00000002
Global Const $TCIF_RTLREADING = 0x00000004
Global Const $TCIF_PARAM = 0x00000008
Global Const $TCIF_STATE = 0x00000010
Global Const $TCIF_ALLDATA = 0x0000001B
Global Const $TCIS_BUTTONPRESSED = 0x00000001
Global Const $TCIS_HIGHLIGHTED = 0x00000002
Global Const $TC_ERR = -1
Global Const $TCS_BOTTOM = 0x00000002
Global Const $TCS_BUTTONS = 0x00000100
Global Const $TCS_FIXEDWIDTH = 0x00000400
Global Const $TCS_FLATBUTTONS = 0x00000008
Global Const $TCS_FOCUSNEVER = 0x00008000
Global Const $TCS_FOCUSONBUTTONDOWN = 0x00001000
Global Const $TCS_FORCEICONLEFT = 0x00000010
Global Const $TCS_FORCELABELLEFT = 0x00000020
Global Const $TCS_HOTTRACK = 0x00000040
Global Const $TCS_MULTILINE = 0x00000200
Global Const $TCS_MULTISELECT = 0x00000004
Global Const $TCS_OWNERDRAWFIXED = 0x00002000
Global Const $TCS_RAGGEDRIGHT = 0x00000800
Global Const $TCS_RIGHT = 0x00000002
Global Const $TCS_RIGHTJUSTIFY = 0x00000000
Global Const $TCS_SCROLLOPPOSITE = 0x00000001
Global Const $TCS_SINGLELINE = 0x00000000
Global Const $TCS_TABS = 0x00000000
Global Const $TCS_TOOLTIPS = 0x00004000
Global Const $TCS_VERTICAL = 0x00000080
Global Const $GUI_SS_DEFAULT_TAB = 0
Global Const $TCM_FIRST = 0x1300
Global Const $TCCM_FIRST = 0X2000
Global Const $TCM_ADJUSTRECT = ($TCM_FIRST + 40)
Global Const $TCM_DELETEALLITEMS = ($TCM_FIRST + 9)
Global Const $TCM_DELETEITEM = ($TCM_FIRST + 8)
Global Const $TCM_DESELECTALL = ($TCM_FIRST + 50)
Global Const $TCM_GETCURFOCUS = ($TCM_FIRST + 47)
Global Const $TCM_GETCURSEL = ($TCM_FIRST + 11)
Global Const $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 53)
Global Const $TCM_GETIMAGELIST = ($TCM_FIRST + 2)
Global Const $TCM_GETITEMA = ($TCM_FIRST + 5)
Global Const $TCM_GETITEMW = ($TCM_FIRST + 60)
Global Const $TCM_GETITEMCOUNT = ($TCM_FIRST + 4)
Global Const $TCM_GETITEMRECT = ($TCM_FIRST + 10)
Global Const $TCM_GETROWCOUNT = ($TCM_FIRST + 44)
Global Const $TCM_GETTOOLTIPS = ($TCM_FIRST + 45)
Global Const $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 6)
Global Const $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
Global Const $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 51)
Global Const $TCM_HITTEST = ($TCM_FIRST + 13)
Global Const $TCM_INSERTITEMA = ($TCM_FIRST + 7)
Global Const $TCM_INSERTITEMW = ($TCM_FIRST + 62)
Global Const $TCM_REMOVEIMAGE = ($TCM_FIRST + 42)
Global Const $TCM_SETITEMA = ($TCM_FIRST + 6)
Global Const $TCM_SETITEMW = ($TCM_FIRST + 61)
Global Const $TCM_SETITEMEXTRA = ($TCM_FIRST + 14)
Global Const $TCM_SETITEMSIZE = $TCM_FIRST + 41
Global Const $TCM_SETCURFOCUS = ($TCM_FIRST + 48)
Global Const $TCM_SETCURSEL = ($TCM_FIRST + 12)
Global Const $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 52)
Global Const $TCM_SETIMAGELIST = $TCM_FIRST + 3
Global Const $TCM_SETMINTABWIDTH = ($TCM_FIRST + 49)
Global Const $TCM_SETPADDING = ($TCM_FIRST + 43)
Global Const $TCM_SETTOOLTIPS = ($TCM_FIRST + 46)
Global Const $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 5)
Global Const $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
Global Const $TCN_FIRST = -550
Global Const $TCN_FOCUSCHANGE = ($TCN_FIRST - 4)
Global Const $TCN_GETOBJECT = ($TCN_FIRST - 3)
Global Const $TCN_KEYDOWN = ($TCN_FIRST - 0)
Global Const $TCN_SELCHANGE = ($TCN_FIRST - 1)
Global Const $TCN_SELCHANGING = ($TCN_FIRST - 2)
Global $__g_hTabLastWnd
Global Const $__TABCONSTANT_ClassName = "SysTabControl32"
Global Const $__TABCONSTANT_WS_CLIPSIBLINGS = 0x04000000
Global Const $__TABCONSTANT_WM_NOTIFY = 0x004E
Global Const $__TABCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $tagTCITEM = "uint Mask;dword State;dword StateMask;ptr Text;int TextMax;int Image;lparam Param"
Global Const $tagTCHITTESTINFO = $tagPOINT & ";uint Flags"
Func __GUICtrlTab_AdjustRect($hWnd, ByRef $tRECT, $bLarger = False)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $TCM_ADJUSTRECT, $bLarger, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_ActivateTab($hWnd, $iIndex)
Local $nIndX
If $hWnd = -1 Then $hWnd = GUICtrlGetHandle(-1)
If IsHWnd($hWnd) Then
$nIndX = _WinAPI_GetDlgCtrlID($hWnd)
Else
$nIndX = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
Local $hParent = _WinAPI_GetParent($hWnd)
If @error Then Return SetError(1, 0, -1)
Local $tNmhdr = DllStructCreate($tagNMHDR)
DllStructSetData($tNmhdr, 1, $hWnd)
DllStructSetData($tNmhdr, 2, $nIndX)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGING)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Local $iRet = _GUICtrlTab_SetCurSel($hWnd, $iIndex)
DllStructSetData($tNmhdr, 3, $TCN_SELCHANGE)
_SendMessage($hParent, $__TABCONSTANT_WM_NOTIFY, $nIndX, $tNmhdr, 0, "wparam", "struct*")
Return $iRet
EndFunc
Func _GUICtrlTab_ClickTab($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $iX, $iY
If Not $bMove Then
Local $hWinParent = _WinAPI_GetParent($hWnd)
Local $avTabPos = _GUICtrlTab_GetItemRect($hWnd, $iIndex)
$iX = $avTabPos[0] + (($avTabPos[2] - $avTabPos[0]) / 2)
$iY = $avTabPos[1] + (($avTabPos[3] - $avTabPos[1]) / 2)
ControlClick($hWinParent, "", $hWnd, $sButton, $iClicks, $iX, $iY)
Else
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
Opt("MouseCoordMode", $iMode)
EndIf
EndFunc
Func _GUICtrlTab_Create($hWnd, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x00000040, $iExStyle = 0x00000000)
If Not IsHWnd($hWnd) Then
Return SetError(1, 0, 0)
EndIf
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $TCS_HOTTRACK
If $iExStyle = -1 Then $iExStyle = 0x00000000
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__TABCONSTANT_WS_CLIPSIBLINGS, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hTab = _WinAPI_CreateWindowEx($iExStyle, $__TABCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_WinAPI_SetFont($hTab, _WinAPI_GetStockObject($__TABCONSTANT_DEFAULT_GUI_FONT))
Return $hTab
EndFunc
Func _GUICtrlTab_DeleteAllItems($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEALLITEMS) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEALLITEMS, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeleteItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_DELETEITEM, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_DELETEITEM, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_DeselectAll($hWnd, $bExclude = True)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_DESELECTALL, $bExclude)
Else
GUICtrlSendMsg($hWnd, $TCM_DESELECTALL, $bExclude, 0)
EndIf
EndFunc
Func _GUICtrlTab_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__TABCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlTab_FindTab($hWnd, $sText, $bInStr = False, $iStart = 0)
Local $sTab
For $iI = $iStart To _GUICtrlTab_GetItemCount($hWnd)
$sTab = _GUICtrlTab_GetItemText($hWnd, $iI)
Switch $bInStr
Case False
If $sTab = $sText Then Return $iI
Case True
If StringInStr($sTab, $sText) Then Return $iI
EndSwitch
Next
Return -1
EndFunc
Func _GUICtrlTab_GetCurFocus($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURFOCUS)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURFOCUS, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetCurSel($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETCURSEL)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETCURSEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetDisplayRect($hWnd)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetDisplayRectEx($hWnd)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetDisplayRectEx($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Return __GUICtrlTab_AdjustRect($hWnd, $tRECT)
EndFunc
Func _GUICtrlTab_GetExtendedStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETEXTENDEDSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETEXTENDEDSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetImageList($hWnd)
If IsHWnd($hWnd) Then
Return Ptr(_SendMessage($hWnd, $TCM_GETIMAGELIST))
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_GETIMAGELIST, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetItem($hWnd, $iIndex)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = 4096
Local $tagTCITEMEx = $tagTCITEM & ";ptr Filler"
Local $tItem = DllStructCreate($tagTCITEMEx)
DllStructSetData($tItem, "Mask", $TCIF_ALLDATA)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "StateMask", BitOR($TCIS_HIGHLIGHTED, $TCIS_BUTTONPRESSED))
Local $iItem = DllStructGetSize($tItem)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
Local $iRet
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_GETITEMW, $iIndex, $pMemory)
Else
$iRet = _SendMessage($hWnd, $TCM_GETITEMA, $iIndex, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
Local $aItem[4]
$aItem[0] = DllStructGetData($tItem, "State")
$aItem[1] = DllStructGetData($tBuffer, "Text")
$aItem[2] = DllStructGetData($tItem, "Image")
$aItem[3] = DllStructGetData($tItem, "Param")
Return SetError($iRet = 0, 0, $aItem)
EndFunc
Func _GUICtrlTab_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetItemImage($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[2]
EndFunc
Func _GUICtrlTab_GetItemParam($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[3]
EndFunc
Func _GUICtrlTab_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlTab_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $TCM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $TCM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlTab_GetItemState($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[0]
EndFunc
Func _GUICtrlTab_GetItemText($hWnd, $iIndex)
Local $aItem = _GUICtrlTab_GetItem($hWnd, $iIndex)
Return $aItem[1]
EndFunc
Func _GUICtrlTab_GetRowCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETROWCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETROWCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlTab_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $TCM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $TCM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HighlightItem($hWnd, $iIndex, $bHighlight = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_HIGHLIGHTITEM, $iIndex, $bHighlight) <> 0
EndIf
EndFunc
Func _GUICtrlTab_HitTest($hWnd, $iX, $iY)
Local $aHit[2] = [-1, 1]
Local $tHit = DllStructCreate($tagTCHITTESTINFO)
DllStructSetData($tHit, "X", $iX)
DllStructSetData($tHit, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $tHit, 0, "wparam", "struct*")
Else
Local $iHit = DllStructGetSize($tHit)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iHit, $tMemMap)
_MemWrite($tMemMap, $tHit)
$aHit[0] = _SendMessage($hWnd, $TCM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tHit, $iHit)
_MemFree($tMemMap)
EndIf
Else
$aHit[0] = GUICtrlSendMsg($hWnd, $TCM_HITTEST, 0, DllStructGetPtr($tHit))
EndIf
$aHit[1] = DllStructGetData($tHit, "Flags")
Return $aHit
EndFunc
Func _GUICtrlTab_InsertItem($hWnd, $iIndex, $sText, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagTCITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", BitOR($TCIF_TEXT, $TCIF_IMAGE, $TCIF_PARAM))
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hTabLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $TCM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMW, $iIndex, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $TCM_INSERTITEMA, $iIndex, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlTab_RemoveImage($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_REMOVEIMAGE, $iIndex)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $TCM_REMOVEIMAGE, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurFocus($hWnd, $iIndex)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETCURFOCUS, $iIndex)
Else
GUICtrlSendMsg($hWnd, $TCM_SETCURFOCUS, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetCurSel($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETCURSEL, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETCURSEL, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetExtendedStyle($hWnd, $iStyle)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETEXTENDEDSTYLE, 0, $iStyle)
EndIf
EndFunc
Func _GUICtrlTab_SetImageList($hWnd, $hImage)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $TCM_SETIMAGELIST, 0, $hImage))
EndIf
EndFunc
Func _GUICtrlTab_SetItem($hWnd, $iIndex, $sText = -1, $iState = -1, $iImage = -1, $iParam = -1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $tItem = DllStructCreate($tagTCITEM)
Local $iBuffer, $tBuffer, $iMask = 0, $iRet
Local $bUnicode = _GUICtrlTab_GetUnicodeFormat($hWnd)
If IsString($sText) Then
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
$iMask = $TCIF_TEXT
EndIf
If $iState <> -1 Then
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iState)
$iMask = BitOR($iMask, $TCIF_STATE)
EndIf
If $iImage <> -1 Then
DllStructSetData($tItem, "Image", $iImage)
$iMask = BitOR($iMask, $TCIF_IMAGE)
EndIf
If $iParam <> -1 Then
DllStructSetData($tItem, "Param", $iParam)
$iMask = BitOR($iMask, $TCIF_PARAM)
EndIf
DllStructSetData($tItem, "Mask", $iMask)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 8192, $tMemMap)
Local $pText = $pMemory + 4096
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If IsString($sText) Then _MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $TCM_SETITEMW, $iIndex, $pMemory) <> 0
Else
$iRet = _SendMessage($hWnd, $TCM_SETITEMA, $iIndex, $pMemory) <> 0
EndIf
_MemFree($tMemMap)
Return $iRet
EndFunc
Func _GUICtrlTab_SetItemImage($hWnd, $iIndex, $iImage)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, $iImage)
EndFunc
Func _GUICtrlTab_SetItemParam($hWnd, $iIndex, $iParam)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, -1, -1, $iParam)
EndFunc
Func _GUICtrlTab_SetItemSize($hWnd, $iWidth, $iHeight)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETITEMSIZE, 0, _WinAPI_MakeLong($iWidth, $iHeight))
EndIf
EndFunc
Func _GUICtrlTab_SetItemState($hWnd, $iIndex, $iState)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, -1, $iState)
EndFunc
Func _GUICtrlTab_SetItemText($hWnd, $iIndex, $sText)
Return _GUICtrlTab_SetItem($hWnd, $iIndex, $sText)
EndFunc
Func _GUICtrlTab_SetMinTabWidth($hWnd, $iMinWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETMINTABWIDTH, 0, $iMinWidth)
EndIf
EndFunc
Func _GUICtrlTab_SetPadding($hWnd, $iHorz, $iVert)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
Else
GUICtrlSendMsg($hWnd, $TCM_SETPADDING, 0, _WinAPI_MakeLong($iHorz, $iVert))
EndIf
EndFunc
Func _GUICtrlTab_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0, 0, "hwnd")
Else
GUICtrlSendMsg($hWnd, $TCM_SETTOOLTIPS, $hToolTip, 0)
EndIf
EndFunc
Func _GUICtrlTab_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode) <> 0
Else
Return GUICtrlSendMsg($hWnd, $TCM_SETUNICODEFORMAT, $bUnicode, 0) <> 0
EndIf
EndFunc
Global Const $ES_LEFT = 0
Global Const $ES_CENTER = 1
Global Const $ES_RIGHT = 2
Global Const $ES_MULTILINE = 4
Global Const $ES_UPPERCASE = 8
Global Const $ES_LOWERCASE = 16
Global Const $ES_PASSWORD = 32
Global Const $ES_AUTOVSCROLL = 64
Global Const $ES_AUTOHSCROLL = 128
Global Const $ES_NOHIDESEL = 256
Global Const $ES_OEMCONVERT = 1024
Global Const $ES_READONLY = 2048
Global Const $ES_WANTRETURN = 4096
Global Const $ES_NUMBER = 8192
Global Const $EC_ERR = -1
Global Const $ECM_FIRST = 0X1500
Global Const $EM_CANUNDO = 0xC6
Global Const $EM_CHARFROMPOS = 0xD7
Global Const $EM_EMPTYUNDOBUFFER = 0xCD
Global Const $EM_FMTLINES = 0xC8
Global Const $EM_GETCUEBANNER = ($ECM_FIRST + 2)
Global Const $EM_GETFIRSTVISIBLELINE = 0xCE
Global Const $EM_GETHANDLE = 0xBD
Global Const $EM_GETIMESTATUS = 0xD9
Global Const $EM_GETLIMITTEXT = 0xD5
Global Const $EM_GETLINE = 0xC4
Global Const $EM_GETLINECOUNT = 0xBA
Global Const $EM_GETMARGINS = 0xD4
Global Const $EM_GETMODIFY = 0xB8
Global Const $EM_GETPASSWORDCHAR = 0xD2
Global Const $EM_GETRECT = 0xB2
Global Const $EM_GETSEL = 0xB0
Global Const $EM_GETTHUMB = 0xBE
Global Const $EM_GETWORDBREAKPROC = 0xD1
Global Const $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
Global Const $EM_LIMITTEXT = 0xC5
Global Const $EM_LINEFROMCHAR = 0xC9
Global Const $EM_LINEINDEX = 0xBB
Global Const $EM_LINELENGTH = 0xC1
Global Const $EM_LINESCROLL = 0xB6
Global Const $EM_POSFROMCHAR = 0xD6
Global Const $EM_REPLACESEL = 0xC2
Global Const $EM_SCROLL = 0xB5
Global Const $EM_SCROLLCARET = 0x00B7
Global Const $EM_SETCUEBANNER = ($ECM_FIRST + 1)
Global Const $EM_SETHANDLE = 0xBC
Global Const $EM_SETIMESTATUS = 0xD8
Global Const $EM_SETLIMITTEXT = $EM_LIMITTEXT
Global Const $EM_SETMARGINS = 0xD3
Global Const $EM_SETMODIFY = 0xB9
Global Const $EM_SETPASSWORDCHAR = 0xCC
Global Const $EM_SETREADONLY = 0xCF
Global Const $EM_SETRECT = 0xB3
Global Const $EM_SETRECTNP = 0xB4
Global Const $EM_SETSEL = 0xB1
Global Const $EM_SETTABSTOPS = 0xCB
Global Const $EM_SETWORDBREAKPROC = 0xD0
Global Const $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
Global Const $EM_UNDO = 0xC7
Global Const $EC_LEFTMARGIN = 0x1
Global Const $EC_RIGHTMARGIN = 0x2
Global Const $EC_USEFONTINFO = 0xFFFF
Global Const $EMSIS_COMPOSITIONSTRING = 0x1
Global Const $EIMES_GETCOMPSTRATONCE = 0x1
Global Const $EIMES_CANCELCOMPSTRINFOCUS = 0x2
Global Const $EIMES_COMPLETECOMPSTRKILLFOCUS = 0x4
Global Const $EN_ALIGN_LTR_EC = 0x700
Global Const $EN_ALIGN_RTL_EC = 0x701
Global Const $EN_CHANGE = 0x300
Global Const $EN_ERRSPACE = 0x500
Global Const $EN_HSCROLL = 0X601
Global Const $EN_KILLFOCUS = 0x200
Global Const $EN_MAXTEXT = 0x501
Global Const $EN_SETFOCUS = 0x100
Global Const $EN_UPDATE = 0x400
Global Const $EN_VSCROLL = 0x602
Global Const $GUI_SS_DEFAULT_EDIT = 0x003010c0
Global Const $GUI_SS_DEFAULT_INPUT = 0x00000080
Global Const $CREATE_BREAKAWAY_FROM_JOB = 0x01000000
Global Const $CREATE_DEFAULT_ERROR_MODE = 0x04000000
Global Const $CREATE_NEW_CONSOLE = 0x00000010
Global Const $CREATE_NEW_PROCESS_GROUP = 0x00000200
Global Const $CREATE_NO_WINDOW = 0x08000000
Global Const $CREATE_PROTECTED_PROCESS = 0x00040000
Global Const $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 0x02000000
Global Const $CREATE_SEPARATE_WOW_VDM = 0x00000800
Global Const $CREATE_SHARED_WOW_VDM = 0x00001000
Global Const $CREATE_SUSPENDED = 0x00000004
Global Const $CREATE_UNICODE_ENVIRONMENT = 0x00000400
Global Const $LIST_MODULES_32BIT = 1
Global Const $LIST_MODULES_64BIT = 2
Global Const $LIST_MODULES_ALL = 3
Global Const $LIST_MODULES_DEFAULT = 0
Global Const $ABOVE_NORMAL_PRIORITY_CLASS = 0x00008000
Global Const $BELOW_NORMAL_PRIORITY_CLASS = 0x00004000
Global Const $HIGH_PRIORITY_CLASS = 0x00000080
Global Const $IDLE_PRIORITY_CLASS = 0x00000040
Global Const $NORMAL_PRIORITY_CLASS = 0x00000020
Global Const $REALTIME_PRIORITY_CLASS = 0x00000100
Global Const $PROCESS_MODE_BACKGROUND_BEGIN = 0x00100000
Global Const $PROCESS_MODE_BACKGROUND_END = 0x00200000
Global Const $MUTEX_MODIFY_STATE = 0x0001
Global Const $MUTEX_ALL_ACCESS = 0x001F0001
Global Const $JOB_OBJECT_ASSIGN_PROCESS = 0x0001
Global Const $JOB_OBJECT_QUERY = 0x0004
Global Const $JOB_OBJECT_SET_ATTRIBUTES = 0x0002
Global Const $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 0x0010
Global Const $JOB_OBJECT_TERMINATE = 0x0008
Global Const $JOB_OBJECT_ALL_ACCESS = 0x001F001F
Global Const $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 0x00000008
Global Const $JOB_OBJECT_LIMIT_AFFINITY = 0x00000010
Global Const $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 0x00000800
Global Const $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 0x00000400
Global Const $JOB_OBJECT_LIMIT_JOB_MEMORY = 0x00000200
Global Const $JOB_OBJECT_LIMIT_JOB_TIME = 0x00000004
Global Const $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 0x00002000
Global Const $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 0x00000040
Global Const $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 0x00000020
Global Const $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 0x00000100
Global Const $JOB_OBJECT_LIMIT_PROCESS_TIME = 0x00000002
Global Const $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 0x00000080
Global Const $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 0x00001000
Global Const $JOB_OBJECT_LIMIT_WORKINGSET = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_DESKTOP = 0x00000040
Global Const $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 0x00000010
Global Const $JOB_OBJECT_UILIMIT_EXITWINDOWS = 0x00000080
Global Const $JOB_OBJECT_UILIMIT_GLOBALATOMS = 0x00000020
Global Const $JOB_OBJECT_UILIMIT_HANDLES = 0x00000001
Global Const $JOB_OBJECT_UILIMIT_READCLIPBOARD = 0x00000002
Global Const $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 0x00000008
Global Const $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 0x00000004
Global Const $JOB_OBJECT_SECURITY_FILTER_TOKENS = 0x00000008
Global Const $JOB_OBJECT_SECURITY_NO_ADMIN = 0x00000001
Global Const $JOB_OBJECT_SECURITY_ONLY_TOKEN = 0x00000004
Global Const $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 0x00000002
Global Const $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
Global Const $JOB_OBJECT_POST_AT_END_OF_JOB = 1
Global Const $SEMAPHORE_MODIFY_STATE = 0x0002
Global Const $SEMAPHORE_QUERY_STATE = 0x0001
Global Const $SEMAPHORE_ALL_ACCESS = 0x001F0003
Global Const $ES_AWAYMODE_REQUIRED = 0x00000040
Global Const $ES_CONTINUOUS = 0x80000000
Global Const $ES_DISPLAY_REQUIRED = 0x00000002
Global Const $ES_SYSTEM_REQUIRED = 0x00000001
Global Const $ES_USER_PRESENT = 0x00000004
Global Const $COINIT_APARTMENTTHREADED = 0x02
Global Const $COINIT_DISABLE_OLE1DDE = 0x04
Global Const $COINIT_MULTITHREADED = 0x00
Global Const $COINIT_SPEED_OVER_MEMORY = 0x08
#Region Global Variables and Constants
Global Const $__tagWinAPICom_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CLSIDFromProgID($sProgID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CLSIDFromProgID', 'wstr', $sProgID, 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 39)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CoInitialize($iFlags = 0)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemAlloc($iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemAlloc', 'uint_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoTaskMemFree($pMemory)
DllCall('ole32.dll', 'none', 'CoTaskMemFree', 'ptr', $pMemory)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CoTaskMemRealloc($pMemory, $iSize)
Local $aReturn = DllCall('ole32.dll', 'ptr', 'CoTaskMemRealloc', 'ptr', $pMemory, 'ulong_ptr', $iSize)
If @error Then Return SetError(@error, @extended, 0)
Return $aReturn[0]
EndFunc
Func _WinAPI_CoUninitialize()
DllCall('ole32.dll', 'none', 'CoUninitialize')
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_CreateGUID()
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'long', 'CoCreateGuid', 'struct*', $tGUID)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
$aReturn = DllCall('ole32.dll', 'int', 'StringFromGUID2', 'struct*', $tGUID, 'wstr', '', 'int', 65536)
If @error Or Not $aReturn[0] Then Return SetError(@error + 20, @extended, '')
Return $aReturn[2]
EndFunc
Func _WinAPI_CreateStreamOnHGlobal($hGlobal = 0, $bDeleteOnRelease = True)
Local $aReturn = DllCall('ole32.dll', 'long', 'CreateStreamOnHGlobal', 'handle', $hGlobal, 'bool', $bDeleteOnRelease, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[3]
EndFunc
Func _WinAPI_GetHGlobalFromStream($pStream)
Local $aReturn = DllCall('ole32.dll', 'uint', 'GetHGlobalFromStream', 'ptr', $pStream, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return $aReturn[2]
EndFunc
Func _WinAPI_ProgIDFromCLSID($sCLSID)
Local $tGUID = DllStructCreate($__tagWinAPICom_GUID)
Local $aReturn = DllCall('ole32.dll', 'uint', 'CLSIDFromString', 'wstr', $sCLSID, 'struct*', $tGUID)
If @error Or $aReturn[0] Then Return SetError(@error + 20, @extended, '')
$aReturn = DllCall('ole32.dll', 'uint', 'ProgIDFromCLSID', 'struct*', $tGUID, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aReturn[0] Then Return SetError(10, $aReturn[0], '')
Local $sID = _WinAPI_GetString($aReturn[2])
_WinAPI_CoTaskMemFree($aReturn[2])
Return $sID
EndFunc
Func _WinAPI_ReleaseStream($pStream)
Local $aReturn = DllCall('oleaut32.dll', 'long', 'DispCallFunc', 'ptr', $pStream, 'ulong_ptr', 8 * (1 + @AutoItX64), 'uint', 4,  'ushort', 23, 'uint', 0, 'ptr', 0, 'ptr', 0, 'str', '')
If @error Then Return SetError(@error, @extended, 0)
If $aReturn[0] Then Return SetError(10, $aReturn[0], 0)
Return 1
EndFunc
#EndRegion Public Functions
Global Const $URL_SCHEME_INVALID = -1
Global Const $URL_SCHEME_UNKNOWN = 0
Global Const $URL_SCHEME_FTP = 1
Global Const $URL_SCHEME_HTTP = 2
Global Const $URL_SCHEME_GOPHER = 3
Global Const $URL_SCHEME_MAILTO = 4
Global Const $URL_SCHEME_NEWS = 5
Global Const $URL_SCHEME_NNTP = 6
Global Const $URL_SCHEME_TELNET = 7
Global Const $URL_SCHEME_WAIS = 8
Global Const $URL_SCHEME_FILE = 9
Global Const $URL_SCHEME_MK = 10
Global Const $URL_SCHEME_HTTPS = 11
Global Const $URL_SCHEME_SHELL = 12
Global Const $URL_SCHEME_SNEWS = 13
Global Const $URL_SCHEME_LOCAL = 14
Global Const $URL_SCHEME_JAVASCRIPT = 15
Global Const $URL_SCHEME_VBSCRIPT = 16
Global Const $URL_SCHEME_ABOUT = 17
Global Const $URL_SCHEME_RES = 18
Global Const $URL_SCHEME_MSSHELLROOTED = 19
Global Const $URL_SCHEME_MSSHELLIDLIST = 20
Global Const $URL_SCHEME_MSHELP = 21
Global Const $URL_SCHEME_MSSHELLDEVICE = 22
Global Const $URL_SCHEME_WILDCARD = 23
Global Const $URL_SCHEME_SEARCH_MS = 24
Global Const $URL_SCHEME_SEARCH = 25
Global Const $URL_SCHEME_KNOWNFOLDER = 26
Global Const $GCT_INVALID = 0x00
Global Const $GCT_LFNCHAR = 0x01
Global Const $GCT_SEPARATOR = 0x08
Global Const $GCT_SHORTCHAR = 0x02
Global Const $GCT_WILD = 0x04
Global Const $URL_APPLY_DEFAULT = 0x01
Global Const $URL_APPLY_GUESSSCHEME = 0x02
Global Const $URL_APPLY_GUESSFILE = 0x04
Global Const $URL_APPLY_FORCEAPPLY = 0x08
Global Const $URL_DONT_SIMPLIFY = 0x08000000
Global Const $URL_ESCAPE_AS_UTF8 = 0x00040000
Global Const $URL_ESCAPE_PERCENT = 0x00001000
Global Const $URL_ESCAPE_SPACES_ONLY = 0x04000000
Global Const $URL_ESCAPE_UNSAFE = 0x20000000
Global Const $URL_NO_META = 0x08000000
Global Const $URL_PLUGGABLE_PROTOCOL = 0x40000000
Global Const $URL_UNESCAPE = 0x10000000
Global Const $URL_PART_HOSTNAME = 2
Global Const $URL_PART_PASSWORD = 4
Global Const $URL_PART_PORT = 5
Global Const $URL_PART_QUERY = 6
Global Const $URL_PART_SCHEME = 1
Global Const $URL_PART_USERNAME = 3
Global Const $URLIS_APPLIABLE = 4
Global Const $URLIS_DIRECTORY = 5
Global Const $URLIS_FILEURL = 3
Global Const $URLIS_HASQUERY = 6
Global Const $URLIS_NOHISTORY = 2
Global Const $URLIS_OPAQUE = 1
Global Const $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_CommandLineToArgv($sCmd)
Local $aResult[1] = [0]
$sCmd = StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING)
If Not $sCmd Then
Return $aResult
EndIf
Local $aRet = DllCall('shell32.dll', 'ptr', 'CommandLineToArgvW', 'wstr', $sCmd, 'int*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[2]) Then Return SetError(@error + 10, @extended, 0)
Local $tPtr = DllStructCreate('ptr[' & $aRet[2] & ']', $aRet[0])
Dim $aResult[$aRet[2] + 1] = [$aRet[2]]
For $i = 1 To $aRet[2]
$aResult[$i] = _WinAPI_GetString(DllStructGetData($tPtr, 1, $i))
Next
DllCall("kernel32.dll", "handle", "LocalFree", "handle", $aRet[0])
Return $aResult
EndFunc
Func _WinAPI_IsNameInExpression($sString, $sPattern, $bCaseSensitive = False)
If Not $bCaseSensitive Then $sPattern = StringUpper($sPattern)
Local $tUS1 = __US($sPattern)
Local $tUS2 = __US($sString)
Local $aRet = DllCall('ntdll.dll', 'boolean', 'RtlIsNameInExpression', 'struct*', $tUS1, 'struct*', $tUS2,  'boolean', Not $bCaseSensitive, 'ptr', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ParseURL($sUrl)
Local $tagPARSEDURL = 'dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme'
Local $tPURL = DllStructCreate($tagPARSEDURL)
DllStructSetData($tPURL, 1, DllStructGetSize($tPURL))
Local $tURL = DllStructCreate('wchar[4096]')
DllStructSetData($tURL, 1, $sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'ParseURLW', 'struct*', $tURL, 'struct*', $tPURL)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $aResult[3]
$aResult[0] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 3) & ']', DllStructGetData($tPURL, 2)), 1)
$aResult[1] = DllStructGetData(DllStructCreate('wchar[' & DllStructGetData($tPURL, 5) & ']', DllStructGetData($tPURL, 4)), 1)
$aResult[2] = DllStructGetData($tPURL, 6)
Return $aResult
EndFunc
Func _WinAPI_ParseUserName($sUser)
If Not __DLL('credui.dll') Then Return SetError(103, 0, 0)
Local $aRet = DllCall('credui.dll', 'dword', 'CredUIParseUserNameW', 'wstr', $sUser, 'wstr', '', 'ulong', 4096, 'wstr', '',  'ulong', 4096)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0
Case 1315
If StringStripWS($sUser, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$aRet[2] = $sUser
$aRet[4] = ''
Else
ContinueCase
EndIf
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Local $aResult[2]
$aResult[0] = $aRet[4]
$aResult[1] = $aRet[2]
Return $aResult
EndFunc
Func _WinAPI_PathAddBackslash($sFilePath)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathAddBackslashW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathAddExtension($sFilePath, $sExt = '')
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $sTypeOfExt = 'wstr'
If Not StringStripWS($sExt, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfExt = 'ptr'
$sExt = 0
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAddExtensionW', 'struct*', $tPath, $sTypeOfExt, $sExt)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], DllStructGetData($tPath, 1))
EndFunc
Func _WinAPI_PathAppend($sFilePath, $sMore)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathAppendW', 'struct*', $tPath, 'wstr', $sMore)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathBuildRoot($iDrive)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathBuildRootW', 'wstr', '', 'int', $iDrive)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathCanonicalize($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCanonicalizeW', 'wstr', '', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCommonPrefix($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathCommonPrefixW', 'wstr', $sPath1, 'wstr', $sPath2, 'wstr', '')
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[3])
EndFunc
Func _WinAPI_PathCompactPath($hWnd, $sFilePath, $iWidth = 0)
If $iWidth < 1 Then
Local $tRECT = DllStructCreate($tagRECT)
DllCall("user32.dll", "bool", "GetClientRect", "hwnd", $hWnd, "struct*", $tRECT)
$iWidth += DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, $sFilePath)
Local $hDC = $aRet[0]
Local Const $WM_GETFONT = 0x0031
$aRet = DllCall('user32.dll', 'ptr', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_GETFONT, 'wparam', 0, 'lparam', 0)
Local $hBack = DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $aRet[0])
Local $iError = 0
$aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathW', 'handle', $hDC, 'wstr', $sFilePath, 'int', $iWidth)
If @error Or Not $aRet[0] Then $iError = @error + 10
DllCall("gdi32.dll", "handle", "SelectObject", "handle", $hDC, "handle", $hBack[0])
DllCall("user32.dll", "int", "ReleaseDC", "hwnd", $hWnd, "handle", $hDC)
If $iError Then Return SetError($iError, 0, $sFilePath)
Return $aRet[2]
EndFunc
Func _WinAPI_PathCompactPathEx($sFilePath, $iMax)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathCompactPathExW', 'wstr', '', 'wstr', $sFilePath, 'uint', $iMax + 1, 'dword', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aRet[1]
EndFunc
Func _WinAPI_PathCreateFromUrl($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'PathCreateFromUrlW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathFindExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindFileName($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'wstr', 'PathFindFileNameW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, $sFilePath)
Return $aRet[0]
EndFunc
Func _WinAPI_PathFindNextComponent($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathFindNextComponentW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathFindOnPath(Const $sFilePath, $aExtraPaths = "", Const $sPathDelimiter = @LF)
Local $iExtraCount = 0
If IsString($aExtraPaths) Then
If StringLen($aExtraPaths) Then
$aExtraPaths = StringSplit($aExtraPaths, $sPathDelimiter, $STR_ENTIRESPLIT + $STR_NOCOUNT)
$iExtraCount = UBound($aExtraPaths, $UBOUND_ROWS)
EndIf
ElseIf IsArray($aExtraPaths) Then
$iExtraCount = UBound($aExtraPaths)
EndIf
Local $tPaths, $tPathPtrs
If $iExtraCount Then
Local $tagStruct = ""
For $path In $aExtraPaths
$tagStruct &= "wchar[" & StringLen($path) + 1 & "];"
Next
$tPaths = DllStructCreate($tagStruct)
$tPathPtrs = DllStructCreate("ptr[" & $iExtraCount + 1 & "]")
For $i = 1 To $iExtraCount
DllStructSetData($tPaths, $i, $aExtraPaths[$i - 1])
DllStructSetData($tPathPtrs, 1, DllStructGetPtr($tPaths, $i), $i)
Next
DllStructSetData($tPathPtrs, 1, Ptr(0), $iExtraCount + 1)
EndIf
Local $aResult = DllCall("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $sFilePath, "struct*", $tPathPtrs)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, $sFilePath)
Return $aResult[1]
EndFunc
Func _WinAPI_PathGetArgs($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathGetArgsW', 'struct*', $tPath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathGetCharType($sChar)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'PathGetCharTypeW', 'word', AscW($sChar))
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_PathGetDriveNumber($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathGetDriveNumberW', 'wstr', $sFilePath)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, '')
Return Chr($aRet[0] + 65) & ':'
EndFunc
Func _WinAPI_PathIsContentType($sFilePath, $sType)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsContentTypeW', 'wstr', $sFilePath, 'wstr', $sType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsExe($sFilePath)
Local $aRet = DllCall('shell32.dll', 'bool', 'PathIsExe', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsLFNFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsLFNFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRelative($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRelativeW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsRootW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSameRoot($sPath1, $sPath2)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSameRootW', 'wstr', $sPath1, 'wstr', $sPath2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsSystemFolderW', 'wstr', $sFilePath, 'dword', 0)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNC($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServer($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathIsUNCServerShare($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathIsUNCServerShareW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathMatchSpec($sFilePath, $sSpec)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'wstr', $sFilePath, 'wstr', $sSpec)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathParseIconLocation($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'int', 'PathParseIconLocationW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
$aResult[0] = $aRet[1]
$aResult[1] = $aRet[0]
Return $aResult
EndFunc
Func _WinAPI_PathRelativePathTo($sPathFrom, $bDirFrom, $sPathTo, $bDirTo)
If $bDirFrom Then
$bDirFrom = 0x10
EndIf
If $bDirTo Then
$bDirTo = 0x10
EndIf
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRelativePathToW', 'wstr', '', 'wstr', $sPathFrom, 'dword', $bDirFrom,  'wstr', $sPathTo, 'dword', $bDirTo)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveArgs($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveArgsW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveBackslash($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathRemoveBackslashW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveExtension($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathRemoveExtensionW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathRemoveFileSpec($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRemoveFileSpecW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return SetExtended($aRet[0], $aRet[1])
EndFunc
Func _WinAPI_PathRenameExtension($sFilePath, $sExt)
Local $tPath = DllStructCreate('wchar[260]')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathRenameExtensionW', 'struct*', $tPath, 'wstr', $sExt)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return DllStructGetData($tPath, 1)
EndFunc
Func _WinAPI_PathSearchAndQualify($sFilePath, $bExists = False)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathSearchAndQualifyW', 'wstr', $sFilePath, 'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
If $bExists And Not FileExists($aRet[2]) Then Return SetError(20, 0, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathSkipRoot($sFilePath)
Local $tPath = DllStructCreate('wchar[' & (StringLen($sFilePath) + 1) & ']')
DllStructSetData($tPath, 1, $sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'ptr', 'PathSkipRootW', 'struct*', $tPath)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return $sFilePath
Return _WinAPI_GetString($aRet[0])
EndFunc
Func _WinAPI_PathStripPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathStripPathW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathStripToRoot($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathStripToRootW', 'wstr', $sFilePath)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUndecorate($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUndecorateW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathUnExpandEnvStrings($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnExpandEnvStringsW', 'wstr', $sFilePath, 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_PathUnmakeSystemFolder($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathUnmakeSystemFolderW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathUnquoteSpaces($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'none', 'PathUnquoteSpacesW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_PathYetAnotherMakeUniqueName($sFilePath)
Local $aRet = DllCall('shell32.dll', 'int', 'PathYetAnotherMakeUniqueName', 'wstr', '', 'wstr', $sFilePath, 'ptr', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[1]
EndFunc
Func _WinAPI_ShellGetImageList($bSmall = False)
Local $pLarge, $pSmall, $tPtr = DllStructCreate('ptr')
If $bSmall Then
$pLarge = 0
$pSmall = DllStructGetPtr($tPtr)
Else
$pLarge = DllStructGetPtr($tPtr)
$pSmall = 0
EndIf
Local $aRet = DllCall('shell32.dll', 'int', 'Shell_GetImageLists', 'ptr', $pLarge, 'ptr', $pSmall)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tPtr, 1)
EndFunc
Func _WinAPI_UrlApplyScheme($sUrl, $iFlags = 1)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlApplySchemeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCanonicalize($sUrl, $iFlags)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCanonicalizeW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlCombine($sUrl, $sPart, $iFlags = 0)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCombineW', 'wstr', $sUrl, 'wstr', $sPart, 'wstr', '', 'dword*', 4096,  'dword', $iFlags)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[3]
EndFunc
Func _WinAPI_UrlCompare($sUrl1, $sUrl2, $bIgnoreSlash = False)
Local $aRet = DllCall('shlwapi.dll', 'int', 'UrlCompareW', 'wstr', $sUrl1, 'wstr', $sUrl2, 'bool', $bIgnoreSlash)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UrlCreateFromPath($sFilePath)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlCreateFromPathW', 'wstr', $sFilePath, 'wstr', '', 'dword*', 4096, 'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] < 0 Or $aRet[0] > 1 Then
Return SetError(10, $aRet[0], '')
EndIf
Return $aRet[2]
EndFunc
Func _WinAPI_UrlFixup($sUrl)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlFixupW', 'wstr', $sUrl, 'wstr', '', 'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlGetPart($sUrl, $iPart)
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlGetPartW', 'wstr', $sUrl, 'wstr', '', 'dword*', 4096, 'dword', $iPart,  'dword', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_UrlHash($sUrl, $iLength = 32)
If $iLength <= 0 Or $iLength > 256 Then Return SetError(256, 0, 0)
Local $tData = DllStructCreate('byte[' & $iLength & ']')
Local $aRet = DllCall('shlwapi.dll', 'long', 'UrlHashW', 'wstr', $sUrl, 'struct*', $tData, 'dword', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return DllStructGetData($tData, 1)
EndFunc
Func _WinAPI_UrlIs($sUrl, $iType = 0)
Local $aRet = DllCall('shlwapi.dll', 'bool', 'UrlIsW', 'wstr', $sUrl, 'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __US($sString, $iLength = 0)
If $iLength Then
$sString = StringLeft($sString, $iLength)
Else
$iLength = StringLen($sString)
EndIf
Local $tUS = DllStructCreate('ushort;ushort;ptr;wchar[' & ($iLength + 1) & ']')
DllStructSetData($tUS, 1, 2 * StringLen($sString))
DllStructSetData($tUS, 2, 2 * $iLength)
DllStructSetData($tUS, 3, DllStructGetPtr($tUS, 4))
DllStructSetData($tUS, 4, $sString)
Return $tUS
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $tagIO_COUNTERS = 'struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct'
Global Const $tagJOBOBJECT_ASSOCIATE_COMPLETION_PORT = 'ulong_ptr CompletionKey;ptr CompletionPort'
Global Const $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = 'struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct'
Global Const $tagJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $tagJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ';' & $tagIO_COUNTERS
Global Const $tagJOBOBJECT_BASIC_LIMIT_INFORMATION = 'struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct'
Global Const $tagJOBOBJECT_BASIC_PROCESS_ID_LIST = 'dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList'
Global Const $tagJOBOBJECT_BASIC_UI_RESTRICTIONS = 'dword UIRestrictionsClass'
Global Const $tagJOBOBJECT_END_OF_JOB_TIME_INFORMATION = 'dword EndOfJobTimeAction'
Global Const $tagJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $tagJOBOBJECT_BASIC_LIMIT_INFORMATION & ';' & $tagIO_COUNTERS & ';ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed'
Global Const $tagJOBOBJECT_GROUP_INFORMATION = ''
Global Const $tagJOBOBJECT_SECURITY_LIMIT_INFORMATION = 'dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids'
Global Const $tagMODULEINFO = 'ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint'
Global Const $tagPROCESSENTRY32 = 'dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AdjustTokenPrivileges($hToken, $aPrivileges, $iAttributes, ByRef $aAdjust)
$aAdjust = 0
If Not $aPrivileges And IsNumber($aPrivileges) Then Return 0
Local $tTP1 = 0, $tTP2, $iCount, $aRet, $bDisable = False
If $aPrivileges = -1 Then
$tTP2 = DllStructCreate('dword')
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', 1, 'ptr', 0,  'dword', 0, 'struct*', $tTP2, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Local $iLastError = _WinAPI_GetLastError()
Switch $iLastError
Case 122
$tTP2 = DllStructCreate('dword;dword[' & ($aRet[6] / 4 - 1) & ']')
If @error Then
ContinueCase
EndIf
Case Else
Return SetError(10, $iLastError, 0)
EndSwitch
$bDisable = True
Else
Local $aPrev = 0
If Not IsArray($aPrivileges) Then
Dim $aPrev[1][2]
$aPrev[0][0] = $aPrivileges
$aPrev[0][1] = $iAttributes
Else
If Not UBound($aPrivileges, $UBOUND_COLUMNS) Then
$iCount = UBound($aPrivileges)
Dim $aPrev[$iCount][2]
For $i = 0 To $iCount - 1
$aPrev[$i][0] = $aPrivileges[$i]
$aPrev[$i][1] = $iAttributes
Next
EndIf
EndIf
If IsArray($aPrev) Then
$aPrivileges = $aPrev
EndIf
Local $tagStruct = 'dword;dword[' & (3 * UBound($aPrivileges)) & ']'
$tTP1 = DllStructCreate($tagStruct)
$tTP2 = DllStructCreate($tagStruct)
If @error Then Return SetError(@error + 20, 0, 0)
DllStructSetData($tTP1, 1, UBound($aPrivileges))
For $i = 0 To UBound($aPrivileges) - 1
DllStructSetData($tTP1, 2, $aPrivileges[$i][1], 3 * $i + 3)
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeValueW', 'ptr', 0, 'wstr', $aPrivileges[$i][0],  'ptr', DllStructGetPtr($tTP1, 2) + 12 * $i)
If @error Or Not $aRet[0] Then Return SetError(@error + 100, @extended, 0)
Next
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'AdjustTokenPrivileges', 'handle', $hToken, 'bool', $bDisable,  'struct*', $tTP1, 'dword', DllStructGetSize($tTP2), 'struct*', $tTP2, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 200, @extended, 0)
Local $iResult
Switch _WinAPI_GetLastError()
Case 1300
$iResult = 1
Case Else
$iResult = 0
EndSwitch
$iCount = DllStructGetData($tTP2, 1)
If $iCount Then
Local $tData = DllStructCreate('wchar[128]')
Dim $aPrivileges[$iCount][2]
For $i = 0 To $iCount - 1
$aRet = DllCall('advapi32.dll', 'bool', 'LookupPrivilegeNameW', 'ptr', 0,  'ptr', DllStructGetPtr($tTP2, 2) + 12 * $i, 'struct*', $tData, 'dword*', 128)
If @error Or Not $aRet[0] Then Return SetError(@error + 300, @extended, 0)
$aPrivileges[$i][1] = DllStructGetData($tTP2, 2, 3 * $i + 3)
$aPrivileges[$i][0] = DllStructGetData($tData, 1)
Next
$aAdjust = $aPrivileges
EndIf
Return SetExtended($iResult, 1)
EndFunc
Func _WinAPI_AssignProcessToJobObject($hJob, $hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'AssignProcessToJobObject', 'handle', $hJob, 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AttachConsole($iPID = -1)
Local $aResult = DllCall("kernel32.dll", "bool", "AttachConsole", "dword", $iPID)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_AttachThreadInput($iAttach, $iAttachTo, $bAttach)
Local $aResult = DllCall("user32.dll", "bool", "AttachThreadInput", "dword", $iAttach, "dword", $iAttachTo, "bool", $bAttach)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateEvent($tAttributes = 0, $bManualReset = True, $bInitialState = True, $sName = "")
Local $sNameType = "wstr"
If $sName = "" Then
$sName = 0
$sNameType = "ptr"
EndIf
Local $aResult = DllCall("kernel32.dll", "handle", "CreateEventW", "struct*", $tAttributes, "bool", $bManualReset,  "bool", $bInitialState, $sNameType, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateJobObject($sName = '', $tSecurity = 0)
Local $sTypeOfName = 'wstr'
If Not StringStripWS($sName, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfName = 'ptr'
$sName = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateJobObjectW', 'struct*', $tSecurity, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateMutex($sMutex, $bInitial = True, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateMutexW', 'struct*', $tSecurity, 'bool', $bInitial, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateProcess($sAppName, $sCommand, $tSecurity, $tThread, $bInherit, $iFlags, $pEnviron, $sDir, $tStartupInfo, $tProcess)
Local $tCommand = 0
Local $sAppNameType = "wstr", $sDirType = "wstr"
If $sAppName = "" Then
$sAppNameType = "ptr"
$sAppName = 0
EndIf
If $sCommand <> "" Then
$tCommand = DllStructCreate("wchar Text[" & 260 + 1 & "]")
DllStructSetData($tCommand, "Text", $sCommand)
EndIf
If $sDir = "" Then
$sDirType = "ptr"
$sDir = 0
EndIf
Local $aResult = DllCall("kernel32.dll", "bool", "CreateProcessW", $sAppNameType, $sAppName, "struct*", $tCommand,  "struct*", $tSecurity, "struct*", $tThread, "bool", $bInherit, "dword", $iFlags, "struct*", $pEnviron, $sDirType, $sDir,  "struct*", $tStartupInfo, "struct*", $tProcess)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_CreateProcessWithToken($sApp, $sCmd, $iFlags, $tStartupInfo, $tProcessInfo, $hToken, $iLogon = 0, $pEnvironment = 0, $sDir = '')
Local $sTypeOfApp = 'wstr', $sTypeOfCmd = 'wstr', $sTypeOfDir = 'wstr'
If Not StringStripWS($sApp, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfApp = 'ptr'
$sApp = 0
EndIf
If Not StringStripWS($sCmd, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfCmd = 'ptr'
$sCmd = 0
EndIf
If Not StringStripWS($sDir, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDir = 'ptr'
$sDir = 0
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'CreateProcessWithTokenW', 'handle', $hToken, 'dword', $iLogon,  $sTypeOfApp, $sApp, $sTypeOfCmd, $sCmd, 'dword', $iFlags, 'struct*', $pEnvironment,  $sTypeOfDir, $sDir, 'struct*', $tStartupInfo, 'struct*', $tProcessInfo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSemaphore($sSemaphore, $iInitial, $iMaximum, $tSecurity = 0)
Local $aRet = DllCall('kernel32.dll', 'handle', 'CreateSemaphoreW', 'struct*', $tSecurity, 'long', $iInitial,  'long', $iMaximum, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DuplicateTokenEx($hToken, $iAccess, $iLevel, $iType = 1, $tSecurity = 0)
Local $aRet = DllCall('advapi32.dll', 'bool', 'DuplicateTokenEx', 'handle', $hToken, 'dword', $iAccess,  'struct*', $tSecurity, 'int', $iLevel, 'int', $iType, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[6]
EndFunc
Func _WinAPI_EmptyWorkingSet($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000500 : 0x00001100),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EmptyWorkingSet', 'handle', $hProcess[0])
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_EnumChildProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or ($hSnapshot[0] = Ptr(-1)) Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $aResult[101][2] = [[0]]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ParentProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = DllStructGetData($tPROCESSENTRY32, 'ProcessID')
$aResult[$aResult[0][0]][1] = DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0][0] Then Return SetError($iError + 20, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumDeviceDrivers()
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'ptr', 0, 'dword', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $iSize
If @AutoItX64 Then
$iSize = $aRet[3] / 8
Else
$iSize = $aRet[3] / 4
EndIf
Local $tData = DllStructCreate('ptr[' & $iSize & ']')
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumDeviceDrivers', 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $aResult[$iSize + 1] = [$iSize]
For $i = 1 To $iSize
$aResult[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aResult
EndFunc
Func _WinAPI_EnumProcessHandles($iPID = 0, $iType = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aResult[101][4] = [[0]]
Local $tSHI = DllStructCreate('ulong;byte[4194304]')
Local $aRet = DllCall('ntdll.dll', 'long', 'ZwQuerySystemInformation', 'uint', 16, 'struct*', $tSHI,  'ulong', DllStructGetSize($tSHI), 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Local $pData = DllStructGetPtr($tSHI, 2)
Local $tHandle
For $i = 1 To DllStructGetData($tSHI, 1)
$tHandle = DllStructCreate('align 4;ulong;byte;byte;ushort;ptr;ulong', $pData + (@AutoItX64 ? (4 + ($i - 1) * 24) : (($i - 1) * 16)))
If (DllStructGetData($tHandle, 1) = $iPID) And ((Not $iType) Or ($iType = DllStructGetData($tHandle, 2))) Then
__Inc($aResult)
$aResult[$aResult[0][0]][0] = Ptr(DllStructGetData($tHandle, 4))
$aResult[$aResult[0][0]][1] = DllStructGetData($tHandle, 2)
$aResult[$aResult[0][0]][2] = DllStructGetData($tHandle, 3)
$aResult[$aResult[0][0]][3] = DllStructGetData($tHandle, 6)
EndIf
Next
If Not $aResult[0][0] Then Return SetError(11, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessModules($iPID = 0, $iFlag = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iCount, $aRet, $iError = 0
Do
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'ptr', 0,  'dword', 0, 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
If @AutoItX64 Then
$iCount = $aRet[4] / 8
Else
$iCount = $aRet[4] / 4
EndIf
Local $tPtr = DllStructCreate('ptr[' & $iCount & ']')
If @error Then
$iError = @error + 30
ExitLoop
EndIf
If $__WINVER >= 0x0600 Then
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModulesEx', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0, 'dword', $iFlag)
Else
$aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumProcessModules', 'handle', $hProcess[0], 'struct*', $tPtr,  'dword', DllStructGetSize($tPtr), 'dword*', 0)
EndIf
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Local $aResult[$iCount + 1][2] = [[$iCount]]
For $i = 1 To $iCount
$aResult[$i][0] = DllStructGetData($tPtr, 1, $i)
$aResult[$i][1] = _WinAPI_GetModuleFileNameEx($hProcess[0], $aResult[$i][0])
Next
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessThreads($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000004, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local Const $tagTHREADENTRY32 = 'dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags'
Local $tTHREADENTRY32 = DllStructCreate($tagTHREADENTRY32)
Local $aResult[101] = [0]
$hSnapshot = $hSnapshot[0]
DllStructSetData($tTHREADENTRY32, 'Size', DllStructGetSize($tTHREADENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Thread32First', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
While Not @error And $aRet[0]
If DllStructGetData($tTHREADENTRY32, 'OwnerProcessID') = $iPID Then
__Inc($aResult)
$aResult[$aResult[0]] = DllStructGetData($tTHREADENTRY32, 'ThreadID')
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Thread32Next', 'handle', $hSnapshot, 'struct*', $tTHREADENTRY32)
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $aResult[0] Then Return SetError(1, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_EnumProcessWindows($iPID = 0, $bVisible = True)
Local $aThreads = _WinAPI_EnumProcessThreads($iPID)
If @error Then Return SetError(@error, @extended, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
For $i = 1 To $aThreads[0]
DllCall('user32.dll', 'bool', 'EnumThreadWindows', 'dword', $aThreads[$i], 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Then
ExitLoop
EndIf
Next
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then Return SetError(11, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FatalAppExit($sMessage)
DllCall("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $sMessage)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_GetCurrentProcessExplicitAppUserModelID()
Local $aRet = DllCall('shell32.dll', 'long', 'GetCurrentProcessExplicitAppUserModelID', 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Local $sID = _WinAPI_GetString($aRet[1])
_WinAPI_CoTaskMemFree($aRet[1])
Return $sID
EndFunc
Func _WinAPI_GetCurrentProcessID()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentProcessId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThread()
Local $aResult = DllCall("kernel32.dll", "handle", "GetCurrentThread")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetCurrentThreadId()
Local $aResult = DllCall("kernel32.dll", "dword", "GetCurrentThreadId")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetDeviceDriverBaseName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverBaseNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetDeviceDriverFileName($pDriver)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetDeviceDriverFileNameW', 'ptr', $pDriver, 'wstr', '',  'dword', 4096)
If @error Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetExitCodeProcess($hProcess)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetExitCodeProcess', 'handle', $hProcess, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetGuiResources($iFlag = 0, $hProcess = -1)
If $hProcess = -1 Then $hProcess = _WinAPI_GetCurrentProcess()
Local $aResult = DllCall("user32.dll", "dword", "GetGuiResources", "handle", $hProcess, "dword", $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetModuleFileNameEx($hProcess, $hModule = 0)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'dword', 'GetModuleFileNameExW', 'handle', $hProcess, 'handle', $hModule,  'wstr', '', 'int', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetModuleInformation($hProcess, $hModule = 0)
Local $tMODULEINFO = DllStructCreate($tagMODULEINFO)
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetModuleInformation', 'handle', $hProcess, 'handle', $hModule,  'struct*', $tMODULEINFO, 'dword', DllStructGetSize($tMODULEINFO))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tMODULEINFO
EndFunc
Func _WinAPI_GetParentProcess($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 10, @extended, 0)
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
Local $iResult = 0
$hSnapshot = $hSnapshot[0]
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
$iResult = DllStructGetData($tPROCESSENTRY32, 'ParentProcessID')
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If Not $iResult Then Return SetError($iError, 0, 0)
Return $iResult
EndFunc
Func _WinAPI_GetPriorityClass($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetPriorityClass', 'handle', $hProcess[0])
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessAffinityMask($hProcess)
Local $aResult = DllCall("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $hProcess, "dword_ptr*", 0, "dword_ptr*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, 0)
Local $aMask[3]
$aMask[0] = True
$aMask[1] = $aResult[2]
$aMask[2] = $aResult[3]
Return $aMask
EndFunc
Func _WinAPI_GetProcessCommandLine($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tCMD
Local $aRet, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 50
ExitLoop
EndIf
$tCMD = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCommandLine') & ']')
If @error Then
$iError = @error + 60
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CommandLine'), 'struct*', $tCMD,  'ulong_ptr', DllStructGetSize($tCMD), 'ulong_ptr*', 0)
If @error Or Not $aRet[0] Or (Not $aRet[5]) Then
$iError = @error + 70
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return StringStripWS(_WinAPI_PathGetArgs(_WinAPI_GetString(DllStructGetPtr($tCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
EndFunc
Func _WinAPI_GetProcessFileName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
Local $sPath = _WinAPI_GetModuleFileNameEx($hProcess[0])
Local $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError(@error, 0, '')
Return $sPath
EndFunc
Func _WinAPI_GetProcessHandleCount($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessHandleCount', 'handle', $hProcess[0], 'dword*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetProcessID($hProcess)
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetProcessId', 'handle', $hProcess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetProcessIoCounters($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tIO_COUNTERS = DllStructCreate('uint64[6]')
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessIoCounters', 'handle', $hProcess[0], 'struct*', $tIO_COUNTERS)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[6]
For $i = 0 To 5
$aResult[$i] = DllStructGetData($tIO_COUNTERS, 1, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessMemoryInfo($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tPMC_EX = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetProcessMemoryInfo', 'handle', $hProcess[0], 'struct*', $tPMC_EX,  'int', DllStructGetSize($tPMC_EX))
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[10]
For $i = 0 To 9
$aResult[$i] = DllStructGetData($tPMC_EX, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcessName($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hSnapshot = DllCall('kernel32.dll', 'handle', 'CreateToolhelp32Snapshot', 'dword', 0x00000002, 'dword', 0)
If @error Or Not $hSnapshot[0] Then Return SetError(@error + 20, @extended, '')
$hSnapshot = $hSnapshot[0]
Local $tPROCESSENTRY32 = DllStructCreate($tagPROCESSENTRY32)
DllStructSetData($tPROCESSENTRY32, 'Size', DllStructGetSize($tPROCESSENTRY32))
Local $aRet = DllCall('kernel32.dll', 'bool', 'Process32FirstW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
Local $iError = @error
While (Not @error) And ($aRet[0])
If DllStructGetData($tPROCESSENTRY32, 'ProcessID') = $iPID Then
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'Process32NextW', 'handle', $hSnapshot, 'struct*', $tPROCESSENTRY32)
$iError = @error
WEnd
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hSnapshot)
If $iError Then Return SetError($iError, 0, '')
If Not $aRet[0] Then SetError(10, 0, '')
Return DllStructGetData($tPROCESSENTRY32, 'ExeFile')
EndFunc
Func _WinAPI_GetProcessTimes($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Local $tFILETIME = DllStructCreate($tagFILETIME)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessTimes', 'handle', $hProcess[0], 'struct*', $tFILETIME, 'uint64*', 0,  'uint64*', 0, 'uint64*', 0)
If __CheckErrorCloseHandle($aRet, $hProcess[0]) Then Return SetError(@error, @extended, 0)
Local $aResult[3]
$aResult[0] = $tFILETIME
$aResult[1] = $aRet[4]
$aResult[2] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessUser($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $tSID, $hToken, $aRet
Local $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000400 : 0x00001000),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, 0)
Do
$hToken = _WinAPI_OpenProcessToken(0x00000008, $hProcess[0])
If Not $hToken Then
$iError = @error + 10
ExitLoop
EndIf
$tSID = DllStructCreate('ptr;byte[1024]')
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 1, 'struct*', $tSID,  'dword', DllStructGetSize($tSID), 'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('advapi32.dll', 'bool', 'LookupAccountSidW', 'ptr', 0, 'ptr', DllStructGetData($tSID, 1), 'wstr', '',  'dword*', 2048, 'wstr', '', 'dword*', 2048, 'uint*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop
EndIf
Until 1
If $hToken Then
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Local $aResult[2]
$aResult[0] = $aRet[3]
$aResult[1] = $aRet[5]
Return $aResult
EndFunc
Func _WinAPI_GetProcessWorkingDirectory($iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $aRet, $iError = 0
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000410 : 0x00001010), 'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 20, @extended, '')
$hProcess = $hProcess[0]
Local $tPBI = DllStructCreate('ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId')
Local $tPEB = DllStructCreate('byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId')
Local $tUPP = DllStructCreate('ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5')
Local $tDIR
Do
$aRet = DllCall('ntdll.dll', 'long', 'NtQueryInformationProcess', 'handle', $hProcess, 'ulong', 0, 'struct*', $tPBI,  'ulong', DllStructGetSize($tPBI), 'ulong*', 0)
If @error Or ($aRet[0]) Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPBI, 'PebBaseAddress'), 'struct*', $tPEB,  'ulong_ptr', DllStructGetSize($tPEB), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 30
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tPEB, 'ProcessParameters'), 'struct*', $tUPP,  'ulong_ptr', DllStructGetSize($tUPP), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 40
ExitLoop
EndIf
$tDIR = DllStructCreate('byte[' & DllStructGetData($tUPP, 'MaxLengthCurrentDirectory') & ']')
If @error Then
$iError = @error + 50
ExitLoop
EndIf
$aRet = DllCall('kernel32.dll', 'bool', 'ReadProcessMemory', 'handle', $hProcess,  'ptr', DllStructGetData($tUPP, 'CurrentDirectory'), 'struct*', $tDIR,  'ulong_ptr', DllStructGetSize($tDIR), 'ulong_ptr*', 0)
If @error Or (Not $aRet[0]) Or (Not $aRet[5]) Then
$iError = @error + 60
ExitLoop
EndIf
$iError = 0
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess)
If $iError Then Return SetError($iError, 0, '')
Return _WinAPI_PathRemoveBackslash(_WinAPI_GetString(DllStructGetPtr($tDIR)))
EndFunc
Func _WinAPI_GetThreadDesktop($iThreadId)
Local $aRet = DllCall('user32.dll', 'handle', 'GetThreadDesktop', 'dword', $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetThreadErrorMode()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetThreadErrorMode')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowFileName($hWnd)
Local $iPID = 0
Local $aResult = DllCall("user32.dll", "bool", "IsWindow", "hwnd", $hWnd)
If $aResult[0] Then
$aResult = DllCall("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $hWnd, "dword*", 0)
$iPID = $aResult[2]
EndIf
If Not $iPID Then Return SetError(1, 0, '')
Local $sResult = _WinAPI_GetProcessFileName($iPID)
If @error Then Return SetError(@error, @extended, '')
Return $sResult
EndFunc
Func _WinAPI_IsElevated()
Local $iElev, $aRet, $iError = 0
Local $hToken = _WinAPI_OpenProcessToken(0x0008)
If Not $hToken Then Return SetError(@error + 10, @extended, False)
Do
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 20, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
$iElev = $aRet[3]
$aRet = DllCall('advapi32.dll', 'bool', 'GetTokenInformation', 'handle', $hToken, 'uint', 18, 'uint*', 0, 'dword', 4,  'dword*', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
Until 1
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
If $iError Then Return SetError($iError, 0, False)
Return SetExtended($aRet[0] - 1, $iElev)
EndFunc
Func _WinAPI_IsProcessInJob($hProcess, $hJob = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessInJob', 'handle', $hProcess, 'handle', $hJob, 'bool*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenJobObject($sName, $iAccess = $JOB_OBJECT_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenJobObjectW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenMutex($sMutex, $iAccess = $MUTEX_ALL_ACCESS, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenMutexW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenProcess($iAccess, $bInherit, $iPID, $bDebugPriv = False)
Local $aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] Then Return $aResult[0]
If Not $bDebugPriv Then Return SetError(100, 0, 0)
Local $hToken = _Security__OpenThreadTokenEx(BitOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
If @error Then Return SetError(@error + 10, @extended, 0)
_Security__SetPrivilege($hToken, "SeDebugPrivilege", True)
Local $iError = @error
Local $iExtended = @extended
Local $iRet = 0
If Not @error Then
$aResult = DllCall("kernel32.dll", "handle", "OpenProcess", "dword", $iAccess, "bool", $bInherit, "dword", $iPID)
$iError = @error
$iExtended = @extended
If $aResult[0] Then $iRet = $aResult[0]
_Security__SetPrivilege($hToken, "SeDebugPrivilege", False)
If @error Then
$iError = @error + 20
$iExtended = @extended
EndIf
Else
$iError = @error + 30
EndIf
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hToken)
Return SetError($iError, $iExtended, $iRet)
EndFunc
Func _WinAPI_OpenProcessToken($iAccess, $hProcess = 0)
If Not $hProcess Then
$hProcess = DllCall("kernel32.dll", "handle", "GetCurrentProcess")
$hProcess = $hProcess[0]
EndIf
Local $aRet = DllCall('advapi32.dll', 'bool', 'OpenProcessToken', 'handle', $hProcess, 'dword', $iAccess, 'handle*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_OpenSemaphore($sSemaphore, $iAccess = 0x001F0003, $bInherit = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'OpenSemaphoreW', 'dword', $iAccess, 'bool', $bInherit, 'wstr', $sSemaphore)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryInformationJobObject($hJob, $iJobObjectInfoClass, ByRef $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_ReleaseMutex($hMutex)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseMutex', 'handle', $hMutex)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseSemaphore($hSemaphore, $iIncrease = 1)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ReleaseSemaphore', 'handle', $hSemaphore, 'long', $iIncrease, 'long*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_ResetEvent($hEvent)
Local $aRet = DllCall('kernel32.dll', 'bool', 'ResetEvent', 'handle', $hEvent)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEvent($hEvent)
Local $aResult = DllCall("kernel32.dll", "bool", "SetEvent", "handle", $hEvent)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetInformationJobObject($hJob, $iJobObjectInfoClass, $tJobObjectInfo)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetInformationJobObject', 'handle', $hJob, 'int', $iJobObjectInfoClass,  'struct*', $tJobObjectInfo, 'dword', DllStructGetSize($tJobObjectInfo))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPriorityClass($iPriority, $iPID = 0)
If Not $iPID Then $iPID = @AutoItPID
Local $hProcess = DllCall('kernel32.dll', 'handle', 'OpenProcess', 'dword', (($__WINVER < 0x0600) ? 0x00000600 : 0x00001200),  'bool', 0, 'dword', $iPID)
If @error Or Not $hProcess[0] Then Return SetError(@error + 10, @extended, 0)
Local $iError = 0
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetPriorityClass', 'handle', $hProcess[0], 'dword', $iPriority)
If @error Then $iError = @error
DllCall("kernel32.dll", "bool", "CloseHandle", "handle", $hProcess[0])
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessAffinityMask($hProcess, $iMask)
Local $aResult = DllCall("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $hProcess, "ulong_ptr", $iMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetThreadDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SetThreadDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetThreadErrorMode($iMode)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetThreadErrorMode', 'dword', $iMode, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_SetThreadExecutionState($iFlags)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SetThreadExecutionState', 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateJobObject($hJob, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateJobObject', 'handle', $hJob, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TerminateProcess($hProcess, $iExitCode = 0)
Local $aRet = DllCall('kernel32.dll', 'bool', 'TerminateProcess', 'handle', $hProcess, 'uint', $iExitCode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UserHandleGrantAccess($hObject, $hJob, $bGrant)
Local $aRet = DllCall('kernel32.dll', 'bool', 'UserHandleGrantAccess', 'handle', $hObject, 'handle', $hJob, 'bool', $bGrant)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_WaitForInputIdle($hProcess, $iTimeout = -1)
Local $aResult = DllCall("user32.dll", "dword", "WaitForInputIdle", "handle", $hProcess, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForMultipleObjects($iCount, $paHandles, $bWaitAll = False, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $iCount, "struct*", $paHandles, "bool", $bWaitAll, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WaitForSingleObject($hHandle, $iTimeout = -1)
Local $aResult = DllCall("kernel32.dll", "INT", "WaitForSingleObject", "handle", $hHandle, "dword", $iTimeout)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_WriteConsole($hConsole, $sText)
Local $aResult = DllCall("kernel32.dll", "bool", "WriteConsoleW", "handle", $hConsole, "wstr", $sText,  "dword", StringLen($sText), "dword*", 0, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
Global $__BinaryCall_Kernel32dll = DllOpen('kernel32.dll')
Global $__BinaryCall_Msvcrtdll = DllOpen('msvcrt.dll')
Global $__BinaryCall_LastError = ""
Func _BinaryCall_GetProcAddress($Module, $Proc)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, 'ptr', 'GetProcAddress', 'ptr', $Module, 'str', $Proc)
If @Error Or Not $Ret[0] Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_LoadLibrary($Filename)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "handle", "LoadLibraryW", "wstr", $Filename)
If @Error Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_lstrlenA($Ptr)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "int", "lstrlenA", "ptr", $Ptr)
If @Error Then Return SetError(1, @Error, 0)
Return $Ret[0]
EndFunc
Func _BinaryCall_Alloc($Code, $Padding = 0)
Local $Length = BinaryLen($Code) + $Padding
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $Length, "dword", 0x1000, "dword", 0x40)
If @Error Or Not $Ret[0] Then Return SetError(1, @Error, 0)
If BinaryLen($Code) Then
Local $Buffer = DllStructCreate("byte[" & $Length & "]", $Ret[0])
DllStructSetData($Buffer, 1, $Code)
EndIf
Return $Ret[0]
EndFunc
Func _BinaryCall_RegionSize($Ptr)
Local $Buffer = DllStructCreate("ptr;ptr;dword;uint_ptr;dword;dword;dword")
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "int", "VirtualQuery", "ptr", $Ptr, "ptr", DllStructGetPtr($Buffer), "uint_ptr", DllStructGetSize($Buffer))
If @Error Or $Ret[0] = 0 Then Return SetError(1, @Error, 0)
Return DllStructGetData($Buffer, 4)
EndFunc
Func _BinaryCall_Free($Ptr)
Local $Ret = DllCall($__BinaryCall_Kernel32dll, "bool", "VirtualFree", "ptr", $Ptr, "ulong_ptr", 0, "dword", 0x8000)
If @Error Or $Ret[0] = 0 Then
$Ret = DllCall($__BinaryCall_Kernel32dll, "bool", "GlobalFree", "ptr", $Ptr)
If @Error Or $Ret[0] <> 0 Then Return SetError(1, @Error, False)
EndIf
Return True
EndFunc
Func _BinaryCall_Release($CodeBase)
Local $Ret = _BinaryCall_Free($CodeBase)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_MemorySearch($Ptr, $Length, $Binary)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('0x4883EC084D85C94889C8742C4C39CA72254C29CA488D141131C9EB0848FFC14C39C97414448A1408453A140874EE48FFC04839D076E231C05AC3', '', 0, True, False)
Else
$CodeBase = _BinaryCall_Create('0x5589E58B4D14578B4508568B550C538B7D1085C9742139CA721B29CA8D341031D2EB054239CA740F8A1C17381C1074F34039F076EA31C05B5E5F5DC3', '', 0, True, False)
EndIf
If Not $CodeBase Then Return SetError(1, 0, 0)
EndIf
$Binary = Binary($Binary)
Local $Buffer = DllStructCreate("byte[" & BinaryLen($Binary) & "]")
DllStructSetData($Buffer, 1, $Binary)
Local $Ret = DllCallAddress("ptr:cdecl", $CodeBase, "ptr", $Ptr, "uint", $Length, "ptr", DllStructGetPtr($Buffer), "uint", DllStructGetSize($Buffer))
Return $Ret[0]
EndFunc
Func _BinaryCall_Base64Decode($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('0x41544989CAB9FF000000555756E8BE000000534881EC000100004889E7F3A44C89D6E98A0000004439C87E0731C0E98D0000000FB66E01440FB626FFC00FB65E020FB62C2C460FB62424408A3C1C0FB65E034189EB41C1E4024183E3308A1C1C41C1FB044509E34080FF634189CC45881C08744C440FB6DFC1E5044489DF4088E883E73CC1FF0209C7418D44240241887C08014883C10380FB63742488D841C1E3064883C60483E03F4409D841884408FF89F389C84429D339D30F8C67FFFFFF4881C4000100005B5E5F5D415CC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233', '', 132, True, False)
Else
$CodeBase = _BinaryCall_Create('0x55B9FF00000089E531C05756E8F10000005381EC0C0100008B55088DBDF5FEFFFFF3A4E9C00000003B45140F8FC20000000FB65C0A028A9C1DF5FEFFFF889DF3FEFFFF0FB65C0A038A9C1DF5FEFFFF889DF2FEFFFF0FB65C0A018985E8FEFFFF0FB69C1DF5FEFFFF899DECFEFFFF0FB63C0A89DE83E630C1FE040FB6BC3DF5FEFFFFC1E70209FE8B7D1089F3881C074080BDF3FEFFFF63745C0FB6B5F3FEFFFF8BBDECFEFFFF8B9DE8FEFFFF89F083E03CC1E704C1F80209F88B7D1088441F0189D883C00280BDF2FEFFFF6374278A85F2FEFFFFC1E60683C10483E03F09F088441F0289D883C0033B4D0C0F8C37FFFFFFEB0231C081C40C0100005B5E5F5DC35EC3E8F9FFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000003E0000003F3435363738393A3B3C3D00000063000000000102030405060708090A0B0C0D0E0F101112131415161718190000000000001A1B1C1D1E1F202122232425262728292A2B2C2D2E2F30313233', '', 132, True, False)
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = String($Src)
Local $SrcLen = StringLen($Src)
Local $SrcBuf = DllStructCreate("char[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $DstLen = Int(($SrcLen + 2) / 4) * 3 + 1
Local $DstBuf = DllStructCreate("byte[" & $DstLen & "]")
Local $Ret = DllCallAddress("uint:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint", $SrcLen, "ptr", DllStructGetPtr($DstBuf), "uint", $DstLen)
If $Ret[0] = 0 Then Return SetError(2, 0, Binary(""))
Return BinaryMid(DllStructGetData($DstBuf, 1), 1, $Ret[0])
EndFunc
Func _BinaryCall_Base64Encode($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create('AwAAAARiAQAAAAAAAAArkuFQDAlvIp0qAgbDnjr76UDZs1EPNIP2K18t9s6SNTbd43IB7HfdyPM8VfD/o36z4AmSW2m2AIsC6Af3fKNsHU4BdQKGd0PQXHxPSX0iNqp1YAKovksqQna06NeKMoOYqryTUX4WgpHjokhp6zY2sEFSIjcL7dW3FDoNVz4bGPyZHRvjFwmqvr7YGlNYKwNoh+SYCXmIgVPVZ63Vz1fbT33/QFpWmWOeBRqs4J+c8Qp6zJFsK345Pjw0I8kMSsnho4F4oNzQ2OsAbmIioaQ6Ma2ziw5NH+M+t4SpEeHDnBdUTTL20sxWZ0yKruFAsBIRoHvM7LYcid2eBV2d5roSjnkwMG0g69LNjs1fHjbI/9iU/hJwpSsgl4fltXdZG659/li13UFY89M7UfckiZ9XOeBM0zadgNsy8r8M3rEAAA==')
Else
$CodeBase = _BinaryCall_Create('AwAAAARVAQAAAAAAAAAqr7blBndrIGnmhhfXD7R1fkOTKhicg1W6MCtStbz+CsneBEg0bbHH1sqTLmLfY7A6LqZl6LYWT5ULVj6MXgugPbBn9wKsSU2ZCcBBPNkx09HVPdUaKnbqghDGj/C5SHoF+A/5g+UgE1C5zJZORjJ8ljs5lt2Y9lA4BsY7jVKX2vmDvHK1NnSR6nVwh7Pb+Po/UpNcy5sObVWDKkYSCCtCIjKIYqOe3c6k8Xsp4eritCUprXEVvCFi7K5Z6HFXdm3nZsFcE+eSJ1WkRnVQbWcmpjGMGka61C68+CI7tsQ13UnCFWNSpDrCbzUejMZh8HdPgEc5vCg3pKMKin/NavNpB6+87Y9y7HIxmKsPdjDT30u9hUKWnYiRe3nrwKyVDsiYpKU/Nse368jHag5B5or3UKA+nb2+eY8JwzgA')
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = Binary($Src)
Local $SrcLen = BinaryLen($Src)
Local $SrcBuf = DllStructCreate("byte[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $DstLen = Int(($SrcLen + 2) / 3) * 4 + 1
Local $DstBuf = DllStructCreate("char[" & $DstLen & "]")
Local $Ret = DllCallAddress("uint:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint", $SrcLen, "ptr", DllStructGetPtr($DstBuf), "uint", $DstLen)
If $Ret[0] = 0 Then Return Binary("")
Return StringMid(DllStructGetData($DstBuf, 1), 1, $Ret[0])
EndFunc
Func _BinaryCall_LzmaDecompress($Src)
Static $CodeBase
If Not $CodeBase Then
If @AutoItX64 Then
$CodeBase = _BinaryCall_Create(_BinaryCall_Base64Decode('QVcxwEFWQVVBVFVXSInXVkiJzlMx20iB7OgAAABEiiFBgPzgdgnpyQAAAEGD7C1BiMf/wEGA/Cx38THA6wRBg+wJQYjG/8BBgPwId/GLRglEi24FQQ+2zkyJRCQoRQ+2/0HB5xBBiQFBD7bEAcG4AAMAANPgjYQAcA4AAEhjyOjIBAAATInpSInF6L0EAABIicMxwEyJ8kSI4EyLRCQoiNQl//8A/0QJ+EiF24lFAHQoTYXtdCNIjVfzSI1MJDhIg8YNTIkEJE2J6UmJ2EiJ7+g2AAAAicbrBb4BAAAASInp6IQEAACF9nQKSInZMdvodgQAAEiJ2EiBxOgAAABbXl9dQVxBXUFeQV/DVVNBV0FWQVVBVEFQTQHBQVFNicVRVkgB8lJIieX8SYn0iwdMjX8Eik8Cg8r/0+L30olV6Ijhg8r/0+L30olV5ADBiUXsuAEAAACJReCJRdyJRdhIiUXQRSnJKfaDy/8A0bgAAwAA0+BIjYg2BwAAuAAEAARMif/R6fOrvwUAAADoUAMAAP/PdfdEie9EicgrfSDB4ARBifpEI1XoRAHQTY0cR+hAAwAAD4WTAAAAik3sI33k0+eA6Qj22dPuAfe4AQAAAEiNPH++AAEAAMHnCEGD+QdNjbR/bA4AAHI0TInvSCt90A+2P9HnQYnzIf5BAfNPjRxe6O8CAACJwcHuCIPhATnOvgABAAB1DjnGd9jrDE2J8+jQAgAAOfBy9EyJ76pEiclBg/kEcg65AwAAAEGD+QpyA4PBA0EpyelDAgAAT42cT4ABAADomgIAAHUsi0XcQYP5B4lF4BnAi1XY99CLTdCD4AOJVdxBicGJTdhNjbdkBgAA6akAAABPjZxPmAEAAOhfAgAAdUZEicjB4AREAdBNjZxH4AEAAOhHAgAAdWpBg/kHuQkAAAByA4PBAkGJyUyJ70grfdBIO30gD4L9AQAAigdIA33QqumzAQAAT42cT7ABAADoCgIAAIt12HQhT42cT8gBAADo+AEAAIt13HQJi03ci3XgiU3gi03YiU3ci03QiU3YiXXQQYP5B7kIAAAAcgODwQNBiclNjbdoCgAATYnz6LsBAAB1FESJ0CnJweADvggAAABJjXxGBOs2TY1eAuicAQAAdRpEidC5CAAAAMHgA74IAAAASY28RgQBAADrEUmNvgQCAAC5EAAAAL4AAQAAiU3MuAEAAABJifvoYQEAAInCKfJy8gNVzEGD+QSJVcwPg7kAAABBg8EHuQMAAAA50XICidHB4Qa4AQAAAEmNvE9gAwAAvkAAAABJifvoHwEAAEGJwkEp8nLwQYP6BHJ4RInWRIlV0NHug2XQAf/Og03QAkGD+g5zFYnx0mXQi0XQRCnQTY20R14FAADrLIPuBOi6AAAA0evRZdBBOdhyBv9F0EEp2P/OdedNjbdEBgAAwWXQBL4EAAAAvwEAAACJ+E2J8+ioAAAAqAF0Awl90NHn/8516+sERIlV0P9F0EyJ74tNzEiJ+IPBAkgrRSBIOUXQd1RIif5IK3XQSItVGKyqSDnXcwT/yXX1SYn9D7bwTDttGA+C9fz//+gwAAAAKcBIi1UQTCtlCESJIkiLVWBMK20gRIkqSIPEKEFcQV1BXUFfW13DXli4AQAAAOvSgfsAAAABcgHDweMITDtlAHPmQcHgCEWKBCRJg8QBwynATY0cQ4H7AAAAAXMVweMITDtlAHPBQcHgCEWKBCRJg8QBidlBD7cTwekLD6/KQTnIcxOJy7kACAAAKdHB6QVmQQELAcDDKcvB6gVBKchmQSkTAcCDwAHDSLj////////////gbXN2Y3J0LmRsbHxtYWxsb2MASLj////////////gZnJlZQA='))
Else
$CodeBase = _BinaryCall_Create(_BinaryCall_Base64Decode('VYnlVzH/VlOD7EyLXQiKC4D54A+HxQAAADHA6wWD6S2I0ID5LI1QAXfziEXmMcDrBYPpCYjQgPkIjVABd/OIReWLRRSITeSLUwkPtsmLcwWJEA+2ReUBwbgAAwAA0+CNhABwDgAAiQQk6EcEAACJNCSJRdToPAQAAItV1InHi0Xkhf+JArgBAAAAdDaF9nQyi0UQg8MNiRQkiXQkFIl8JBCJRCQYjUXgiUQkDItFDIlcJASD6A2JRCQI6CkAAACLVdSJRdSJFCToAQQAAItF1IXAdAqJPCQx/+jwAwAAg8RMifhbXl9dw1dWU1WJ5YtFJAFFKFD8i3UYAXUcVot1FK2SUopO/oPI/9Pg99BQiPGDyP/T4PfQUADRifeD7AwpwEBQUFBQUFcp9laDy/+4AAMAANPgjYg2BwAAuAAEAATR6fOragVZ6MoCAADi+Yt9/ItF8Ct9JCH4iUXosADoywIAAA+FhQAAAIpN9CN97NPngOkI9tnT7lgB916NPH/B5wg8B1qNjH5sDgAAUVa+AAEAAFCwAXI0i338K33cD7Y/i23M0eeJ8SH+AfGNbE0A6JgCAACJwcHuCIPhATnOvgABAAB1DjnwctfrDIttzOh5AgAAOfBy9FqD+gSJ0XIJg/oKsQNyArEGKcpS60mwwOhJAgAAdRRYX1pZWln/NCRRUrpkBgAAsQDrb7DM6CwCAAB1LLDw6BMCAAB1U1g8B7AJcgKwC1CLdfwrddw7dSQPgs8BAACsi338qumOAQAAsNjo9wEAAIt12HQbsOTo6wEAAIt11HQJi3XQi03UiU3Qi03YiU3Ui03ciU3YiXXcWF9ZumgKAACxCAH6Ulc8B4jIcgIEA1CLbczovAEAAHUUi0Xoi33MweADKclqCF6NfEcE6zWLbcyDxQLomwEAAHUYi0Xoi33MweADaghZaghejbxHBAEAAOsQvwQCAAADfcxqEFm+AAEAAIlN5CnAQIn96GYBAACJwSnxcvMBTeSDfcQED4OwAAAAg0XEB4tN5IP5BHIDagNZi33IweEGKcBAakBejbxPYAMAAIn96CoBAACJwSnxcvOJTeiJTdyD+QRyc4nOg2XcAdHug03cAk6D+Q5zGbivAgAAKciJ8dJl3ANF3NHgA0XIiUXM6y2D7gToowAAANHr0WXcOV3gcgb/RdwpXeBOdei4RAYAAANFyIlFzMFl3ARqBF4p/0eJ+IttzOi0AAAAqAF0Awl93NHnTnXs6wD/RdyLTeSDwQKLffyJ+CtFJDlF3HdIif4rddyLVSisqjnXcwNJdfeJffwPtvA7fSgPgnH9///oKAAAACnAjWwkPItVIIt1+Ct1GIkyi1Usi338K30kiTrJW15fw15YKcBA69qB+wAAAAFyAcPB4whWi3X4O3Ucc+SLReDB4AisiUXgiXX4XsOLTcQPtsDB4QQDRegByOsGD7bAA0XEi23IjWxFACnAjWxFAIH7AAAAAXMci0wkOMFkJCAIO0wkXHOcihH/RCQ4weMIiFQkIInZD7dVAMHpCw+vyjlMJCBzF4nLuQAIAAAp0cHpBWYBTQABwI1sJEDDweoFKUwkICnLZilVAAHAg8ABjWwkQMO4///////gbXN2Y3J0LmRsbHxtYWxsb2MAuP//////4GZyZWUA'))
EndIf
If Not $CodeBase Then Return SetError(1, 0, Binary(""))
EndIf
$Src = Binary($Src)
Local $SrcLen = BinaryLen($Src)
Local $SrcBuf = DllStructCreate("byte[" & $SrcLen & "]")
DllStructSetData($SrcBuf, 1, $Src)
Local $Ret = DllCallAddress("ptr:cdecl", $CodeBase, "ptr", DllStructGetPtr($SrcBuf), "uint_ptr", $SrcLen, "uint_ptr*", 0, "uint*", 0)
If $Ret[0] Then
Local $DstBuf = DllStructCreate("byte[" & $Ret[3] & "]", $Ret[0])
Local $Output = DllStructGetData($DstBuf, 1)
DllCall($__BinaryCall_Msvcrtdll, "none:cdecl", "free", "ptr", $Ret[0])
Return $Output
EndIf
Return SetError(2, 0, Binary(""))
EndFunc
Func _BinaryCall_Relocation($Base, $Reloc)
Local $Size = Int(BinaryMid($Reloc, 1, 2))
For $i = 3 To BinaryLen($Reloc) Step $Size
Local $Offset = Int(BinaryMid($Reloc, $i, $Size))
Local $Ptr = $Base + $Offset
DllStructSetData(DllStructCreate("ptr", $Ptr), 1, DllStructGetData(DllStructCreate("ptr", $Ptr), 1) + $Base)
Next
EndFunc
Func _BinaryCall_ImportLibrary($Base, $Length)
Local $JmpBin, $JmpOff, $JmpLen, $DllName, $ProcName
If @AutoItX64 Then
$JmpBin = Binary("0x48B8FFFFFFFFFFFFFFFFFFE0")
$JmpOff = 2
Else
$JmpBin = Binary("0xB8FFFFFFFFFFE0")
$JmpOff = 1
EndIf
$JmpLen = BinaryLen($JmpBin)
Do
Local $Ptr = _BinaryCall_MemorySearch($Base, $Length, $JmpBin)
If $Ptr = 0 Then ExitLoop
Local $StringPtr = $Ptr + $JmpLen
Local $StringLen = _BinaryCall_lstrlenA($StringPtr)
Local $String = DllStructGetData(DllStructCreate("char[" & $StringLen & "]", $StringPtr), 1)
Local $Split = StringSplit($String, "|")
If $Split[0] = 1 Then
$ProcName = $Split[1]
ElseIf $Split[0] = 2 Then
If $Split[1] Then $DllName = $Split[1]
$ProcName = $Split[2]
EndIf
If $DllName And $ProcName Then
Local $Handle = _BinaryCall_LoadLibrary($DllName)
If Not $Handle Then
$__BinaryCall_LastError = "LoadLibrary fail on " & $DllName
Return SetError(1, 0, False)
EndIf
Local $Proc = _BinaryCall_GetProcAddress($Handle, $ProcName)
If Not $Proc Then
$__BinaryCall_LastError = "GetProcAddress failed on " & $ProcName
Return SetError(2, 0, False)
EndIf
DllStructSetData(DllStructCreate("ptr", $Ptr + $JmpOff), 1, $Proc)
EndIf
Local $Diff = Int($Ptr - $Base + $JmpLen + $StringLen + 1)
$Base += $Diff
$Length -= $Diff
Until $Length <= $JmpLen
Return True
EndFunc
Func _BinaryCall_CodePrepare($Code)
If Not $Code Then Return ""
If IsBinary($Code) Then Return $Code
$Code = String($Code)
If StringLeft($Code, 2) = "0x" Then Return Binary($Code)
If StringIsXDigit($Code) Then Return Binary("0x" & $Code)
Return _BinaryCall_LzmaDecompress(_BinaryCall_Base64Decode($Code))
EndFunc
Func _BinaryCall_SymbolFind($CodeBase, $Identify, $Length = Default)
$Identify = Binary($Identify)
If IsKeyword($Length) Then
$Length = _BinaryCall_RegionSize($CodeBase)
EndIf
Local $Ptr = _BinaryCall_MemorySearch($CodeBase, $Length, $Identify)
If $Ptr = 0 Then Return SetError(1, 0, 0)
Return $Ptr + BinaryLen($Identify)
EndFunc
Func _BinaryCall_SymbolList($CodeBase, $Symbol)
If Not IsArray($Symbol) Or $CodeBase = 0 Then Return SetError(1, 0, 0)
Local $Tag = ""
For $i = 0 To UBound($Symbol) - 1
$Tag &=  "ptr " & $Symbol[$i] & ";"
Next
Local $SymbolList = DllStructCreate($Tag)
If @Error Then Return SetError(1, 0, 0)
For $i = 0 To UBound($Symbol) - 1
$CodeBase = _BinaryCall_SymbolFind($CodeBase, $Symbol[$i])
DllStructSetData($SymbolList, $Symbol[$i], $CodeBase)
Next
Return $SymbolList
EndFunc
Func _BinaryCall_Create($Code, $Reloc = '', $Padding = 0, $ReleaseOnExit = True, $LibraryImport = True)
Local $BinaryCode = _BinaryCall_CodePrepare($Code)
If Not $BinaryCode Then Return SetError(1, 0, 0)
Local $BinaryCodeLen = BinaryLen($BinaryCode)
Local $TotalCodeLen = $BinaryCodeLen + $Padding
Local $CodeBase = _BinaryCall_Alloc($BinaryCode, $Padding)
If Not $CodeBase Then Return SetError(2, 0, 0)
If $Reloc Then
$Reloc = _BinaryCall_CodePrepare($Reloc)
If Not $Reloc Then Return SetError(3, 0, 0)
_BinaryCall_Relocation($CodeBase, $Reloc)
EndIf
If $LibraryImport Then
If Not _BinaryCall_ImportLibrary($CodeBase, $BinaryCodeLen) Then
_BinaryCall_Free($CodeBase)
Return SetError(4, 0, 0)
EndIf
EndIf
If $ReleaseOnExit Then
_BinaryCall_ReleaseOnExit($CodeBase)
EndIf
Return SetError(0, $TotalCodeLen, $CodeBase)
EndFunc
Func _BinaryCall_CommandLineToArgv($CommandLine, ByRef $Argc, $IsUnicode = False)
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code
If @AutoItX64 Then
$Code = 'AwAAAASuAgAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFNgf81Ag4vS2VP4y4wxFa+4yMI7GDB7CG+xn4JE3cdEVvk8cMp4oIuS3DgTxlcKHGVIg94tvzG/256bizZfGtAETQUCPQjW5+JSx2C/Y4C0VNJMKTlSCHiV5AzXRZ5gw3WFghbtkCCFxWOX+RDSI2oH/vROEOnqc0jfKTo17EBjqX+dW3QxrUe45xsbyYTZ9ccIGySgcOAxetbRiSxQnz8BOMbJyfrbZbuVJyGpKrXFLh/5MlBZ09Cim9qgflbGzmkrGStT9QL1f+O2krzyOzgaWWqhWL6S+y0G32RWVi0uMLR/JOGLEW/+Yg/4bzkeC0lKELT+RmWAatNa38BRfaitROMN12moRDHM6LYD1lzPLnaiefSQRVti561sxni/AFkYoCb5Lkuyw4RIn/r/flRiUg5w48YkqBBd9rXkaXrEoKwPg6rmOvOCZadu//B6HN4+Ipq5aYNuZMxSJXmxwXVRSQZVpSfLS2ATZMd9/Y7kLqrKy1H4V76SgI/d9OKApfKSbQ8ZaKIHBCsoluEip3UDOB82Z21zd933UH5l0laGWLIrTz7xVGkecjo0NQzR7LyhhoV3xszlIuw2v8q0Q/S9LxB5G6tYbOXo7lLjNIZc0derZz7DNeeeJ9dQE9hp8unubaTBpulPxTNtRjog=='
Else
$Code = 'AwAAAAR6AgAAAAAAAABcQfD553vjya/3DmalU0BKqABevUb/60GZ55rMwmzpQfPSRUlIl04lEiS8RDrXpS0EoBUe+uzDgZd37nVu9wsJ4fykqYvLoMz3ApxQbTBKleOIRSla6I0V8dNP3P7rHeUfjH0jCho0RvhhVpf0o4ht/iZptauxaoy1zQ19TkPZ/vf5Im8ecY6qEdHNzjo2H60jVwiOJ+1J47TmQRwxJ+yKLakq8QNxtKkRIB9B9ugfo3NAL0QslDxbyU0dSgw2aOPxV+uttLzYNnWbLBZVQbchcKgLRjC/32U3Op576sOYFolB1Nj4/33c7MRgtGLjlZfTB/4yNvd4/E+u3U6/Q4MYApCfWF4R/d9CAdiwgIjCYUkGDExKjFtHbAWXfWh9kQ7Q/GWUjsfF9BtHO6924Cy1Ou+BUKksqsxmIKP4dBjvvmz9OHc1FdtR9I63XKyYtlUnqVRtKwlNrYAZVCSFsyAefMbteq1ihU33sCsLkAnp1LRZ2wofgT1/JtT8+GO2s/n52D18wM70RH2n5uJJv8tlxQc1lwbmo4XQvcbcE91U2j9glvt2wC1pkP0hF23Nr/iiIEZHIPAOAHvhervlHE830LSHyUx8yh5Tjojr0gdLvQ=='
EndIf
Local $CodeBase = _BinaryCall_Create($Code)
If @Error Then Return SetError(1, 0, 0)
Local $Symbol[] = ["ToArgvW","ToArgvA"]
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @Error Then Return SetError(1, 0, 0)
EndIf
Local $Ret
If $IsUnicode Then
$Ret = DllCallAddress("ptr:cdecl", DllStructGetData($SymbolList, "ToArgvW"), "wstr", $CommandLine, "int*", 0)
Else
$Ret = DllCallAddress("ptr:cdecl", DllStructGetData($SymbolList, "ToArgvA"), "str", $CommandLine, "int*", 0)
EndIf
If Not @Error And $Ret[0] <> 0 Then
_BinaryCall_ReleaseOnExit($Ret[0])
$Argc = $Ret[2]
Return $Ret[0]
Else
Return SetError(2, 0, 0)
EndIf
EndFunc
Func _BinaryCall_StdioRedirect($Filename = "CON", $Flag = 1 + 2 + 4)
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code, $Reloc
If @AutoItX64 Then
$Code = 'AwAAAASjAQAAAAAAAAAkL48ClEB9jTEOeYv4yYTosNjFM1rLNdMULriZUDxTj+ZdkQ01F5zKL+WDCScfQKKLn66EDmcA+gXIkPcZV4lyz8VPw8BPZlNB5KymydM15kCA+uqvmBc1V0NJfzgsF0Amhn0JhM/ZIguYCHxywMQ1SgKxUb05dxDg8WlX/2aPfSolcX47+4/72lPDNTeT7d7XRdm0ND+eCauuQcRH2YOahare9ASxuU4IMHCh2rbZYHwmTNRiQUB/8dLGtph93yhmwdHtyMPLX2x5n6sdA1mxua9htLsLTulE05LLmXbRYXylDz0A'
$Reloc = 'AwAAAAQIAAAAAAAAAAABAB7T+CzGn9ScQAC='
Else
$Code = 'AwAAAASVAQAAAAAAAABcQfD553vjya/3DmalU0BKqABaUcndypZ3mTYUkHxlLV/lKZPrXYWXgNATjyiowkUQGDVYUy5THQwK4zYdU7xuGf7qfVDELc1SNbiW3NgD4D6N6ZM7auI1jPaThsPfA/ouBcx2aVQX36fjmViTZ8ZLzafjJeR7d5OG5s9sAoIzFLTZsqrFlkIJedqDAOfhA/0mMrkavTWnsio6yTbic1dER0DcEsXpLn0vBNErKHoagLzAgofHNLeFRw5yHWz5owR5CYL7rgiv2k51neHBWGx97A=='
$Reloc = 'AwAAAAQgAAAAAAAAAAABABfyHS/VRkdjBBzbtGPD6vtmVH/IsGHYvPsTv2lGuqJxGlAA'
EndIf
Local $CodeBase = _BinaryCall_Create($Code, $Reloc)
If @Error Then Return SetError(1, 0, 0)
Local $Symbol[] = ["StdinRedirect","StdoutRedirect","StderrRedirect"]
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @Error Then Return SetError(1, 0, 0)
EndIf
If BitAND($Flag, 1) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StdinRedirect"), "str", $Filename)
If BitAND($Flag, 2) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StdoutRedirect"), "str", $Filename)
If BitAND($Flag, 4) Then DllCallAddress("none:cdecl", DllStructGetData($SymbolList, "StderrRedirect"), "str", $Filename)
EndFunc
Func _BinaryCall_StdinRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 1)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_StdoutRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 2)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_StderrRedirect($Filename = "CON")
Local $Ret = _BinaryCall_StdioRedirect($Filename, 4)
Return SetError(@Error, @Extended, $Ret)
EndFunc
Func _BinaryCall_ReleaseOnExit($Ptr)
OnAutoItExitRegister('__BinaryCall_DoRelease')
__BinaryCall_ReleaseOnExit_Handle($Ptr)
EndFunc
Func __BinaryCall_DoRelease()
__BinaryCall_ReleaseOnExit_Handle()
EndFunc
Func __BinaryCall_ReleaseOnExit_Handle($Ptr = Default)
Static $PtrList
If @NumParams = 0 Then
If IsArray($PtrList) Then
For $i = 1 To $PtrList[0]
_BinaryCall_Free($PtrList[$i])
Next
EndIf
Else
If Not IsArray($PtrList) Then
Local $InitArray[1] = [0]
$PtrList = $InitArray
EndIf
If IsPtr($Ptr) Then
Local $Array = $PtrList
Local $Size = UBound($Array)
ReDim $Array[$Size + 1]
$Array[$Size] = $Ptr
$Array[0] += 1
$PtrList = $Array
EndIf
EndIf
EndFunc
Global Const $JSON_UNESCAPED_UNICODE = 1
Global Const $JSON_UNESCAPED_SLASHES = 2
Global Const $JSON_HEX_TAG = 4
Global Const $JSON_HEX_AMP = 8
Global Const $JSON_HEX_APOS = 16
Global Const $JSON_HEX_QUOT = 32
Global Const $JSON_UNESCAPED_ASCII = 64
Global Const $JSON_PRETTY_PRINT = 128
Global Const $JSON_STRICT_PRINT = 256
Global Const $JSON_UNQUOTED_STRING = 512
Global Const $JSMN_ERROR_NOMEM = -1
Global Const $JSMN_ERROR_INVAL = -2
Global Const $JSMN_ERROR_PART = -3
Global $Total_JSON_DUMP_Output = ""
Func __Jsmn_RuntimeLoader($ProcName = "")
Static $SymbolList
If Not IsDllStruct($SymbolList) Then
Local $Code
If @AutoItX64 Then
$Code = 'AwAAAAQfCAAAAAAAAAA1HbEvgTNrvX54gCiWSTVmt5v7RCdoFJ/zhkKmwcm8yVqZPjJBoVhNHHAIzrHWKbZh1J0QAUaHB5zyQTilTmWa9O0OKeLrk/Jg+o7CmMzjEk74uPongdHv37nwYXvg97fiHvjP2bBzI9gxSkKq9Cqh/GxSHIlZPYyW76pXUt//25Aqs2Icfpyay/NFd50rW7eMliH5ynkrp16HM1afithVrO+LpSaz/IojowApmXnBHUncHliDqbkx6/AODUkyDm1hj+AiEZ9Me1Jy+hBQ1/wC/YnuuYSJvNAKp6XDnyc8Nwr54Uqx5SbUW2CezwQQ7aXX/HFiHSKpQcFW/gi8oSx5nsoxUXVjxeNI/L7z6GF2mfu3Tnpt7hliWEdA2r2VB+TIM7Pgwl9X3Ge0T3KJQUaRtLJZcPvVtOuKXr2Q9wy7hl80hVRrt9zYrbjBHXLrRx/HeIMkZwxhmKo/dD/vvaNgE+BdU8eeJqFBJK2alrK2rh2WkRynftyepm1WrdKrz/5KhQPp/4PqH+9IADDjoGBbfvJQXdT+yiO8DtfrVnd+JOEKsKEsdgeM3UXx5r6tEHO9rYWbzbnyEiX7WozZemry+vBZMMtHn1aA63+RcDQED73xOsnj00/9E5Z6hszM5Hi8vi6Hw3iOgf3cHwcXG44aau0JpuA2DlrUvnJOYkNnY+bECeSdAR1UQkFNyqRoH2xm4Y7gYMCPsFtPBlwwleEKI27SsUq1ZHVQvFCoef7DXgf/GwPCAvwDMIQfb3hJtIVubOkASRQZVNIJ/y4KPrn/gcASV7fvMjE34loltTVlyqprUWxpI51tN6vhTOLAp+CHseKxWaf9g1wdbVs0e/5xAiqgJbmKNi9OYbhV/blpp3SL63XKxGiHdxhK1aR+4rUY4eckNbaHfW7ob+q7aBoHSs6LVX9lWakb/xWxwQdwcX/7/C+TcQSOOg6rLoWZ8wur9qp+QwzoCbXkf04OYpvD5kqgEiwQnB90kLtcA+2XSbDRu+aq02eNNCzgkZujeL/HjVISjf2EuQKSsZkBhS15eiXoRgPaUoQ5586VS7t7rhM8ng5LiVzoUQIZ0pNKxWWqD+gXRBvOMIXY2yd0Ei4sE5KFIEhbs3u8vwP7nFLIpZ/RembPTuc0ZlguGJgJ2F5iApfia+C2tRYRNjVCqECCveWw6P2Btfaq9gw7cWWmJflIQbjxtccDqsn52cftLqXSna9zk05mYdJSV8z2W7vM1YJ5Rd82v0j3kau710A/kQrN41bdaxmKjL+gvSRlOLB1bpvkCtf9+h+eVA4XIkIXKFydr1OjMZ8wq2FIxPJXskAe4YMgwQmeWZXMK1KBbLB3yQR1YOYaaHk1fNea9KsXgs5YLbiP/noAusz76oEDo/DJh1aw7cUwdhboVPg1bNq88mRb5RGa13KDK9uEET7OA02KbSL+Q4HOtyasLUoVrZzVyd8iZPoGrV36vHnj+yvG4fq6F/fkug/sBRp186yVZQVmdAgFd+WiRLnUjxHUKJ6xBbpt4FTP42E/PzPw3JlDb0UQtXTDnIL0CWqbns2E7rZ5PBwrwQYwvBn/gaEeLVGDSh84DfW4zknIneGnYDXdVEHC+ITzejAnNxb1duB+w2aVTk64iXsKHETq53GMH6DuFi0oUeEFb/xp0HsRyNC8vBjOq3Kk7NZHxCQLh7UATFttG7sH+VIqGjjNwmraGJ0C92XhpQwSgfAb3KHucCHGTTti0sn6cgS3vb36BkjGKsRhXVuoQCFH96bvTYtl8paQQW9ufRfvxPqmU0sALdR0fIvZwd7Z8z0UoEec6b1Sul4e60REj/H4scb6N2ryHBR9ua5N1YxJu1uwgoLXUL2wT9ZPBjPjySUzeqXikUIKKYgNlWy+VlNIiWWTPtKpCTr508logA=='
Else
$Code = 'AwAAAASFBwAAAAAAAAA1HbEvgTNrvX54gCiqsa1mt5v7RCdoAFjCfVE40DZbE5UfabA9UKuHrjqOMbvjSoB2zBJTEYEQejBREnPrXL3VwpVOW+L9SSfo0rTfA8U2W+Veqo1uy0dOsPhl7vAHbBHrvJNfEUe8TT0q2eaTX2LeWpyrFEm4I3mhDJY/E9cpWf0A78e+y4c7NxewvcVvAakIHE8Xb8fgtqCTVQj3Q1eso7n1fKQj5YsQ20A86Gy9fz8dky78raeZnhYayn0b1riSUKxGVnWja2i02OvAVM3tCCvXwcbSkHTRjuIAbMu2mXF1UpKci3i/GzPmbxo9n/3aX/jpR6UvxMZuaEDEij4yzfZv7EyK9WCNBXxMmtTp3Uv6MZsK+nopXO3C0xFzZA/zQObwP3zhJ4sdatzMhFi9GAM70R4kgMzsxQDNArueXj+UFzbCCFZ89zXs22F7Ixi0FyFTk3jhH56dBaN65S+gtPztNGzEUmtk4M8IanhQSw8xCXr0x0MPDpDFDZs3aN5TtTPYmyk3psk7OrmofCQGG5cRcqEt9902qtxQDOHumfuCPMvU+oMjzLzBVEDnBbj+tY3y1jvgGbmEJguAgfB04tSeAt/2618ksnJJK+dbBkDLxjB4xrFr3uIFFadJQWUckl5vfh4MVXbsFA1hG49lqWDa7uSuPCnOhv8Yql376I4U4gfcF8LcgorkxS+64urv2nMUq6AkBEMQ8bdkI64oKLFfO7fGxh5iMNZuLoutDn2ll3nq4rPi4kOyAtfhW0UPyjvqNtXJ/h0Wik5Mi8z7BVxaURTDk81TP8y9+tzjySB/uGfHFAzjF8DUY1vqJCgn0GQ8ANtiiElX/+Wnc9HWi2bEEXItbm4yv97QrEPvJG9nPRBKWGiAQsIA5J+WryX5NrfEfRPk0QQwyl16lpHlw6l0UMuk7S21xjQgyWo0MywfzoBWW7+t4HH9sqavvP4dYAw81BxXqVHQhefUOS23en4bFUPWE98pAN6bul+kS767vDK34yTC3lA2a8wLrBEilmFhdB74fxbAl+db91PivhwF/CR4Igxr35uLdof7+jAYyACopQzmsbHpvAAwT2lapLix8H03nztAC3fBqFSPBVdIv12lsrrDw4dfhJEzq7AbL/Y7L/nIcBsQ/3UyVnZk4kZP1KzyPCBLLIQNpCVgOLJzQuyaQ6k2QCBy0eJ0ppUyfp54LjwVg0X7bwncYbAomG4ZcFwTQnC2AX3oYG5n6Bz4SLLjxrFsY+v/SVa+GqH8uePBh1TPkHVNmzjXXymEf5jROlnd+EjfQdRyitkjPrg2HiQxxDcVhCh5J2L5+6CY9eIaYgrbd8zJnzAD8KnowHwh2bi4JLgmt7ktJ1XGizox7cWf3/Dod56KAcaIrSVw9XzYybdJCf0YRA6yrwPWXbwnzc/4+UDkmegi+AoCEMoue+cC7vnYVdmlbq/YLE/DWJX383oz2Ryq8anFrZ8jYvdoh8WI+dIugYL2SwRjmBoSwn56XIaot/QpMo3pYJIa4o8aZIZrjvB7BXO5aCDeMuZdUMT6AXGAGF1AeAWxFd2XIo1coR+OplMNDuYia8YAtnSTJ9JwGYWi2dJz3xrxsTQpBONf3yn8LVf8eH+o5eXc7lzCtHlDB+YyI8V9PyMsUPOeyvpB3rr9fDfNy263Zx33zTi5jldgP2OetUqGfbwl+0+zNYnrg64bluyIN/Awt1doDCQkCKpKXxuPaem/SyCHrKjg'
EndIf
Local $Symbol[] = ["jsmn_parse", "jsmn_init", "json_string_decode", "json_string_encode"]
Local $CodeBase = _BinaryCall_Create($Code)
If @error Then Exit MsgBox(16, "Json", "Startup Failure!")
$SymbolList = _BinaryCall_SymbolList($CodeBase, $Symbol)
If @error Then Exit MsgBox(16, "Json", "Startup Failure!")
EndIf
If $ProcName Then Return DllStructGetData($SymbolList, $ProcName)
EndFunc
Func Json_StringEncode($String, $Option = 0)
Static $Json_StringEncode = __Jsmn_RuntimeLoader("json_string_encode")
Local $Length = StringLen($String) * 6 + 1
Local $Buffer = DllStructCreate("wchar[" & $Length & "]")
Local $Ret = DllCallAddress("int:cdecl", $Json_StringEncode, "wstr", $String, "ptr", DllStructGetPtr($Buffer), "uint", $Length, "int", $Option)
Return SetError($Ret[0], 0, DllStructGetData($Buffer, 1))
EndFunc
Func Json_StringDecode($String)
Static $Json_StringDecode = __Jsmn_RuntimeLoader("json_string_decode")
Local $Length = StringLen($String) + 1
Local $Buffer = DllStructCreate("wchar[" & $Length & "]")
Local $Ret = DllCallAddress("int:cdecl", $Json_StringDecode, "wstr", $String, "ptr", DllStructGetPtr($Buffer), "uint", $Length)
Return SetError($Ret[0], 0, DllStructGetData($Buffer, 1))
EndFunc
Func Json_Decode($Json, $InitTokenCount = 1000)
Static $Jsmn_Init = __Jsmn_RuntimeLoader("jsmn_init"), $Jsmn_Parse = __Jsmn_RuntimeLoader("jsmn_parse")
If $Json = "" Then $Json = '""'
Local $TokenList, $Ret
Local $Parser = DllStructCreate("uint pos;int toknext;int toksuper")
Do
DllCallAddress("none:cdecl", $Jsmn_Init, "ptr", DllStructGetPtr($Parser))
$TokenList = DllStructCreate("byte[" & ($InitTokenCount * 20) & "]")
$Ret = DllCallAddress("int:cdecl", $Jsmn_Parse, "ptr", DllStructGetPtr($Parser), "wstr", $Json, "ptr", DllStructGetPtr($TokenList), "uint", $InitTokenCount)
$InitTokenCount *= 2
Until $Ret[0] <> $JSMN_ERROR_NOMEM
Local $Next = 0
Return SetError($Ret[0], 0, _Json_Token($Json, DllStructGetPtr($TokenList), $Next))
EndFunc
Func _Json_Token(ByRef $Json, $Ptr, ByRef $Next)
If $Next = -1 Then Return Null
Local $Token = DllStructCreate("int;int;int;int", $Ptr + ($Next * 20))
Local $Type = DllStructGetData($Token, 1)
Local $Start = DllStructGetData($Token, 2)
Local $End = DllStructGetData($Token, 3)
Local $Size = DllStructGetData($Token, 4)
$Next += 1
If $Type = 0 And $Start = 0 And $End = 0 And $Size = 0 Then
$Next = -1
Return Null
EndIf
Switch $Type
Case 0
Local $Primitive = StringMid($Json, $Start + 1, $End - $Start)
Switch $Primitive
Case "true"
Return True
Case "false"
Return False
Case "null"
Return Null
Case Else
If StringRegExp($Primitive, "^[+\-0-9]") Then
Return Number($Primitive)
Else
Return Json_StringDecode($Primitive)
EndIf
EndSwitch
Case 1
Local $Object = Json_ObjCreate()
For $i = 0 To $Size - 1 Step 2
Local $Key = _Json_Token($Json, $Ptr, $Next)
Local $Value = _Json_Token($Json, $Ptr, $Next)
If Not IsString($Key) Then $Key = Json_Encode($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
$Object.Add($Key, $Value)
Next
Return $Object
Case 2
Local $Array[$Size]
For $i = 0 To $Size - 1
$Array[$i] = _Json_Token($Json, $Ptr, $Next)
Next
Return $Array
Case 3
Return Json_StringDecode(StringMid($Json, $Start + 1, $End - $Start))
EndSwitch
EndFunc
Func Json_IsObject(ByRef $Object)
Return (IsObj($Object) And ObjName($Object) = "Dictionary")
EndFunc
Func Json_IsNull(ByRef $Null)
Return IsKeyword($Null) Or (Not IsObj($Null) And VarGetType($Null) = "Object")
EndFunc
Func Json_Encode_Compact($Data, $Option = 0)
Local $Json = ""
Select
Case IsString($Data)
Return '"' & Json_StringEncode($Data, $Option) & '"'
Case IsNumber($Data)
Return $Data
Case IsArray($Data) And UBound($Data, 0) = 1
$Json = "["
For $i = 0 To UBound($Data) - 1
$Json &= Json_Encode_Compact($Data[$i], $Option) & ","
Next
If StringRight($Json, 1) = "," Then $Json = StringTrimRight($Json, 1)
Return $Json & "]"
Case Json_IsObject($Data)
$Json = "{"
Local $Keys = $Data.Keys()
For $i = 0 To UBound($Keys) - 1
$Json &= '"' & Json_StringEncode($Keys[$i], $Option) & '":' & Json_Encode_Compact($Data.Item($Keys[$i]), $Option) & ","
Next
If StringRight($Json, 1) = "," Then $Json = StringTrimRight($Json, 1)
Return $Json & "}"
Case IsBool($Data)
Return StringLower($Data)
Case IsPtr($Data)
Return Number($Data)
Case IsBinary($Data)
Return '"' & Json_StringEncode(BinaryToString($Data, 4), $Option) & '"'
Case Else
Return "null"
EndSelect
EndFunc
Func Json_Encode_Pretty($Data, $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF = Default, $ObjectCRLF = Default, $NextIdent = "")
Local $ThisIdent = $NextIdent, $Json = "", $String = "", $Match = "", $Keys = ""
Local $Length = 0
Select
Case IsString($Data)
$String = Json_StringEncode($Data, $Option)
If BitAND($Option, $JSON_UNQUOTED_STRING) And Not BitAND($Option, $JSON_STRICT_PRINT) And Not StringRegExp($String, "[\s,:]") And Not StringRegExp($String, "^[+\-0-9]") Then
Return $String
Else
Return '"' & $String & '"'
EndIf
Case IsArray($Data) And UBound($Data, 0) = 1
If UBound($Data) = 0 Then Return "[]"
If IsKeyword($ArrayCRLF) Then
$ArrayCRLF = ""
$Match = StringRegExp($ArraySep, "[\r\n]+$", 3)
If IsArray($Match) Then $ArrayCRLF = $Match[0]
EndIf
If $ArrayCRLF Then $NextIdent &= $Indent
$Length = UBound($Data) - 1
For $i = 0 To $Length
If $ArrayCRLF Then $Json &= $NextIdent
$Json &= Json_Encode_Pretty($Data[$i], $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF, $ObjectCRLF, $NextIdent)
If $i < $Length Then $Json &= $ArraySep
Next
If $ArrayCRLF Then Return "[" & $ArrayCRLF & $Json & $ArrayCRLF & $ThisIdent & "]"
Return "[" & $Json & "]"
Case Json_IsObject($Data)
If $Data.Count = 0 Then Return "{}"
If IsKeyword($ObjectCRLF) Then
$ObjectCRLF = ""
$Match = StringRegExp($ObjectSep, "[\r\n]+$", 3)
If IsArray($Match) Then $ObjectCRLF = $Match[0]
EndIf
If $ObjectCRLF Then $NextIdent &= $Indent
$Keys = $Data.Keys()
$Length = UBound($Keys) - 1
For $i = 0 To $Length
If $ObjectCRLF Then $Json &= $NextIdent
$Json &= Json_Encode_Pretty(String($Keys[$i]), $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep) & $ColonSep  & Json_Encode_Pretty($Data.Item($Keys[$i]), $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep, $ArrayCRLF, $ObjectCRLF, $NextIdent)
If $i < $Length Then $Json &= $ObjectSep
Next
If $ObjectCRLF Then Return "{" & $ObjectCRLF & $Json & $ObjectCRLF & $ThisIdent & "}"
Return "{" & $Json & "}"
Case Else
Return Json_Encode_Compact($Data, $Option)
EndSelect
EndFunc
Func Json_Encode($Data, $Option = 0, $Indent = Default, $ArraySep = Default, $ObjectSep = Default, $ColonSep = Default)
If BitAND($Option, $JSON_PRETTY_PRINT) Then
Local $Strict = BitAND($Option, $JSON_STRICT_PRINT)
If IsKeyword($Indent) Then
$Indent = @TAB
Else
$Indent = Json_StringDecode($Indent)
If StringRegExp($Indent, "[^\t ]") Then $Indent = @TAB
EndIf
If IsKeyword($ArraySep) Then
$ArraySep = "," & @CRLF
Else
$ArraySep = Json_StringDecode($ArraySep)
If $ArraySep = "" Or StringRegExp($ArraySep, "[^\s,]|,.*,") Or ($Strict And Not StringRegExp($ArraySep, ",")) Then $ArraySep = "," & @CRLF
EndIf
If IsKeyword($ObjectSep) Then
$ObjectSep = "," & @CRLF
Else
$ObjectSep = Json_StringDecode($ObjectSep)
If $ObjectSep = "" Or StringRegExp($ObjectSep, "[^\s,]|,.*,") Or ($Strict And Not StringRegExp($ObjectSep, ",")) Then $ObjectSep = "," & @CRLF
EndIf
If IsKeyword($ColonSep) Then
$ColonSep = ": "
Else
$ColonSep = Json_StringDecode($ColonSep)
If $ColonSep = "" Or StringRegExp($ColonSep, "[^\s,:]|[,:].*[,:]") Or ($Strict And (StringRegExp($ColonSep, ",") Or Not StringRegExp($ColonSep, ":"))) Then $ColonSep = ": "
EndIf
Return Json_Encode_Pretty($Data, $Option, $Indent, $ArraySep, $ObjectSep, $ColonSep)
ElseIf BitAND($Option, $JSON_UNQUOTED_STRING) Then
Return Json_Encode_Pretty($Data, $Option, "", ",", ",", ":")
Else
Return Json_Encode_Compact($Data, $Option)
EndIf
EndFunc
Func Json_ObjCreate()
Local $Object = ObjCreate('Scripting.Dictionary')
$Object.CompareMode = 0
Return $Object
EndFunc
Func Json_ObjPut(ByRef $Object, $Key, $Value)
$Key = String($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
$Object.Add($Key, $Value)
EndFunc
Func Json_ObjGet(ByRef $Object, $Key)
Local $DynObject = $Object
Local $Keys = StringSplit($Key, ".")
For $x = 1 To $Keys[0]
If $DynObject.Exists($Keys[$x]) Then
If $x = $Keys[0] Then
Return $DynObject.Item($Keys[$x])
Else
$DynObject = Json_ObjGet($DynObject, $Keys[$x])
EndIf
EndIf
Next
Return SetError(1, 0, '')
EndFunc
Func Json_ObjDelete(ByRef $Object, $Key)
$Key = String($Key)
If $Object.Exists($Key) Then $Object.Remove($Key)
EndFunc
Func Json_ObjExists(ByRef $Object, $Key)
Local $DynObject = $Object
Local $Keys = StringSplit($Key, ".")
For $x = 1 To $Keys[0]
If $DynObject.Exists($Keys[$x]) Then
If $x = $Keys[0] Then
Return True
Else
$DynObject = Json_ObjGet($DynObject, $Keys[$x])
EndIf
Else
Return False
EndIf
Next
Return False
EndFunc
Func Json_ObjGetCount(ByRef $Object)
Return $Object.Count
EndFunc
Func Json_ObjGetKeys(ByRef $Object)
Return $Object.Keys()
EndFunc
Func Json_ObjGetItems(ByRef $Object)
Return $Object.Items()
EndFunc
Func Json_ObjClear(ByRef $Object)
Return $Object.RemoveAll()
EndFunc
Func Json_Put(ByRef $Var, $Notation, $Data, $CheckExists = False)
Local $Ret = 0, $Item = "", $Error = 0
Local $Match = ""
$Match = StringRegExp($Notation, "(^\[([^\]]+)\])|(^\.([^\.\[]+))", 3)
If IsArray($Match) Then
Local $Index
If UBound($Match) = 4 Then
$Index = String(Json_Decode($Match[3]))
$Notation = StringTrimLeft($Notation, StringLen($Match[2]))
Else
$Index = Json_Decode($Match[1])
$Notation = StringTrimLeft($Notation, StringLen($Match[0]))
EndIf
If IsString($Index) Then
If $CheckExists And (Not Json_IsObject($Var) Or Not Json_ObjExists($Var, $Index)) Then
Return SetError(1, 0, False)
EndIf
If Not Json_IsObject($Var) Then $Var = Json_ObjCreate()
If $Notation Then
$Item = Json_ObjGet($Var, $Index)
$Ret = Json_Put($Item, $Notation, $Data, $CheckExists)
$Error = @error
If Not $Error Then Json_ObjPut($Var, $Index, $Item)
Return SetError($Error, 0, $Ret)
Else
Json_ObjPut($Var, $Index, $Data)
Return True
EndIf
ElseIf IsInt($Index) Then
If $Index < 0 Or ($CheckExists And (Not IsArray($Var) Or UBound($Var, 0) <> 1 Or $Index >= UBound($Var))) Then
Return SetError(1, 0, False)
EndIf
If Not IsArray($Var) Or UBound($Var, 0) <> 1 Then
Dim $Var[$Index + 1]
ElseIf $Index >= UBound($Var) Then
ReDim $Var[$Index + 1]
EndIf
If $Notation Then
$Ret = Json_Put($Var[$Index], $Notation, $Data, $CheckExists)
Return SetError(@error, 0, $Ret)
Else
$Var[$Index] = $Data
Return True
EndIf
EndIf
EndIf
Return SetError(2, 0, False)
EndFunc
Func Json_Get(ByRef $Var, $Notation)
Local $Match = StringRegExp($Notation, "(^\[([^\]]+)\])|(^\.([^\.\[]+))", 3)
If IsArray($Match) Then
Local $Index
If UBound($Match) = 4 Then
$Index = String(Json_Decode($Match[3]))
$Notation = StringTrimLeft($Notation, StringLen($Match[2]))
Else
$Index = Json_Decode($Match[1])
$Notation = StringTrimLeft($Notation, StringLen($Match[0]))
EndIf
Local $Item
If IsString($Index) And Json_IsObject($Var) And Json_ObjExists($Var, $Index) Then
$Item = Json_ObjGet($Var, $Index)
ElseIf IsInt($Index) And IsArray($Var) And UBound($Var, 0) = 1 And $Index >= 0 And $Index < UBound($Var) Then
$Item = $Var[$Index]
Else
Return SetError(1, 0, "")
EndIf
If Not $Notation Then Return $Item
Local $Ret = Json_Get($Item, $Notation)
Return SetError(@error, 0, $Ret)
EndIf
Return SetError(2, 0, "")
EndFunc
Func Json_Dump($Json, $InitTokenCount = 1000)
Static $Jsmn_Init = __Jsmn_RuntimeLoader("jsmn_init"), $Jsmn_Parse = __Jsmn_RuntimeLoader("jsmn_parse")
If $Json = "" Then $Json = '""'
Local $TokenList, $Ret
$Total_JSON_DUMP_Output = ""
Local $Parser = DllStructCreate("uint pos;int toknext;int toksuper")
Do
DllCallAddress("none:cdecl", $Jsmn_Init, "ptr", DllStructGetPtr($Parser))
$TokenList = DllStructCreate("byte[" & ($InitTokenCount * 20) & "]")
$Ret = DllCallAddress("int:cdecl", $Jsmn_Parse, "ptr", DllStructGetPtr($Parser), "wstr", $Json, "ptr", DllStructGetPtr($TokenList), "uint", $InitTokenCount)
$InitTokenCount *= 2
Until $Ret[0] <> $JSMN_ERROR_NOMEM
Local $Next = 0
_Json_TokenDump($Json, DllStructGetPtr($TokenList), $Next)
EndFunc
Func _Json_TokenDump(ByRef $Json, $Ptr, ByRef $Next, $ObjPath = "")
If $Next = -1 Then Return Null
Local $Token = DllStructCreate("int;int;int;int", $Ptr + ($Next * 20))
Local $Type = DllStructGetData($Token, 1)
Local $Start = DllStructGetData($Token, 2)
Local $End = DllStructGetData($Token, 3)
Local $Size = DllStructGetData($Token, 4)
Local $Value
$Next += 1
If $Type = 0 And $Start = 0 And $End = 0 And $Size = 0 Then
$Next = -1
Return Null
EndIf
Switch $Type
Case 0
Local $Primitive = StringMid($Json, $Start + 1, $End - $Start)
Switch $Primitive
Case "true"
Return "True"
Case "false"
Return "False"
Case "null"
Return "Null"
Case Else
If StringRegExp($Primitive, "^[+\-0-9]") Then
Return Number($Primitive)
Else
Return Json_StringDecode($Primitive)
EndIf
EndSwitch
Case 1
For $i = 0 To $Size - 1 Step 2
Local $Key = _Json_TokenDump($Json, $Ptr, $Next)
Local $cObjPath = $ObjPath & "." & $Key
$Value = _Json_TokenDump($Json, $Ptr, $Next, $ObjPath & "." & $Key)
If Not (IsBool($Value) And $Value = False) Then
If Not IsString($Key) Then
$Key = Json_Encode($Key)
EndIf
ConsoleWrite("+-> " & $cObjPath & '  =' & $Value & @CRLF)
$Total_JSON_DUMP_Output &= "+-> " & $cObjPath & '  =' & $Value & @CRLF
EndIf
Next
Return False
Case 2
Local $sObjPath = $ObjPath
For $i = 0 To $Size - 1
$sObjPath = $ObjPath & "[" & $i & "]"
$Value = _Json_TokenDump($Json, $Ptr, $Next, $sObjPath)
If Not (IsBool($Value) And $Value = False) Then
ConsoleWrite("+=> " & $sObjPath & "=>" & $Value & @CRLF)
$Total_JSON_DUMP_Output &= "+=> " & $sObjPath & "=>" & $Value & @CRLF
EndIf
Next
$ObjPath = $sObjPath
Return False
Case 3
Local $LastKey = Json_StringDecode(StringMid($Json, $Start + 1, $End - $Start))
Return $LastKey
EndSwitch
EndFunc
Global Const $INTERNET_DEFAULT_PORT = 0
Global Const $INTERNET_DEFAULT_HTTP_PORT = 80
Global Const $INTERNET_DEFAULT_HTTPS_PORT = 443
Global Const $INTERNET_SCHEME_HTTP = 1
Global Const $INTERNET_SCHEME_HTTPS = 2
Global Const $INTERNET_SCHEME_FTP = 3
Global Const $ICU_ESCAPE = 0x80000000
Global Const $WINHTTP_FLAG_ASYNC = 0x10000000
Global Const $WINHTTP_FLAG_ESCAPE_PERCENT = 0x00000004
Global Const $WINHTTP_FLAG_NULL_CODEPAGE = 0x00000008
Global Const $WINHTTP_FLAG_ESCAPE_DISABLE = 0x00000040
Global Const $WINHTTP_FLAG_ESCAPE_DISABLE_QUERY = 0x00000080
Global Const $WINHTTP_FLAG_BYPASS_PROXY_CACHE = 0x00000100
Global Const $WINHTTP_FLAG_REFRESH = $WINHTTP_FLAG_BYPASS_PROXY_CACHE
Global Const $WINHTTP_FLAG_SECURE = 0x00800000
Global Const $WINHTTP_ACCESS_TYPE_DEFAULT_PROXY = 0
Global Const $WINHTTP_ACCESS_TYPE_NO_PROXY = 1
Global Const $WINHTTP_ACCESS_TYPE_NAMED_PROXY = 3
Global Const $WINHTTP_NO_PROXY_NAME = ""
Global Const $WINHTTP_NO_PROXY_BYPASS = ""
Global Const $WINHTTP_NO_REFERER = ""
Global Const $WINHTTP_DEFAULT_ACCEPT_TYPES = 0
Global Const $WINHTTP_NO_ADDITIONAL_HEADERS = ""
Global Const $WINHTTP_NO_REQUEST_DATA = ""
Global Const $WINHTTP_HEADER_NAME_BY_INDEX = ""
Global Const $WINHTTP_NO_OUTPUT_BUFFER = 0
Global Const $WINHTTP_NO_HEADER_INDEX = 0
Global Const $WINHTTP_ADDREQ_INDEX_MASK = 0x0000FFFF
Global Const $WINHTTP_ADDREQ_FLAGS_MASK = 0xFFFF0000
Global Const $WINHTTP_ADDREQ_FLAG_ADD_IF_NEW = 0x10000000
Global Const $WINHTTP_ADDREQ_FLAG_ADD = 0x20000000
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA = 0x40000000
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON = 0x01000000
Global Const $WINHTTP_ADDREQ_FLAG_COALESCE = $WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
Global Const $WINHTTP_ADDREQ_FLAG_REPLACE = 0x80000000
Global Const $WINHTTP_IGNORE_REQUEST_TOTAL_LENGTH = 0
Global Const $WINHTTP_OPTION_CALLBACK = 1
Global Const $WINHTTP_FIRST_OPTION = $WINHTTP_OPTION_CALLBACK
Global Const $WINHTTP_OPTION_RESOLVE_TIMEOUT = 2
Global Const $WINHTTP_OPTION_CONNECT_TIMEOUT = 3
Global Const $WINHTTP_OPTION_CONNECT_RETRIES = 4
Global Const $WINHTTP_OPTION_SEND_TIMEOUT = 5
Global Const $WINHTTP_OPTION_RECEIVE_TIMEOUT = 6
Global Const $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT = 7
Global Const $WINHTTP_OPTION_HANDLE_TYPE = 9
Global Const $WINHTTP_OPTION_READ_BUFFER_SIZE = 12
Global Const $WINHTTP_OPTION_WRITE_BUFFER_SIZE = 13
Global Const $WINHTTP_OPTION_PARENT_HANDLE = 21
Global Const $WINHTTP_OPTION_EXTENDED_ERROR = 24
Global Const $WINHTTP_OPTION_SECURITY_FLAGS = 31
Global Const $WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT = 32
Global Const $WINHTTP_OPTION_URL = 34
Global Const $WINHTTP_OPTION_SECURITY_KEY_BITNESS = 36
Global Const $WINHTTP_OPTION_PROXY = 38
Global Const $WINHTTP_OPTION_USER_AGENT = 41
Global Const $WINHTTP_OPTION_CONTEXT_VALUE = 45
Global Const $WINHTTP_OPTION_CLIENT_CERT_CONTEXT = 47
Global Const $WINHTTP_OPTION_REQUEST_PRIORITY = 58
Global Const $WINHTTP_OPTION_HTTP_VERSION = 59
Global Const $WINHTTP_OPTION_DISABLE_FEATURE = 63
Global Const $WINHTTP_OPTION_CODEPAGE = 68
Global Const $WINHTTP_OPTION_MAX_CONNS_PER_SERVER = 73
Global Const $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER = 74
Global Const $WINHTTP_OPTION_AUTOLOGON_POLICY = 77
Global Const $WINHTTP_OPTION_SERVER_CERT_CONTEXT = 78
Global Const $WINHTTP_OPTION_ENABLE_FEATURE = 79
Global Const $WINHTTP_OPTION_WORKER_THREAD_COUNT = 80
Global Const $WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT = 81
Global Const $WINHTTP_OPTION_PASSPORT_COBRANDING_URL = 82
Global Const $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH = 83
Global Const $WINHTTP_OPTION_SECURE_PROTOCOLS = 84
Global Const $WINHTTP_OPTION_ENABLETRACING = 85
Global Const $WINHTTP_OPTION_PASSPORT_SIGN_OUT = 86
Global Const $WINHTTP_OPTION_PASSPORT_RETURN_URL = 87
Global Const $WINHTTP_OPTION_REDIRECT_POLICY = 88
Global Const $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS = 89
Global Const $WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE = 90
Global Const $WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE = 91
Global Const $WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE = 92
Global Const $WINHTTP_OPTION_CONNECTION_INFO = 93
Global Const $WINHTTP_OPTION_CLIENT_CERT_ISSUER_LIST = 94
Global Const $WINHTTP_OPTION_SPN = 96
Global Const $WINHTTP_OPTION_GLOBAL_PROXY_CREDS = 97
Global Const $WINHTTP_OPTION_GLOBAL_SERVER_CREDS = 98
Global Const $WINHTTP_OPTION_UNLOAD_NOTIFY_EVENT = 99
Global Const $WINHTTP_OPTION_REJECT_USERPWD_IN_URL = 100
Global Const $WINHTTP_OPTION_USE_GLOBAL_SERVER_CREDENTIALS = 101
Global Const $WINHTTP_OPTION_RECEIVE_PROXY_CONNECT_RESPONSE = 103
Global Const $WINHTTP_OPTION_IS_PROXY_CONNECT_RESPONSE = 104
Global Const $WINHTTP_OPTION_SERVER_SPN_USED = 106
Global Const $WINHTTP_OPTION_PROXY_SPN_USED = 107
Global Const $WINHTTP_OPTION_SERVER_CBT = 108
Global Const $WINHTTP_OPTION_UNSAFE_HEADER_PARSING = 110
Global Const $WINHTTP_OPTION_DECOMPRESSION = 118
Global Const $WINHTTP_LAST_OPTION = $WINHTTP_OPTION_DECOMPRESSION
Global Const $WINHTTP_OPTION_USERNAME = 0x1000
Global Const $WINHTTP_OPTION_PASSWORD = 0x1001
Global Const $WINHTTP_OPTION_PROXY_USERNAME = 0x1002
Global Const $WINHTTP_OPTION_PROXY_PASSWORD = 0x1003
Global Const $WINHTTP_CONNS_PER_SERVER_UNLIMITED = 0xFFFFFFFF
Global Const $WINHTTP_DECOMPRESSION_FLAG_GZIP = 0x00000001
Global Const $WINHTTP_DECOMPRESSION_FLAG_DEFLATE = 0x00000002
Global Const $WINHTTP_DECOMPRESSION_FLAG_ALL = 0x00000003
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM = 0
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW = 1
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH = 2
Global Const $WINHTTP_AUTOLOGON_SECURITY_LEVEL_DEFAULT = $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_NEVER = 0
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP = 1
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS = 2
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_LAST = $WINHTTP_OPTION_REDIRECT_POLICY_ALWAYS
Global Const $WINHTTP_OPTION_REDIRECT_POLICY_DEFAULT = $WINHTTP_OPTION_REDIRECT_POLICY_DISALLOW_HTTPS_TO_HTTP
Global Const $WINHTTP_DISABLE_PASSPORT_AUTH = 0x00000000
Global Const $WINHTTP_ENABLE_PASSPORT_AUTH = 0x10000000
Global Const $WINHTTP_DISABLE_PASSPORT_KEYRING = 0x20000000
Global Const $WINHTTP_ENABLE_PASSPORT_KEYRING = 0x40000000
Global Const $WINHTTP_DISABLE_COOKIES = 0x00000001
Global Const $WINHTTP_DISABLE_REDIRECTS = 0x00000002
Global Const $WINHTTP_DISABLE_AUTHENTICATION = 0x00000004
Global Const $WINHTTP_DISABLE_KEEP_ALIVE = 0x00000008
Global Const $WINHTTP_ENABLE_SSL_REVOCATION = 0x00000001
Global Const $WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION = 0x00000002
Global Const $WINHTTP_DISABLE_SPN_SERVER_PORT = 0x00000000
Global Const $WINHTTP_ENABLE_SPN_SERVER_PORT = 0x00000001
Global Const $WINHTTP_OPTION_SPN_MASK = $WINHTTP_ENABLE_SPN_SERVER_PORT
Global Const $WINHTTP_ERROR_BASE = 12000
Global Const $ERROR_WINHTTP_OUT_OF_HANDLES = 12001
Global Const $ERROR_WINHTTP_TIMEOUT = 12002
Global Const $ERROR_WINHTTP_INTERNAL_ERROR = 12004
Global Const $ERROR_WINHTTP_INVALID_URL = 12005
Global Const $ERROR_WINHTTP_UNRECOGNIZED_SCHEME = 12006
Global Const $ERROR_WINHTTP_NAME_NOT_RESOLVED = 12007
Global Const $ERROR_WINHTTP_INVALID_OPTION = 12009
Global Const $ERROR_WINHTTP_OPTION_NOT_SETTABLE = 12011
Global Const $ERROR_WINHTTP_SHUTDOWN = 12012
Global Const $ERROR_WINHTTP_LOGIN_FAILURE = 12015
Global Const $ERROR_WINHTTP_OPERATION_CANCELLED = 12017
Global Const $ERROR_WINHTTP_INCORRECT_HANDLE_TYPE = 12018
Global Const $ERROR_WINHTTP_INCORRECT_HANDLE_STATE = 12019
Global Const $ERROR_WINHTTP_CANNOT_CONNECT = 12029
Global Const $ERROR_WINHTTP_CONNECTION_ERROR = 12030
Global Const $ERROR_WINHTTP_RESEND_REQUEST = 12032
Global Const $ERROR_WINHTTP_SECURE_CERT_DATE_INVALID = 12037
Global Const $ERROR_WINHTTP_SECURE_CERT_CN_INVALID = 12038
Global Const $ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED = 12044
Global Const $ERROR_WINHTTP_SECURE_INVALID_CA = 12045
Global Const $ERROR_WINHTTP_SECURE_CERT_REV_FAILED = 12057
Global Const $ERROR_WINHTTP_CANNOT_CALL_BEFORE_OPEN = 12100
Global Const $ERROR_WINHTTP_CANNOT_CALL_BEFORE_SEND = 12101
Global Const $ERROR_WINHTTP_CANNOT_CALL_AFTER_SEND = 12102
Global Const $ERROR_WINHTTP_CANNOT_CALL_AFTER_OPEN = 12103
Global Const $ERROR_WINHTTP_HEADER_NOT_FOUND = 12150
Global Const $ERROR_WINHTTP_INVALID_SERVER_RESPONSE = 12152
Global Const $ERROR_WINHTTP_INVALID_HEADER = 12153
Global Const $ERROR_WINHTTP_INVALID_QUERY_REQUEST = 12154
Global Const $ERROR_WINHTTP_HEADER_ALREADY_EXISTS = 12155
Global Const $ERROR_WINHTTP_REDIRECT_FAILED = 12156
Global Const $ERROR_WINHTTP_SECURE_CHANNEL_ERROR = 12157
Global Const $ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT = 12166
Global Const $ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT = 12167
Global Const $ERROR_WINHTTP_SECURE_INVALID_CERT = 12169
Global Const $ERROR_WINHTTP_SECURE_CERT_REVOKED = 12170
Global Const $ERROR_WINHTTP_NOT_INITIALIZED = 12172
Global Const $ERROR_WINHTTP_SECURE_FAILURE = 12175
Global Const $ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR = 12178
Global Const $ERROR_WINHTTP_SECURE_CERT_WRONG_USAGE = 12179
Global Const $ERROR_WINHTTP_AUTODETECTION_FAILED = 12180
Global Const $ERROR_WINHTTP_HEADER_COUNT_EXCEEDED = 12181
Global Const $ERROR_WINHTTP_HEADER_SIZE_OVERFLOW = 12182
Global Const $ERROR_WINHTTP_CHUNKED_ENCODING_HEADER_SIZE_OVERFLOW = 12183
Global Const $ERROR_WINHTTP_RESPONSE_DRAIN_OVERFLOW = 12184
Global Const $ERROR_WINHTTP_CLIENT_CERT_NO_PRIVATE_KEY = 12185
Global Const $ERROR_WINHTTP_CLIENT_CERT_NO_ACCESS_PRIVATE_KEY = 12186
Global Const $WINHTTP_ERROR_LAST = 12186
Global Const $HTTP_STATUS_CONTINUE = 100
Global Const $HTTP_STATUS_SWITCH_PROTOCOLS = 101
Global Const $HTTP_STATUS_OK = 200
Global Const $HTTP_STATUS_CREATED = 201
Global Const $HTTP_STATUS_ACCEPTED = 202
Global Const $HTTP_STATUS_PARTIAL = 203
Global Const $HTTP_STATUS_NO_CONTENT = 204
Global Const $HTTP_STATUS_RESET_CONTENT = 205
Global Const $HTTP_STATUS_PARTIAL_CONTENT = 206
Global Const $HTTP_STATUS_WEBDAV_MULTI_STATUS = 207
Global Const $HTTP_STATUS_AMBIGUOUS = 300
Global Const $HTTP_STATUS_MOVED = 301
Global Const $HTTP_STATUS_REDIRECT = 302
Global Const $HTTP_STATUS_REDIRECT_METHOD = 303
Global Const $HTTP_STATUS_NOT_MODIFIED = 304
Global Const $HTTP_STATUS_USE_PROXY = 305
Global Const $HTTP_STATUS_REDIRECT_KEEP_VERB = 307
Global Const $HTTP_STATUS_BAD_REQUEST = 400
Global Const $HTTP_STATUS_DENIED = 401
Global Const $HTTP_STATUS_PAYMENT_REQ = 402
Global Const $HTTP_STATUS_FORBIDDEN = 403
Global Const $HTTP_STATUS_NOT_FOUND = 404
Global Const $HTTP_STATUS_BAD_METHOD = 405
Global Const $HTTP_STATUS_NONE_ACCEPTABLE = 406
Global Const $HTTP_STATUS_PROXY_AUTH_REQ = 407
Global Const $HTTP_STATUS_REQUEST_TIMEOUT = 408
Global Const $HTTP_STATUS_CONFLICT = 409
Global Const $HTTP_STATUS_GONE = 410
Global Const $HTTP_STATUS_LENGTH_REQUIRED = 411
Global Const $HTTP_STATUS_PRECOND_FAILED = 412
Global Const $HTTP_STATUS_REQUEST_TOO_LARGE = 413
Global Const $HTTP_STATUS_URI_TOO_LONG = 414
Global Const $HTTP_STATUS_UNSUPPORTED_MEDIA = 415
Global Const $HTTP_STATUS_RETRY_WITH = 449
Global Const $HTTP_STATUS_SERVER_ERROR = 500
Global Const $HTTP_STATUS_NOT_SUPPORTED = 501
Global Const $HTTP_STATUS_BAD_GATEWAY = 502
Global Const $HTTP_STATUS_SERVICE_UNAVAIL = 503
Global Const $HTTP_STATUS_GATEWAY_TIMEOUT = 504
Global Const $HTTP_STATUS_VERSION_NOT_SUP = 505
Global Const $HTTP_STATUS_FIRST = $HTTP_STATUS_CONTINUE
Global Const $HTTP_STATUS_LAST = $HTTP_STATUS_VERSION_NOT_SUP
Global Const $SECURITY_FLAG_IGNORE_UNKNOWN_CA = 0x00000100
Global Const $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID = 0x00002000
Global Const $SECURITY_FLAG_IGNORE_CERT_CN_INVALID = 0x00001000
Global Const $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE = 0x00000200
Global Const $SECURITY_FLAG_SECURE = 0x00000001
Global Const $SECURITY_FLAG_STRENGTH_WEAK = 0x10000000
Global Const $SECURITY_FLAG_STRENGTH_MEDIUM = 0x40000000
Global Const $SECURITY_FLAG_STRENGTH_STRONG = 0x20000000
Global Const $ICU_NO_ENCODE = 0x20000000
Global Const $ICU_DECODE = 0x10000000
Global Const $ICU_NO_META = 0x08000000
Global Const $ICU_ENCODE_SPACES_ONLY = 0x04000000
Global Const $ICU_BROWSER_MODE = 0x02000000
Global Const $ICU_ENCODE_PERCENT = 0x00001000
Global Const $WINHTTP_QUERY_MIME_VERSION = 0
Global Const $WINHTTP_QUERY_CONTENT_TYPE = 1
Global Const $WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING = 2
Global Const $WINHTTP_QUERY_CONTENT_ID = 3
Global Const $WINHTTP_QUERY_CONTENT_DESCRIPTION = 4
Global Const $WINHTTP_QUERY_CONTENT_LENGTH = 5
Global Const $WINHTTP_QUERY_CONTENT_LANGUAGE = 6
Global Const $WINHTTP_QUERY_ALLOW = 7
Global Const $WINHTTP_QUERY_PUBLIC = 8
Global Const $WINHTTP_QUERY_DATE = 9
Global Const $WINHTTP_QUERY_EXPIRES = 10
Global Const $WINHTTP_QUERY_LAST_MODIFIED = 11
Global Const $WINHTTP_QUERY_MESSAGE_ID = 12
Global Const $WINHTTP_QUERY_URI = 13
Global Const $WINHTTP_QUERY_DERIVED_FROM = 14
Global Const $WINHTTP_QUERY_COST = 15
Global Const $WINHTTP_QUERY_LINK = 16
Global Const $WINHTTP_QUERY_PRAGMA = 17
Global Const $WINHTTP_QUERY_VERSION = 18
Global Const $WINHTTP_QUERY_STATUS_CODE = 19
Global Const $WINHTTP_QUERY_STATUS_TEXT = 20
Global Const $WINHTTP_QUERY_RAW_HEADERS = 21
Global Const $WINHTTP_QUERY_RAW_HEADERS_CRLF = 22
Global Const $WINHTTP_QUERY_CONNECTION = 23
Global Const $WINHTTP_QUERY_ACCEPT = 24
Global Const $WINHTTP_QUERY_ACCEPT_CHARSET = 25
Global Const $WINHTTP_QUERY_ACCEPT_ENCODING = 26
Global Const $WINHTTP_QUERY_ACCEPT_LANGUAGE = 27
Global Const $WINHTTP_QUERY_AUTHORIZATION = 28
Global Const $WINHTTP_QUERY_CONTENT_ENCODING = 29
Global Const $WINHTTP_QUERY_FORWARDED = 30
Global Const $WINHTTP_QUERY_FROM = 31
Global Const $WINHTTP_QUERY_IF_MODIFIED_SINCE = 32
Global Const $WINHTTP_QUERY_LOCATION = 33
Global Const $WINHTTP_QUERY_ORIG_URI = 34
Global Const $WINHTTP_QUERY_REFERER = 35
Global Const $WINHTTP_QUERY_RETRY_AFTER = 36
Global Const $WINHTTP_QUERY_SERVER = 37
Global Const $WINHTTP_QUERY_TITLE = 38
Global Const $WINHTTP_QUERY_USER_AGENT = 39
Global Const $WINHTTP_QUERY_WWW_AUTHENTICATE = 40
Global Const $WINHTTP_QUERY_PROXY_AUTHENTICATE = 41
Global Const $WINHTTP_QUERY_ACCEPT_RANGES = 42
Global Const $WINHTTP_QUERY_SET_COOKIE = 43
Global Const $WINHTTP_QUERY_COOKIE = 44
Global Const $WINHTTP_QUERY_REQUEST_METHOD = 45
Global Const $WINHTTP_QUERY_REFRESH = 46
Global Const $WINHTTP_QUERY_CONTENT_DISPOSITION = 47
Global Const $WINHTTP_QUERY_AGE = 48
Global Const $WINHTTP_QUERY_CACHE_CONTROL = 49
Global Const $WINHTTP_QUERY_CONTENT_BASE = 50
Global Const $WINHTTP_QUERY_CONTENT_LOCATION = 51
Global Const $WINHTTP_QUERY_CONTENT_MD5 = 52
Global Const $WINHTTP_QUERY_CONTENT_RANGE = 53
Global Const $WINHTTP_QUERY_ETAG = 54
Global Const $WINHTTP_QUERY_HOST = 55
Global Const $WINHTTP_QUERY_IF_MATCH = 56
Global Const $WINHTTP_QUERY_IF_NONE_MATCH = 57
Global Const $WINHTTP_QUERY_IF_RANGE = 58
Global Const $WINHTTP_QUERY_IF_UNMODIFIED_SINCE = 59
Global Const $WINHTTP_QUERY_MAX_FORWARDS = 60
Global Const $WINHTTP_QUERY_PROXY_AUTHORIZATION = 61
Global Const $WINHTTP_QUERY_RANGE = 62
Global Const $WINHTTP_QUERY_TRANSFER_ENCODING = 63
Global Const $WINHTTP_QUERY_UPGRADE = 64
Global Const $WINHTTP_QUERY_VARY = 65
Global Const $WINHTTP_QUERY_VIA = 66
Global Const $WINHTTP_QUERY_WARNING = 67
Global Const $WINHTTP_QUERY_EXPECT = 68
Global Const $WINHTTP_QUERY_PROXY_CONNECTION = 69
Global Const $WINHTTP_QUERY_UNLESS_MODIFIED_SINCE = 70
Global Const $WINHTTP_QUERY_PROXY_SUPPORT = 75
Global Const $WINHTTP_QUERY_AUTHENTICATION_INFO = 76
Global Const $WINHTTP_QUERY_PASSPORT_URLS = 77
Global Const $WINHTTP_QUERY_PASSPORT_CONFIG = 78
Global Const $WINHTTP_QUERY_MAX = 78
Global Const $WINHTTP_QUERY_CUSTOM = 65535
Global Const $WINHTTP_QUERY_FLAG_REQUEST_HEADERS = 0x80000000
Global Const $WINHTTP_QUERY_FLAG_SYSTEMTIME = 0x40000000
Global Const $WINHTTP_QUERY_FLAG_NUMBER = 0x20000000
Global Const $WINHTTP_CALLBACK_STATUS_RESOLVING_NAME = 0x00000001
Global Const $WINHTTP_CALLBACK_STATUS_NAME_RESOLVED = 0x00000002
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER = 0x00000004
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER = 0x00000008
Global Const $WINHTTP_CALLBACK_STATUS_SENDING_REQUEST = 0x00000010
Global Const $WINHTTP_CALLBACK_STATUS_REQUEST_SENT = 0x00000020
Global Const $WINHTTP_CALLBACK_STATUS_RECEIVING_RESPONSE = 0x00000040
Global Const $WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED = 0x00000080
Global Const $WINHTTP_CALLBACK_STATUS_CLOSING_CONNECTION = 0x00000100
Global Const $WINHTTP_CALLBACK_STATUS_CONNECTION_CLOSED = 0x00000200
Global Const $WINHTTP_CALLBACK_STATUS_HANDLE_CREATED = 0x00000400
Global Const $WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING = 0x00000800
Global Const $WINHTTP_CALLBACK_STATUS_DETECTING_PROXY = 0x00001000
Global Const $WINHTTP_CALLBACK_STATUS_REDIRECT = 0x00004000
Global Const $WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE = 0x00008000
Global Const $WINHTTP_CALLBACK_STATUS_SECURE_FAILURE = 0x00010000
Global Const $WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE = 0x00020000
Global Const $WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE = 0x00040000
Global Const $WINHTTP_CALLBACK_STATUS_READ_COMPLETE = 0x00080000
Global Const $WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE = 0x00100000
Global Const $WINHTTP_CALLBACK_STATUS_REQUEST_ERROR = 0x00200000
Global Const $WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE = 0x00400000
Global Const $WINHTTP_CALLBACK_FLAG_RESOLVE_NAME = 0x00000003
Global Const $WINHTTP_CALLBACK_FLAG_CONNECT_TO_SERVER = 0x0000000C
Global Const $WINHTTP_CALLBACK_FLAG_SEND_REQUEST = 0x00000030
Global Const $WINHTTP_CALLBACK_FLAG_RECEIVE_RESPONSE = 0x000000C0
Global Const $WINHTTP_CALLBACK_FLAG_CLOSE_CONNECTION = 0x00000300
Global Const $WINHTTP_CALLBACK_FLAG_HANDLES = 0x00000C00
Global Const $WINHTTP_CALLBACK_FLAG_DETECTING_PROXY = $WINHTTP_CALLBACK_STATUS_DETECTING_PROXY
Global Const $WINHTTP_CALLBACK_FLAG_REDIRECT = $WINHTTP_CALLBACK_STATUS_REDIRECT
Global Const $WINHTTP_CALLBACK_FLAG_INTERMEDIATE_RESPONSE = $WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE
Global Const $WINHTTP_CALLBACK_FLAG_SECURE_FAILURE = $WINHTTP_CALLBACK_STATUS_SECURE_FAILURE
Global Const $WINHTTP_CALLBACK_FLAG_SENDREQUEST_COMPLETE = $WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_HEADERS_AVAILABLE = $WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
Global Const $WINHTTP_CALLBACK_FLAG_DATA_AVAILABLE = $WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
Global Const $WINHTTP_CALLBACK_FLAG_READ_COMPLETE = $WINHTTP_CALLBACK_STATUS_READ_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_WRITE_COMPLETE = $WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
Global Const $WINHTTP_CALLBACK_FLAG_REQUEST_ERROR = $WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
Global Const $WINHTTP_CALLBACK_FLAG_ALL_COMPLETIONS = 0x007E0000
Global Const $WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS = 0xFFFFFFFF
Global Const $API_RECEIVE_RESPONSE = 1
Global Const $API_QUERY_DATA_AVAILABLE = 2
Global Const $API_READ_DATA = 3
Global Const $API_WRITE_DATA = 4
Global Const $API_SEND_REQUEST = 5
Global Const $WINHTTP_HANDLE_TYPE_SESSION = 1
Global Const $WINHTTP_HANDLE_TYPE_CONNECT = 2
Global Const $WINHTTP_HANDLE_TYPE_REQUEST = 3
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_REV_FAILED = 0x00000001
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CERT = 0x00000002
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_REVOKED = 0x00000004
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_INVALID_CA = 0x00000008
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_CN_INVALID = 0x00000010
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_DATE_INVALID = 0x00000020
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_CERT_WRONG_USAGE = 0x00000040
Global Const $WINHTTP_CALLBACK_STATUS_FLAG_SECURITY_CHANNEL_ERROR = 0x80000000
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_SSL2 = 0x00000008
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_SSL3 = 0x00000020
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1 = 0x00000080
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 = 0x00000200
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2 = 0x00000800
Global Const $WINHTTP_FLAG_SECURE_PROTOCOL_ALL = 0x000000A8
Global Const $WINHTTP_AUTH_SCHEME_BASIC = 0x00000001
Global Const $WINHTTP_AUTH_SCHEME_NTLM = 0x00000002
Global Const $WINHTTP_AUTH_SCHEME_PASSPORT = 0x00000004
Global Const $WINHTTP_AUTH_SCHEME_DIGEST = 0x00000008
Global Const $WINHTTP_AUTH_SCHEME_NEGOTIATE = 0x00000010
Global Const $WINHTTP_AUTH_TARGET_SERVER = 0x00000000
Global Const $WINHTTP_AUTH_TARGET_PROXY = 0x00000001
Global Const $WINHTTP_AUTOPROXY_AUTO_DETECT = 0x00000001
Global Const $WINHTTP_AUTOPROXY_CONFIG_URL = 0x00000002
Global Const $WINHTTP_AUTOPROXY_RUN_INPROCESS = 0x00010000
Global Const $WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY = 0x00020000
Global Const $WINHTTP_AUTO_DETECT_TYPE_DHCP = 0x00000001
Global Const $WINHTTP_AUTO_DETECT_TYPE_DNS_A = 0x00000002
Global Const $hWINHTTPDLL__WINHTTP = DllOpen("winhttp.dll")
DllOpen("winhttp.dll")
Func _WinHttpAddRequestHeaders($hRequest, $sHeader, $iModifier = Default)
__WinHttpDefault($iModifier, $WINHTTP_ADDREQ_FLAG_ADD_IF_NEW)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpAddRequestHeaders",  "handle", $hRequest,  "wstr", $sHeader,  "dword", -1,  "dword", $iModifier)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpCheckPlatform()
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpCheckPlatform")
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _WinHttpCloseHandle($hInternet)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpCloseHandle", "handle", $hInternet)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpConnect($hSession, $sServerName, $iServerPort = Default)
Local $aURL = _WinHttpCrackUrl($sServerName), $iScheme = 0
If @error Then
__WinHttpDefault($iServerPort, $INTERNET_DEFAULT_PORT)
Else
$sServerName = $aURL[2]
$iServerPort = $aURL[3]
$iScheme = $aURL[1]
EndIf
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "handle", "WinHttpConnect",  "handle", $hSession,  "wstr", $sServerName,  "dword", $iServerPort,  "dword", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
_WinHttpSetOption($aCall[0], $WINHTTP_OPTION_CONTEXT_VALUE, $iScheme)
Return $aCall[0]
EndFunc
Func _WinHttpCrackUrl($sURL, $iFlag = Default)
__WinHttpDefault($iFlag, $ICU_ESCAPE)
Local $tURL_COMPONENTS = DllStructCreate("dword StructSize;" &  "ptr SchemeName;" &  "dword SchemeNameLength;" &  "int Scheme;" &  "ptr HostName;" &  "dword HostNameLength;" &  "word Port;" &  "ptr UserName;" &  "dword UserNameLength;" &  "ptr Password;" &  "dword PasswordLength;" &  "ptr UrlPath;" &  "dword UrlPathLength;" &  "ptr ExtraInfo;" &  "dword ExtraInfoLength")
DllStructSetData($tURL_COMPONENTS, 1, DllStructGetSize($tURL_COMPONENTS))
Local $tBuffers[6]
Local $iURLLen = StringLen($sURL)
For $i = 0 To 5
$tBuffers[$i] = DllStructCreate("wchar[" & $iURLLen + 1 & "]")
Next
DllStructSetData($tURL_COMPONENTS, "SchemeNameLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "SchemeName", DllStructGetPtr($tBuffers[0]))
DllStructSetData($tURL_COMPONENTS, "HostNameLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "HostName", DllStructGetPtr($tBuffers[1]))
DllStructSetData($tURL_COMPONENTS, "UserNameLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "UserName", DllStructGetPtr($tBuffers[2]))
DllStructSetData($tURL_COMPONENTS, "PasswordLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "Password", DllStructGetPtr($tBuffers[3]))
DllStructSetData($tURL_COMPONENTS, "UrlPathLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "UrlPath", DllStructGetPtr($tBuffers[4]))
DllStructSetData($tURL_COMPONENTS, "ExtraInfoLength", $iURLLen)
DllStructSetData($tURL_COMPONENTS, "ExtraInfo", DllStructGetPtr($tBuffers[5]))
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpCrackUrl",  "wstr", $sURL,  "dword", $iURLLen,  "dword", $iFlag,  "struct*", $tURL_COMPONENTS)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Local $aRet[8] = [DllStructGetData($tBuffers[0], 1),  DllStructGetData($tURL_COMPONENTS, "Scheme"),  DllStructGetData($tBuffers[1], 1),  DllStructGetData($tURL_COMPONENTS, "Port"),  DllStructGetData($tBuffers[2], 1),  DllStructGetData($tBuffers[3], 1),  DllStructGetData($tBuffers[4], 1),  DllStructGetData($tBuffers[5], 1)]
Return $aRet
EndFunc
Func _WinHttpCreateUrl($aURLArray)
If UBound($aURLArray) - 8 Then Return SetError(1, 0, "")
Local $tURL_COMPONENTS = DllStructCreate("dword StructSize;" &  "ptr SchemeName;" &  "dword SchemeNameLength;" &  "int Scheme;" &  "ptr HostName;" &  "dword HostNameLength;" &  "word Port;" &  "ptr UserName;" &  "dword UserNameLength;" &  "ptr Password;" &  "dword PasswordLength;" &  "ptr UrlPath;" &  "dword UrlPathLength;" &  "ptr ExtraInfo;" &  "dword ExtraInfoLength;")
DllStructSetData($tURL_COMPONENTS, 1, DllStructGetSize($tURL_COMPONENTS))
Local $tBuffers[6][2]
$tBuffers[0][1] = StringLen($aURLArray[0])
If $tBuffers[0][1] Then
$tBuffers[0][0] = DllStructCreate("wchar[" & $tBuffers[0][1] + 1 & "]")
DllStructSetData($tBuffers[0][0], 1, $aURLArray[0])
EndIf
$tBuffers[1][1] = StringLen($aURLArray[2])
If $tBuffers[1][1] Then
$tBuffers[1][0] = DllStructCreate("wchar[" & $tBuffers[1][1] + 1 & "]")
DllStructSetData($tBuffers[1][0], 1, $aURLArray[2])
EndIf
$tBuffers[2][1] = StringLen($aURLArray[4])
If $tBuffers[2][1] Then
$tBuffers[2][0] = DllStructCreate("wchar[" & $tBuffers[2][1] + 1 & "]")
DllStructSetData($tBuffers[2][0], 1, $aURLArray[4])
EndIf
$tBuffers[3][1] = StringLen($aURLArray[5])
If $tBuffers[3][1] Then
$tBuffers[3][0] = DllStructCreate("wchar[" & $tBuffers[3][1] + 1 & "]")
DllStructSetData($tBuffers[3][0], 1, $aURLArray[5])
EndIf
$tBuffers[4][1] = StringLen($aURLArray[6])
If $tBuffers[4][1] Then
$tBuffers[4][0] = DllStructCreate("wchar[" & $tBuffers[4][1] + 1 & "]")
DllStructSetData($tBuffers[4][0], 1, $aURLArray[6])
EndIf
$tBuffers[5][1] = StringLen($aURLArray[7])
If $tBuffers[5][1] Then
$tBuffers[5][0] = DllStructCreate("wchar[" & $tBuffers[5][1] + 1 & "]")
DllStructSetData($tBuffers[5][0], 1, $aURLArray[7])
EndIf
DllStructSetData($tURL_COMPONENTS, "SchemeNameLength", $tBuffers[0][1])
DllStructSetData($tURL_COMPONENTS, "SchemeName", DllStructGetPtr($tBuffers[0][0]))
DllStructSetData($tURL_COMPONENTS, "HostNameLength", $tBuffers[1][1])
DllStructSetData($tURL_COMPONENTS, "HostName", DllStructGetPtr($tBuffers[1][0]))
DllStructSetData($tURL_COMPONENTS, "UserNameLength", $tBuffers[2][1])
DllStructSetData($tURL_COMPONENTS, "UserName", DllStructGetPtr($tBuffers[2][0]))
DllStructSetData($tURL_COMPONENTS, "PasswordLength", $tBuffers[3][1])
DllStructSetData($tURL_COMPONENTS, "Password", DllStructGetPtr($tBuffers[3][0]))
DllStructSetData($tURL_COMPONENTS, "UrlPathLength", $tBuffers[4][1])
DllStructSetData($tURL_COMPONENTS, "UrlPath", DllStructGetPtr($tBuffers[4][0]))
DllStructSetData($tURL_COMPONENTS, "ExtraInfoLength", $tBuffers[5][1])
DllStructSetData($tURL_COMPONENTS, "ExtraInfo", DllStructGetPtr($tBuffers[5][0]))
DllStructSetData($tURL_COMPONENTS, "Scheme", $aURLArray[1])
DllStructSetData($tURL_COMPONENTS, "Port", $aURLArray[3])
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpCreateUrl",  "struct*", $tURL_COMPONENTS,  "dword", $ICU_ESCAPE,  "ptr", 0,  "dword*", 0)
If @error Then Return SetError(2, 0, "")
Local $iURLLen = $aCall[4]
Local $URLBuffer = DllStructCreate("wchar[" & ($iURLLen + 1) & "]")
$aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpCreateUrl",  "struct*", $tURL_COMPONENTS,  "dword", $ICU_ESCAPE,  "struct*", $URLBuffer,  "dword*", $iURLLen)
If @error Or Not $aCall[0] Then Return SetError(3, 0, "")
Return DllStructGetData($URLBuffer, 1)
EndFunc
Func _WinHttpDetectAutoProxyConfigUrl($iAutoDetectFlags)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpDetectAutoProxyConfigUrl", "dword", $iAutoDetectFlags, "ptr*", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, "")
Local $pStr = $aCall[2]
If $pStr Then
Local $iLen = __WinHttpPtrStringLenW($pStr)
If @error Then Return SetError(2, 0, "")
Local $tString = DllStructCreate("wchar[" & $iLen + 1 & "]", $pStr)
Local $sString = DllStructGetData($tString, 1)
__WinHttpMemGlobalFree($pStr)
Return $sString
EndIf
Return ""
EndFunc
Func _WinHttpGetDefaultProxyConfiguration()
Local $tWINHTTP_PROXY_INFO = DllStructCreate("dword AccessType;" &  "ptr Proxy;" &  "ptr ProxyBypass")
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpGetDefaultProxyConfiguration", "struct*", $tWINHTTP_PROXY_INFO)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Local $iAccessType = DllStructGetData($tWINHTTP_PROXY_INFO, "AccessType")
Local $pProxy = DllStructGetData($tWINHTTP_PROXY_INFO, "Proxy")
Local $pProxyBypass = DllStructGetData($tWINHTTP_PROXY_INFO, "ProxyBypass")
Local $sProxy
If $pProxy Then
Local $iProxyLen = __WinHttpPtrStringLenW($pProxy)
If Not @error Then
Local $tProxy = DllStructCreate("wchar[" & $iProxyLen + 1 & "]", $pProxy)
$sProxy = DllStructGetData($tProxy, 1)
__WinHttpMemGlobalFree($pProxy)
EndIf
EndIf
Local $sProxyBypass
If $pProxyBypass Then
Local $iProxyBypassLen = __WinHttpPtrStringLenW($pProxyBypass)
If Not @error Then
Local $tProxyBypass = DllStructCreate("wchar[" & $iProxyBypassLen + 1 & "]", $pProxyBypass)
$sProxyBypass = DllStructGetData($tProxyBypass, 1)
__WinHttpMemGlobalFree($pProxyBypass)
EndIf
EndIf
Local $aRet[3] = [$iAccessType, $sProxy, $sProxyBypass]
Return $aRet
EndFunc
Func _WinHttpGetIEProxyConfigForCurrentUser()
Local $tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG = DllStructCreate("int AutoDetect;" &  "ptr AutoConfigUrl;" &  "ptr Proxy;" &  "ptr ProxyBypass;")
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpGetIEProxyConfigForCurrentUser", "struct*", $tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Local $iAutoDetect = DllStructGetData($tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG, "AutoDetect")
Local $pAutoConfigUrl = DllStructGetData($tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG, "AutoConfigUrl")
Local $pProxy = DllStructGetData($tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG, "Proxy")
Local $pProxyBypass = DllStructGetData($tWINHTTP_CURRENT_USER_IE_PROXY_CONFIG, "ProxyBypass")
Local $sAutoConfigUrl
If $pAutoConfigUrl Then
Local $iAutoConfigUrlLen = __WinHttpPtrStringLenW($pAutoConfigUrl)
If Not @error Then
Local $tAutoConfigUrl = DllStructCreate("wchar[" & $iAutoConfigUrlLen + 1 & "]", $pAutoConfigUrl)
$sAutoConfigUrl = DllStructGetData($tAutoConfigUrl, 1)
__WinHttpMemGlobalFree($pAutoConfigUrl)
EndIf
EndIf
Local $sProxy
If $pProxy Then
Local $iProxyLen = __WinHttpPtrStringLenW($pProxy)
If Not @error Then
Local $tProxy = DllStructCreate("wchar[" & $iProxyLen + 1 & "]", $pProxy)
$sProxy = DllStructGetData($tProxy, 1)
__WinHttpMemGlobalFree($pProxy)
EndIf
EndIf
Local $sProxyBypass
If $pProxyBypass Then
Local $iProxyBypassLen = __WinHttpPtrStringLenW($pProxyBypass)
If Not @error Then
Local $tProxyBypass = DllStructCreate("wchar[" & $iProxyBypassLen + 1 & "]", $pProxyBypass)
$sProxyBypass = DllStructGetData($tProxyBypass, 1)
__WinHttpMemGlobalFree($pProxyBypass)
EndIf
EndIf
Local $aOutput[4] = [$iAutoDetect, $sAutoConfigUrl, $sProxy, $sProxyBypass]
Return $aOutput
EndFunc
Func _WinHttpOpen($sUserAgent = Default, $iAccessType = Default, $sProxyName = Default, $sProxyBypass = Default, $iFlag = Default)
__WinHttpDefault($sUserAgent, __WinHttpUA())
__WinHttpDefault($iAccessType, $WINHTTP_ACCESS_TYPE_NO_PROXY)
__WinHttpDefault($sProxyName, $WINHTTP_NO_PROXY_NAME)
__WinHttpDefault($sProxyBypass, $WINHTTP_NO_PROXY_BYPASS)
__WinHttpDefault($iFlag, 0)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "handle", "WinHttpOpen",  "wstr", $sUserAgent,  "dword", $iAccessType,  "wstr", $sProxyName,  "wstr", $sProxyBypass,  "dword", $iFlag)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
If $iFlag = $WINHTTP_FLAG_ASYNC Then _WinHttpSetOption($aCall[0], $WINHTTP_OPTION_CONTEXT_VALUE, $WINHTTP_FLAG_ASYNC)
Return $aCall[0]
EndFunc
Func _WinHttpOpenRequest($hConnect, $sVerb = Default, $sObjectName = Default, $sVersion = Default, $sReferrer = Default, $sAcceptTypes = Default, $iFlags = Default)
__WinHttpDefault($sVerb, "GET")
__WinHttpDefault($sObjectName, "")
__WinHttpDefault($sVersion, "HTTP/1.1")
__WinHttpDefault($sReferrer, $WINHTTP_NO_REFERER)
__WinHttpDefault($iFlags, $WINHTTP_FLAG_ESCAPE_DISABLE)
Local $pAcceptTypes
If $sAcceptTypes = Default Or Number($sAcceptTypes) = -1 Then
$pAcceptTypes = $WINHTTP_DEFAULT_ACCEPT_TYPES
Else
Local $aTypes = StringSplit($sAcceptTypes, ",", 2)
Local $tAcceptTypes = DllStructCreate("ptr[" & UBound($aTypes) + 1 & "]")
Local $tType[UBound($aTypes)]
For $i = 0 To UBound($aTypes) - 1
$tType[$i] = DllStructCreate("wchar[" & StringLen($aTypes[$i]) + 1 & "]")
DllStructSetData($tType[$i], 1, $aTypes[$i])
DllStructSetData($tAcceptTypes, 1, DllStructGetPtr($tType[$i]), $i + 1)
Next
$pAcceptTypes = DllStructGetPtr($tAcceptTypes)
EndIf
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "handle", "WinHttpOpenRequest",  "handle", $hConnect,  "wstr", StringUpper($sVerb),  "wstr", $sObjectName,  "wstr", StringUpper($sVersion),  "wstr", $sReferrer,  "ptr", $pAcceptTypes,  "dword", $iFlags)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _WinHttpQueryAuthSchemes($hRequest, ByRef $iSupportedSchemes, ByRef $iFirstScheme, ByRef $iAuthTarget)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpQueryAuthSchemes",  "handle", $hRequest,  "dword*", 0,  "dword*", 0,  "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
$iSupportedSchemes = $aCall[2]
$iFirstScheme = $aCall[3]
$iAuthTarget = $aCall[4]
Return 1
EndFunc
Func _WinHttpQueryDataAvailable($hRequest)
Local $sReadType = "dword*"
If BitAND(_WinHttpQueryOption(_WinHttpQueryOption(_WinHttpQueryOption($hRequest, $WINHTTP_OPTION_PARENT_HANDLE), $WINHTTP_OPTION_PARENT_HANDLE), $WINHTTP_OPTION_CONTEXT_VALUE), $WINHTTP_FLAG_ASYNC) Then $sReadType = "ptr"
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpQueryDataAvailable", "handle", $hRequest, $sReadType, 0)
If @error Then Return SetError(1, 0, 0)
Return SetExtended($aCall[2], $aCall[0])
EndFunc
Func _WinHttpQueryHeaders($hRequest, $iInfoLevel = Default, $sName = Default, $iIndex = Default)
__WinHttpDefault($iInfoLevel, $WINHTTP_QUERY_RAW_HEADERS_CRLF)
__WinHttpDefault($sName, $WINHTTP_HEADER_NAME_BY_INDEX)
__WinHttpDefault($iIndex, $WINHTTP_NO_HEADER_INDEX)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpQueryHeaders",  "handle", $hRequest,  "dword", $iInfoLevel,  "wstr", $sName,  "wstr", "",  "dword*", 65536,  "dword*", $iIndex)
If @error Or Not $aCall[0] Then Return SetError(1, 0, "")
Return SetExtended($aCall[6], $aCall[4])
EndFunc
Func _WinHttpQueryOption($hInternet, $iOption)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpQueryOption",  "handle", $hInternet,  "dword", $iOption,  "ptr", 0,  "dword*", 0)
If @error Or $aCall[0] Then Return SetError(1, 0, "")
Local $iSize = $aCall[4]
Local $tBuffer
Switch $iOption
Case $WINHTTP_OPTION_CONNECTION_INFO, $WINHTTP_OPTION_PASSWORD, $WINHTTP_OPTION_PROXY_PASSWORD, $WINHTTP_OPTION_PROXY_USERNAME, $WINHTTP_OPTION_URL, $WINHTTP_OPTION_USERNAME, $WINHTTP_OPTION_USER_AGENT,  $WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT, $WINHTTP_OPTION_PASSPORT_COBRANDING_URL
$tBuffer = DllStructCreate("wchar[" & $iSize + 1 & "]")
Case $WINHTTP_OPTION_PARENT_HANDLE, $WINHTTP_OPTION_CALLBACK, $WINHTTP_OPTION_SERVER_CERT_CONTEXT
$tBuffer = DllStructCreate("ptr")
Case $WINHTTP_OPTION_CONNECT_TIMEOUT, $WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH, $WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW, $WINHTTP_AUTOLOGON_SECURITY_LEVEL_MEDIUM,  $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH, $WINHTTP_OPTION_CONNECT_RETRIES, $WINHTTP_OPTION_EXTENDED_ERROR, $WINHTTP_OPTION_HANDLE_TYPE, $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER,  $WINHTTP_OPTION_MAX_CONNS_PER_SERVER, $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS, $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT, $WINHTTP_OPTION_RECEIVE_TIMEOUT,  $WINHTTP_OPTION_RESOLVE_TIMEOUT, $WINHTTP_OPTION_SECURITY_FLAGS, $WINHTTP_OPTION_SECURITY_KEY_BITNESS, $WINHTTP_OPTION_SEND_TIMEOUT
$tBuffer = DllStructCreate("int")
Case $WINHTTP_OPTION_CONTEXT_VALUE
$tBuffer = DllStructCreate("dword_ptr")
Case Else
$tBuffer = DllStructCreate("byte[" & $iSize & "]")
EndSwitch
$aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpQueryOption",  "handle", $hInternet,  "dword", $iOption,  "struct*", $tBuffer,  "dword*", $iSize)
If @error Or Not $aCall[0] Then Return SetError(2, 0, "")
Return DllStructGetData($tBuffer, 1)
EndFunc
Func _WinHttpReadData($hRequest, $iMode = Default, $iNumberOfBytesToRead = Default, $pBuffer = Default)
__WinHttpDefault($iMode, 0)
__WinHttpDefault($iNumberOfBytesToRead, 8192)
Local $tBuffer, $vOutOnError = ""
If $iMode = 2 Then $vOutOnError = Binary($vOutOnError)
Switch $iMode
Case 1, 2
If $pBuffer And $pBuffer <> Default Then
$tBuffer = DllStructCreate("byte[" & $iNumberOfBytesToRead & "]", $pBuffer)
Else
$tBuffer = DllStructCreate("byte[" & $iNumberOfBytesToRead & "]")
EndIf
Case Else
$iMode = 0
If $pBuffer And $pBuffer <> Default Then
$tBuffer = DllStructCreate("char[" & $iNumberOfBytesToRead & "]", $pBuffer)
Else
$tBuffer = DllStructCreate("char[" & $iNumberOfBytesToRead & "]")
EndIf
EndSwitch
Local $sReadType = "dword*"
If BitAND(_WinHttpQueryOption(_WinHttpQueryOption(_WinHttpQueryOption($hRequest, $WINHTTP_OPTION_PARENT_HANDLE), $WINHTTP_OPTION_PARENT_HANDLE), $WINHTTP_OPTION_CONTEXT_VALUE), $WINHTTP_FLAG_ASYNC) Then $sReadType = "ptr"
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpReadData",  "handle", $hRequest,  "struct*", $tBuffer,  "dword", $iNumberOfBytesToRead,  $sReadType, 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, "")
If Not $aCall[4] Then Return SetError(-1, 0, $vOutOnError)
If $aCall[4] < $iNumberOfBytesToRead Then
Switch $iMode
Case 0
Return SetExtended($aCall[4], StringLeft(DllStructGetData($tBuffer, 1), $aCall[4]))
Case 1
Return SetExtended($aCall[4], BinaryToString(BinaryMid(DllStructGetData($tBuffer, 1), 1, $aCall[4]), 4))
Case 2
Return SetExtended($aCall[4], BinaryMid(DllStructGetData($tBuffer, 1), 1, $aCall[4]))
EndSwitch
Else
Switch $iMode
Case 0, 2
Return SetExtended($aCall[4], DllStructGetData($tBuffer, 1))
Case 1
Return SetExtended($aCall[4], BinaryToString(DllStructGetData($tBuffer, 1), 4))
EndSwitch
EndIf
EndFunc
Func _WinHttpReceiveResponse($hRequest)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpReceiveResponse", "handle", $hRequest, "ptr", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpSendRequest($hRequest, $sHeaders = Default, $vOptional = Default, $iTotalLength = Default, $iContext = Default)
__WinHttpDefault($sHeaders, $WINHTTP_NO_ADDITIONAL_HEADERS)
__WinHttpDefault($vOptional, $WINHTTP_NO_REQUEST_DATA)
__WinHttpDefault($iTotalLength, 0)
__WinHttpDefault($iContext, 0)
Local $pOptional = 0, $iOptionalLength = 0
If @NumParams > 2 Then
Local $tOptional
$iOptionalLength = BinaryLen($vOptional)
$tOptional = DllStructCreate("byte[" & $iOptionalLength & "]")
If $iOptionalLength Then $pOptional = DllStructGetPtr($tOptional)
DllStructSetData($tOptional, 1, $vOptional)
EndIf
If Not $iTotalLength Or $iTotalLength < $iOptionalLength Then $iTotalLength += $iOptionalLength
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSendRequest",  "handle", $hRequest,  "wstr", $sHeaders,  "dword", 0,  "ptr", $pOptional,  "dword", $iOptionalLength,  "dword", $iTotalLength,  "dword_ptr", $iContext)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpSetCredentials($hRequest, $iAuthTargets, $iAuthScheme, $sUserName, $sPassword)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSetCredentials",  "handle", $hRequest,  "dword", $iAuthTargets,  "dword", $iAuthScheme,  "wstr", $sUserName,  "wstr", $sPassword,  "ptr", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpSetDefaultProxyConfiguration($iAccessType, $sProxy = "", $sProxyBypass = "")
Local $tProxy = DllStructCreate("wchar[" & StringLen($sProxy) + 1 & "]")
DllStructSetData($tProxy, 1, $sProxy)
Local $tProxyBypass = DllStructCreate("wchar[" & StringLen($sProxyBypass) + 1 & "]")
DllStructSetData($tProxyBypass, 1, $sProxyBypass)
Local $tWINHTTP_PROXY_INFO = DllStructCreate("dword AccessType;" &  "ptr Proxy;" &  "ptr ProxyBypass")
DllStructSetData($tWINHTTP_PROXY_INFO, "AccessType", $iAccessType)
If $iAccessType <> $WINHTTP_ACCESS_TYPE_NO_PROXY Then
DllStructSetData($tWINHTTP_PROXY_INFO, "Proxy", DllStructGetPtr($tProxy))
DllStructSetData($tWINHTTP_PROXY_INFO, "ProxyBypass", DllStructGetPtr($tProxyBypass))
EndIf
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSetDefaultProxyConfiguration", "struct*", $tWINHTTP_PROXY_INFO)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpSetOption($hInternet, $iOption, $vSetting, $iSize = Default)
If $iSize = Default Then $iSize = -1
If IsBinary($vSetting) Then
$iSize = DllStructCreate("byte[" & BinaryLen($vSetting) & "]")
DllStructSetData($iSize, 1, $vSetting)
$vSetting = $iSize
$iSize = DllStructGetSize($vSetting)
EndIf
Local $sType
Switch $iOption
Case $WINHTTP_OPTION_AUTOLOGON_POLICY, $WINHTTP_OPTION_CODEPAGE, $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH, $WINHTTP_OPTION_CONNECT_RETRIES,  $WINHTTP_OPTION_CONNECT_TIMEOUT, $WINHTTP_OPTION_DISABLE_FEATURE, $WINHTTP_OPTION_ENABLE_FEATURE, $WINHTTP_OPTION_ENABLETRACING,  $WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER, $WINHTTP_OPTION_MAX_CONNS_PER_SERVER, $WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS,  $WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE, $WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE, $WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE,  $WINHTTP_OPTION_READ_BUFFER_SIZE, $WINHTTP_OPTION_RECEIVE_TIMEOUT,  $WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT, $WINHTTP_OPTION_REDIRECT_POLICY, $WINHTTP_OPTION_REJECT_USERPWD_IN_URL,  $WINHTTP_OPTION_REQUEST_PRIORITY, $WINHTTP_OPTION_RESOLVE_TIMEOUT, $WINHTTP_OPTION_SECURE_PROTOCOLS, $WINHTTP_OPTION_SECURITY_FLAGS,  $WINHTTP_OPTION_SECURITY_KEY_BITNESS, $WINHTTP_OPTION_SEND_TIMEOUT, $WINHTTP_OPTION_SPN, $WINHTTP_OPTION_USE_GLOBAL_SERVER_CREDENTIALS,  $WINHTTP_OPTION_WORKER_THREAD_COUNT, $WINHTTP_OPTION_WRITE_BUFFER_SIZE, $WINHTTP_OPTION_DECOMPRESSION, $WINHTTP_OPTION_UNSAFE_HEADER_PARSING
$sType = "dword*"
$iSize = 4
Case $WINHTTP_OPTION_CALLBACK, $WINHTTP_OPTION_PASSPORT_SIGN_OUT
$sType = "ptr*"
$iSize = 4
If @AutoItX64 Then $iSize = 8
If Not IsPtr($vSetting) Then Return SetError(3, 0, 0)
Case $WINHTTP_OPTION_CONTEXT_VALUE
$sType = "dword_ptr*"
$iSize = 4
If @AutoItX64 Then $iSize = 8
Case $WINHTTP_OPTION_PASSWORD, $WINHTTP_OPTION_PROXY_PASSWORD, $WINHTTP_OPTION_PROXY_USERNAME, $WINHTTP_OPTION_USER_AGENT, $WINHTTP_OPTION_USERNAME
$sType = "wstr"
If (IsDllStruct($vSetting) Or IsPtr($vSetting)) Then Return SetError(3, 0, 0)
If $iSize < 1 Then $iSize = StringLen($vSetting)
Case $WINHTTP_OPTION_CLIENT_CERT_CONTEXT, $WINHTTP_OPTION_GLOBAL_PROXY_CREDS, $WINHTTP_OPTION_GLOBAL_SERVER_CREDS, $WINHTTP_OPTION_HTTP_VERSION,  $WINHTTP_OPTION_PROXY
$sType = "ptr"
If Not (IsDllStruct($vSetting) Or IsPtr($vSetting)) Then Return SetError(3, 0, 0)
Case Else
Return SetError(1, 0, 0)
EndSwitch
If $iSize < 1 Then
If IsDllStruct($vSetting) Then
$iSize = DllStructGetSize($vSetting)
Else
Return SetError(2, 0, 0)
EndIf
EndIf
Local $aCall
If IsDllStruct($vSetting) Then
$aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSetOption", "handle", $hInternet, "dword", $iOption, $sType, DllStructGetPtr($vSetting), "dword", $iSize)
Else
$aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSetOption", "handle", $hInternet, "dword", $iOption, $sType, $vSetting, "dword", $iSize)
EndIf
If @error Or Not $aCall[0] Then Return SetError(4, 0, 0)
Return 1
EndFunc
Func _WinHttpSetStatusCallback($hInternet, $hInternetCallback, $iNotificationFlags = Default)
__WinHttpDefault($iNotificationFlags, $WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "ptr", "WinHttpSetStatusCallback",  "handle", $hInternet,  "ptr", DllCallbackGetPtr($hInternetCallback),  "dword", $iNotificationFlags,  "ptr", 0)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func _WinHttpSetTimeouts($hInternet, $iResolveTimeout = Default, $iConnectTimeout = Default, $iSendTimeout = Default, $iReceiveTimeout = Default)
__WinHttpDefault($iResolveTimeout, 0)
__WinHttpDefault($iConnectTimeout, 60000)
__WinHttpDefault($iSendTimeout, 30000)
__WinHttpDefault($iReceiveTimeout, 30000)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpSetTimeouts",  "handle", $hInternet,  "int", $iResolveTimeout,  "int", $iConnectTimeout,  "int", $iSendTimeout,  "int", $iReceiveTimeout)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func _WinHttpSimpleBinaryConcat(ByRef $bBinary1, ByRef $bBinary2)
Switch IsBinary($bBinary1) + 2 * IsBinary($bBinary2)
Case 0
Return SetError(1, 0, Binary(''))
Case 1
Return $bBinary1
Case 2
Return $bBinary2
EndSwitch
Local $tAuxiliary = DllStructCreate("byte[" & BinaryLen($bBinary1) & "];byte[" & BinaryLen($bBinary2) & "]")
DllStructSetData($tAuxiliary, 1, $bBinary1)
DllStructSetData($tAuxiliary, 2, $bBinary2)
Local $tOutput = DllStructCreate("byte[" & DllStructGetSize($tAuxiliary) & "]", DllStructGetPtr($tAuxiliary))
Return DllStructGetData($tOutput, 1)
EndFunc
Func _WinHttpSimpleFormFill(ByRef $hInternet, $sActionPage = Default, $sFormId = Default, $sFldId1 = Default, $sDta1 = Default, $sFldId2 = Default, $sDta2 = Default, $sFldId3 = Default, $sDta3 = Default, $sFldId4 = Default, $sDta4 = Default, $sFldId5 = Default, $sDta5 = Default, $sFldId6 = Default, $sDta6 = Default, $sFldId7 = Default, $sDta7 = Default, $sFldId8 = Default, $sDta8 = Default, $sFldId9 = Default, $sDta9 = Default, $sFldId10 = Default, $sDta10 = Default,  $sFldId11 = Default, $sDta11 = Default, $sFldId12 = Default, $sDta12 = Default, $sFldId13 = Default, $sDta13 = Default, $sFldId14 = Default, $sDta14 = Default, $sFldId15 = Default, $sDta15 = Default, $sFldId16 = Default, $sDta16 = Default, $sFldId17 = Default, $sDta17 = Default, $sFldId18 = Default, $sDta18 = Default, $sFldId19 = Default, $sDta19 = Default, $sFldId20 = Default, $sDta20 = Default,  $sFldId21 = Default, $sDta21 = Default, $sFldId22 = Default, $sDta22 = Default, $sFldId23 = Default, $sDta23 = Default, $sFldId24 = Default, $sDta24 = Default, $sFldId25 = Default, $sDta25 = Default, $sFldId26 = Default, $sDta26 = Default, $sFldId27 = Default, $sDta27 = Default, $sFldId28 = Default, $sDta28 = Default, $sFldId29 = Default, $sDta29 = Default, $sFldId30 = Default, $sDta30 = Default,  $sFldId31 = Default, $sDta31 = Default, $sFldId32 = Default, $sDta32 = Default, $sFldId33 = Default, $sDta33 = Default, $sFldId34 = Default, $sDta34 = Default, $sFldId35 = Default, $sDta35 = Default, $sFldId36 = Default, $sDta36 = Default, $sFldId37 = Default, $sDta37 = Default, $sFldId38 = Default, $sDta38 = Default, $sFldId39 = Default, $sDta39 = Default, $sFldId40 = Default, $sDta40 = Default)
__WinHttpDefault($sActionPage, "")
Local $iNumArgs = @NumParams, $sAdditionalHeaders, $sCredName, $sCredPass, $iIgnoreCertErr, $iRetArr
Local $aDtas[41] = [0, $sDta1, $sDta2, $sDta3, $sDta4, $sDta5, $sDta6, $sDta7, $sDta8, $sDta9, $sDta10, $sDta11, $sDta12, $sDta13, $sDta14, $sDta15, $sDta16, $sDta17, $sDta18, $sDta19, $sDta20, $sDta21, $sDta22, $sDta23, $sDta24, $sDta25, $sDta26, $sDta27, $sDta28, $sDta29, $sDta30, $sDta31, $sDta32, $sDta33, $sDta34, $sDta35, $sDta36, $sDta37, $sDta38, $sDta39, $sDta40]
Local $aFlds[41] = [0, $sFldId1, $sFldId2, $sFldId3, $sFldId4, $sFldId5, $sFldId6, $sFldId7, $sFldId8, $sFldId9, $sFldId10, $sFldId11, $sFldId12, $sFldId13, $sFldId14, $sFldId15, $sFldId16, $sFldId17, $sFldId18, $sFldId19, $sFldId20, $sFldId21, $sFldId22, $sFldId23, $sFldId24, $sFldId25, $sFldId26, $sFldId27, $sFldId28, $sFldId29, $sFldId30, $sFldId31, $sFldId32, $sFldId33, $sFldId34, $sFldId35, $sFldId36, $sFldId37, $sFldId38, $sFldId39, $sFldId40]
If Not Mod($iNumArgs, 2) Then
$sAdditionalHeaders = $aFlds[$iNumArgs / 2 - 1]
$aFlds[$iNumArgs / 2 - 1] = 0
$iIgnoreCertErr = StringInStr($sAdditionalHeaders, "[IGNORE_CERT_ERRORS]")
If $iIgnoreCertErr Then $sAdditionalHeaders = StringReplace($sAdditionalHeaders, "[IGNORE_CERT_ERRORS]", "", 1)
$iRetArr = StringInStr($sAdditionalHeaders, "[RETURN_ARRAY]")
If $iRetArr Then $sAdditionalHeaders = StringReplace($sAdditionalHeaders, "[RETURN_ARRAY]", "", 1)
Local $aCred = StringRegExp($sAdditionalHeaders, "\[CRED:(.*?)\]", 2)
If Not @error Then
Local $sCredDelim = ":"
If Not StringInStr($aCred[1], $sCredDelim) Then $sCredDelim = ","
Local $aStrSplit = StringSplit($aCred[1], $sCredDelim, 3)
If Not @error Then
$sCredName = $aStrSplit[0]
$sCredPass = $aStrSplit[1]
EndIf
$sAdditionalHeaders = StringReplace($sAdditionalHeaders, $aCred[0], "", 1)
EndIf
EndIf
Local $hOpen, $aHTML, $sHTML, $sURL, $fVarForm, $iScheme = $INTERNET_SCHEME_HTTP
If IsString($hInternet) Then
$sHTML = $hInternet
If _WinHttpQueryOption($sActionPage, $WINHTTP_OPTION_HANDLE_TYPE) <> $WINHTTP_HANDLE_TYPE_SESSION Then Return SetError(6, 0, "")
$hOpen = $sActionPage
$fVarForm = True
Else
$iScheme = _WinHttpQueryOption($hInternet, $WINHTTP_OPTION_CONTEXT_VALUE)
Local $sAccpt = "Accept: text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5"
If $iScheme = $INTERNET_SCHEME_HTTPS Then
$aHTML = _WinHttpSimpleSSLRequest($hInternet, Default, $sActionPage, Default, Default, $sAccpt, 1, Default, $sCredName, $sCredPass, $iIgnoreCertErr)
ElseIf $iScheme = $INTERNET_SCHEME_HTTP Then
$aHTML = _WinHttpSimpleRequest($hInternet, Default, $sActionPage, Default, Default, $sAccpt, 1, Default, $sCredName, $sCredPass)
Else
$aHTML = _WinHttpSimpleRequest($hInternet, Default, $sActionPage, Default, Default, $sAccpt, 1, Default, $sCredName, $sCredPass)
If @error Or @extended >= $HTTP_STATUS_BAD_REQUEST Then
$aHTML = _WinHttpSimpleSSLRequest($hInternet, Default, $sActionPage, Default, Default, $sAccpt, 1, Default, $sCredName, $sCredPass, $iIgnoreCertErr)
$iScheme = $INTERNET_SCHEME_HTTPS
Else
$iScheme = $INTERNET_SCHEME_HTTP
EndIf
EndIf
If Not @error Then
$sHTML = $aHTML[1]
$sURL = $aHTML[2]
EndIf
EndIf
$sHTML = StringRegExpReplace($sHTML, "(?s)<!--.*?-->", "")
$sHTML = StringRegExpReplace($sHTML, "(?s)<!\[CDATA\[.*?\]\]>", "")
Local $fSend = False
Local $aForm = StringRegExp($sHTML, "(?si)<\s*form(?:[^\w])\s*(.*?)(?:(?:<\s*/form\s*>)|\Z)", 3)
If @error Then Return SetError(1, 0, "")
Local $fGetFormByName, $sFormName, $fGetFormByIndex, $fGetFormById, $iFormIndex
Local $aSplitForm = StringSplit($sFormId, ":", 2)
If @error Then
$fGetFormById = True
Else
If $aSplitForm[0] = "name" Then
$sFormName = $aSplitForm[1]
$fGetFormByName = True
ElseIf $aSplitForm[0] = "index" Then
$iFormIndex = Number($aSplitForm[1])
$fGetFormByIndex = True
ElseIf $aSplitForm[0] = "id" Then
$sFormId = $aSplitForm[1]
$fGetFormById = True
Else
$sFormId = $aSplitForm[0]
$fGetFormById = True
EndIf
EndIf
Local $sForm, $sAttributes, $aInput
Local $iNumParams = Ceiling(($iNumArgs - 2) / 2) - 1
Local $sAddData, $sNewURL
For $iFormOrdinal = 0 To UBound($aForm) - 1
If $fGetFormByIndex And $iFormOrdinal <> $iFormIndex Then ContinueLoop
$sForm = $aForm[$iFormOrdinal]
$sAttributes = StringRegExp($sForm, "(?s)(.*?)>", 3)
If Not @error Then $sAttributes = StringRegExpReplace($sAttributes[0], "\v", " ")
Local $sAction = "", $sAccept = "", $sEnctype = "", $sMethod = "", $sName = "", $sId = ""
$sId = __WinHttpAttribVal($sAttributes, "id")
If $fGetFormById And $sFormId <> Default And $sId <> $sFormId Then ContinueLoop
$sName = __WinHttpAttribVal($sAttributes, "name")
If $fGetFormByName And $sFormName <> $sName Then ContinueLoop
$sAction = __WinHttpHTMLDecode(__WinHttpAttribVal($sAttributes, "action"))
$sAccept = __WinHttpAttribVal($sAttributes, "accept")
$sEnctype = __WinHttpAttribVal($sAttributes, "enctype")
$sMethod = __WinHttpAttribVal($sAttributes, "method")
$fSend = True
Local $sSpr1 = Chr(27), $sSpr2 = Chr(26)
__WinHttpNormalizeForm($sForm, $sSpr1, $sSpr2)
$aInput = StringRegExp($sForm, "(?si)<\h*(?:input|textarea|label|fieldset|legend|select|optgroup|option|button)\h*(.*?)/*\h*>", 3)
If @error Then Return SetError(2, 0, "")
__WinHttpHTML5FormAttribs($aDtas, $aFlds, $iNumParams, $aInput, $sAction, $sEnctype, $sMethod)
__WinHttpNormalizeActionURL($sActionPage, $sAction, $iScheme, $sNewURL, $sEnctype, $sMethod, $sURL)
If $fVarForm And Not $sNewURL Then Return SetError(5, 0, "")
Local $aSplit, $sBoundary, $sPassedId, $sPassedData, $iNumRepl, $fMultiPart = False, $sSubmit, $sRadio, $sCheckBox, $sButton
Local $sGrSep = Chr(29), $iErr
Local $aInputIds[4][UBound($aInput)]
Switch $sEnctype
Case "", "application/x-www-form-urlencoded", "text/plain"
For $i = 0 To UBound($aInput) - 1
__WinHttpFormAttrib($aInputIds, $i, $aInput[$i])
If $aInputIds[1][$i] Then
$aInputIds[1][$i] = __WinHttpURLEncode(StringReplace($aInputIds[1][$i], $sSpr1, " "), $sEnctype)
$aInputIds[2][$i] = __WinHttpURLEncode(StringReplace(StringReplace($aInputIds[2][$i], $sSpr2, ">"), $sSpr1, " "), $sEnctype)
$sAddData &= $aInputIds[1][$i] & "=" & $aInputIds[2][$i] & "&"
If $aInputIds[3][$i] = "submit" Then $sSubmit &= $aInputIds[1][$i] & "=" & $aInputIds[2][$i] & $sGrSep
If $aInputIds[3][$i] = "radio" Then $sRadio &= $aInputIds[1][$i] & "=" & $aInputIds[2][$i] & $sGrSep
If $aInputIds[3][$i] = "checkbox" Then $sCheckBox &= $aInputIds[1][$i] & "=" & $aInputIds[2][$i] & $sGrSep
If $aInputIds[3][$i] = "button" Then $sButton &= $aInputIds[1][$i] & "=" & $aInputIds[2][$i] & $sGrSep
EndIf
Next
$sSubmit = StringTrimRight($sSubmit, 1)
$sRadio = StringTrimRight($sRadio, 1)
$sCheckBox = StringTrimRight($sCheckBox, 1)
$sButton = StringTrimRight($sButton, 1)
$sAddData = StringTrimRight($sAddData, 1)
For $k = 1 To $iNumParams
$sPassedData = __WinHttpURLEncode($aDtas[$k], $sEnctype)
$aDtas[$k] = 0
$sPassedId = $aFlds[$k]
$aFlds[$k] = 0
$aSplit = StringSplit($sPassedId, ":", 2)
$iErr = @error
$aSplit[0] = __WinHttpURLEncode($aSplit[0], $sEnctype)
If Not $iErr Then $aSplit[1] = __WinHttpURLEncode($aSplit[1], $sEnctype)
If $iErr Or $aSplit[0] <> "name" Then
If Not $iErr And $aSplit[0] = "id" Then $sPassedId = $aSplit[1]
For $j = 0 To UBound($aInputIds, 2) - 1
If $aInputIds[0][$j] = $sPassedId Then
If $aInputIds[3][$j] = "submit" Then
If $sPassedData = True Then
If $sSubmit Then
Local $fDelId = False
For $sChunkSub In StringSplit($sSubmit, $sGrSep, 3)
If $sChunkSub == $aInputIds[1][$j] & "=" & $aInputIds[2][$j] Then
If $fDelId Then $sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $sChunkSub & "\E(?:&|\Z)", "&", 1)
$fDelId = True
Else
$sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $sChunkSub & "\E(?:&|\Z)", "&")
EndIf
__WinHttpTrimBounds($sAddData, "&")
Next
$sSubmit = ""
EndIf
EndIf
ElseIf $aInputIds[3][$j] = "radio" Then
If $sPassedData = $aInputIds[2][$j] Then
For $sChunkSub In StringSplit($sRadio, $sGrSep, 3)
If $sChunkSub == $aInputIds[1][$j] & "=" & $sPassedData Then
$sAddData = StringRegExpReplace(StringReplace($sAddData, "&", "&&"), "(?:&|\A)\Q" & $aInputIds[1][$j] & "\E(.*?)(?:&|\Z)", "&")
$sAddData = StringReplace(StringReplace($sAddData, "&&", "&"), "&&", "&")
If StringLeft($sAddData, 1) = "&" Then $sAddData = StringTrimLeft($sAddData, 1)
$sAddData &= "&" & $sChunkSub
$sRadio = StringRegExpReplace(StringReplace($sRadio, $sGrSep, $sGrSep & $sGrSep), "(?:" & $sGrSep & "|\A)\Q" & $aInputIds[1][$j] & "\E(.*?)(?:" & $sGrSep & "|\Z)", $sGrSep)
$sRadio = StringReplace(StringReplace($sRadio, $sGrSep & $sGrSep, $sGrSep), $sGrSep & $sGrSep, $sGrSep)
EndIf
Next
EndIf
ElseIf $aInputIds[3][$j] = "checkbox" Then
$sCheckBox = StringRegExpReplace($sCheckBox, "\Q" & $aInputIds[1][$j] & "=" & $sPassedData & "\E" & $sGrSep & "*", "")
__WinHttpTrimBounds($sCheckBox, $sGrSep)
ElseIf $aInputIds[3][$j] = "button" Then
$sButton = StringRegExpReplace($sButton, "\Q" & $aInputIds[1][$j] & "=" & $sPassedData & "\E" & $sGrSep & "*", "")
__WinHttpTrimBounds($sButton, $sGrSep)
Else
$sAddData = StringRegExpReplace(StringReplace($sAddData, "&", "&&"), "(?:&|\A)\Q" & $aInputIds[1][$j] & "=" & $aInputIds[2][$j] & "\E(?:&|\Z)", "&" & $aInputIds[1][$j] & "=" & $sPassedData & "&")
$iNumRepl = @extended
$sAddData = StringReplace($sAddData, "&&", "&")
If $iNumRepl > 1 Then
$sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $aInputIds[1][$j] & "\E=.*?(?:&|\Z)", "&", $iNumRepl - 1)
EndIf
__WinHttpTrimBounds($sAddData, "&")
EndIf
EndIf
Next
Else
For $j = 0 To UBound($aInputIds, 2) - 1
If $aInputIds[3][$j] = "submit" Then
If $sPassedData = True Then
If $aInputIds[1][$j] == $aSplit[1] Then
If $sSubmit Then
Local $fDel = False
For $sChunkSub In StringSplit($sSubmit, $sGrSep, 3)
If $sChunkSub = $aInputIds[1][$j] & "=" & $aInputIds[2][$j] Then
If $fDel Then $sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $sChunkSub & "\E(?:&|\Z)", "&", 1)
$fDel = True
Else
$sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $sChunkSub & "\E(?:&|\Z)", "&")
EndIf
__WinHttpTrimBounds($sAddData, "&")
Next
$sSubmit = ""
EndIf
ContinueLoop 2
EndIf
Else
ContinueLoop 2
EndIf
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "radio" Then
For $sChunkSub In StringSplit($sRadio, $sGrSep, 3)
If $sChunkSub == $aInputIds[1][$j] & "=" & $sPassedData Then
$sAddData = StringReplace(StringReplace(StringRegExpReplace(StringReplace($sAddData, "&", "&&"), "(?:&|\A)\Q" & $aInputIds[1][$j] & "\E(.*?)(?:&|\Z)", "&"), "&&", "&"), "&&", "&")
If StringLeft($sAddData, 1) = "&" Then $sAddData = StringTrimLeft($sAddData, 1)
$sAddData &= "&" & $sChunkSub
$sRadio = StringRegExpReplace(StringReplace($sRadio, $sGrSep, $sGrSep & $sGrSep), "(?:" & $sGrSep & "|\A)\Q" & $aInputIds[1][$j] & "\E(.*?)(?:" & $sGrSep & "|\Z)", $sGrSep)
$sRadio = StringReplace(StringReplace($sRadio, $sGrSep & $sGrSep, $sGrSep), $sGrSep & $sGrSep, $sGrSep)
EndIf
Next
ContinueLoop 2
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "checkbox" Then
$sCheckBox = StringRegExpReplace($sCheckBox, "\Q" & $aInputIds[1][$j] & "=" & $sPassedData & "\E" & $sGrSep & "*", "")
__WinHttpTrimBounds($sCheckBox, $sGrSep)
ContinueLoop 2
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "button" Then
$sButton = StringRegExpReplace($sButton, "\Q" & $aInputIds[1][$j] & "=" & $sPassedData & "\E" & $sGrSep & "*", "")
__WinHttpTrimBounds($sButton, $sGrSep)
ContinueLoop 2
EndIf
Next
$sAddData = StringRegExpReplace(StringReplace($sAddData, "&", "&&"), "(?:&|\A)\Q" & $aSplit[1] & "\E=.*?(?:&|\Z)", "&" & $aSplit[1] & "=" & $sPassedData & "&")
$iNumRepl = @extended
$sAddData = StringReplace($sAddData, "&&", "&")
If $iNumRepl > 1 Then
$sAddData = StringRegExpReplace($sAddData, "(?:&|\A)\Q" & $aSplit[1] & "\E=.*?(?:&|\Z)", "&", $iNumRepl - 1)
EndIf
__WinHttpTrimBounds($sAddData, "&")
EndIf
Next
__WinHttpFinalizeCtrls($sSubmit, $sRadio, $sCheckBox, $sButton, $sAddData, $sGrSep, "&")
If $sMethod = "GET" Then
$sAction &= "?" & $sAddData
$sAddData = ""
EndIf
Case "multipart/form-data"
If $sMethod = "POST" Then
$fMultiPart = True
$sBoundary = StringFormat("%s%.5f", "----WinHttpBoundaryLine_", Random(10000, 99999))
Local $sCDisp = 'Content-Disposition: form-data; name="'
For $i = 0 To UBound($aInput) - 1
__WinHttpFormAttrib($aInputIds, $i, $aInput[$i])
If $aInputIds[1][$i] Then
$aInputIds[1][$i] = StringReplace($aInputIds[1][$i], $sSpr1, " ")
$aInputIds[2][$i] = StringReplace(StringReplace($aInputIds[2][$i], $sSpr2, ">"), $sSpr1, " ")
If $aInputIds[3][$i] = "file" Then
$sAddData &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"; filename=""' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF
Else
$sAddData &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF
EndIf
If $aInputIds[3][$i] = "submit" Then $sSubmit &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF & $sGrSep
If $aInputIds[3][$i] = "radio" Then $sRadio &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF & $sGrSep
If $aInputIds[3][$i] = "checkbox" Then $sCheckBox &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF & $sGrSep
If $aInputIds[3][$i] = "button" Then $sButton &= "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$i] & '"' & @CRLF & @CRLF &  $aInputIds[2][$i] & @CRLF & $sGrSep
EndIf
Next
$sSubmit = StringTrimRight($sSubmit, 1)
$sRadio = StringTrimRight($sRadio, 1)
$sCheckBox = StringTrimRight($sCheckBox, 1)
$sButton = StringTrimRight($sButton, 1)
$sAddData &= "--" & $sBoundary & "--" & @CRLF
For $k = 1 To $iNumParams
$sPassedData = $aDtas[$k]
$aDtas[$k] = 0
$sPassedId = $aFlds[$k]
$aFlds[$k] = 0
$aSplit = StringSplit($sPassedId, ":", 2)
If @error Or $aSplit[0] <> "name" Then
If Not @error And $aSplit[0] = "id" Then $sPassedId = $aSplit[1]
For $j = 0 To UBound($aInputIds, 2) - 1
If $aInputIds[0][$j] = $sPassedId Then
If $aInputIds[3][$j] = "file" Then
$sAddData = StringReplace($sAddData,  $sCDisp & $aInputIds[1][$j] & '"; filename=""' & @CRLF & @CRLF & $aInputIds[2][$j] & @CRLF,  __WinHttpFileContent($sAccept, $aInputIds[1][$j], $sPassedData, $sBoundary), 0, 1)
ElseIf $aInputIds[3][$j] = "submit" Then
If $sPassedData = True Then
If $sSubmit Then
Local $fMDelId = False
For $sChunkSub In StringSplit($sSubmit, $sGrSep, 3)
If $sChunkSub = "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $aInputIds[2][$j] & @CRLF Then
If $fMDelId Then $sAddData = StringReplace($sAddData, $sChunkSub, "", 1, 1)
$fMDelId = True
Else
$sAddData = StringReplace($sAddData, $sChunkSub, "", 0, 1)
EndIf
Next
$sSubmit = ""
EndIf
EndIf
ElseIf $aInputIds[3][$j] = "radio" Then
If $sPassedData = $aInputIds[2][$j] Then
For $sChunkSub In StringSplit($sRadio, $sGrSep, 3)
If StringInStr($sChunkSub, "--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & $sPassedData & @CRLF, 1) Then
$sAddData = StringRegExpReplace($sAddData, "\Q--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF, "")
$sAddData = StringReplace($sAddData, "--" & $sBoundary & "--" & @CRLF, "", 0, 1)
$sAddData &= $sChunkSub & "--" & $sBoundary & "--" & @CRLF
$sRadio = StringRegExpReplace($sRadio, "\Q--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $sGrSep & "?", "")
EndIf
Next
EndIf
ElseIf $aInputIds[3][$j] = "checkbox" Then
$sCheckBox = StringRegExpReplace($sCheckBox, "\Q--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $sPassedData & @CRLF & "\E" & $sGrSep & "*", "")
If StringRight($sCheckBox, 1) = $sGrSep Then $sCheckBox = StringTrimRight($sCheckBox, 1)
ElseIf $aInputIds[3][$j] = "button" Then
$sButton = StringRegExpReplace($sButton, "\Q--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $sPassedData & @CRLF & "\E" & $sGrSep & "*", "")
If StringRight($sButton, 1) = $sGrSep Then $sButton = StringTrimRight($sButton, 1)
Else
$sAddData = StringReplace($sAddData,  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & $aInputIds[2][$j] & @CRLF,  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & $sPassedData & @CRLF, 0, 1)
$iNumRepl = @extended
If $iNumRepl > 1 Then
$sAddData = StringRegExpReplace($sAddData, '(?s)\Q--' & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & '\E\r\n\r\n.*?\r\n', "", $iNumRepl - 1)
EndIf
EndIf
EndIf
Next
Else
For $j = 0 To UBound($aInputIds, 2) - 1
If $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "file" Then
$sAddData = StringReplace($sAddData,  $sCDisp & $aSplit[1] & '"; filename=""' & @CRLF & @CRLF & $aInputIds[2][$j] & @CRLF,  __WinHttpFileContent($sAccept, $aInputIds[1][$j], $sPassedData, $sBoundary), 0, 1)
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "submit" Then
If $sPassedData = True Then
If $sSubmit Then
Local $fMDel = False
For $sChunkSub In StringSplit($sSubmit, $sGrSep, 3)
If $sChunkSub = "--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $aInputIds[2][$j] & @CRLF Then
If $fMDel Then $sAddData = StringReplace($sAddData, $sChunkSub, "", 1, 1)
$fMDel = True
Else
$sAddData = StringReplace($sAddData, $sChunkSub, "", 0, 1)
EndIf
Next
$sSubmit = ""
EndIf
ContinueLoop 2
Else
ContinueLoop 2
EndIf
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "radio" Then
For $sChunkSub In StringSplit($sRadio, $sGrSep, 3)
If StringInStr($sChunkSub, "--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & $sPassedData & @CRLF, 1) Then
$sAddData = StringRegExpReplace($sAddData, "\Q--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & "\E" & "(.*?)" & @CRLF, "")
$sAddData = StringReplace($sAddData, "--" & $sBoundary & "--" & @CRLF, "", 0, 1)
$sAddData &= $sChunkSub & "--" & $sBoundary & "--" & @CRLF
$sRadio = StringRegExpReplace($sRadio, "\Q--" & $sBoundary & @CRLF & $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF & "\E(.*?)" & @CRLF & $sGrSep & "?", "")
EndIf
Next
ContinueLoop 2
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "checkbox" Then
$sCheckBox = StringRegExpReplace($sCheckBox, "\Q--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $sPassedData & @CRLF & "\E" & $sGrSep & "*", "")
If StringRight($sCheckBox, 1) = $sGrSep Then $sCheckBox = StringTrimRight($sCheckBox, 1)
ContinueLoop 2
ElseIf $aInputIds[1][$j] == $aSplit[1] And $aInputIds[3][$j] = "button" Then
$sButton = StringRegExpReplace($sButton, "\Q--" & $sBoundary & @CRLF &  $sCDisp & $aInputIds[1][$j] & '"' & @CRLF & @CRLF &  $sPassedData & @CRLF & "\E" & $sGrSep & "*", "")
If StringRight($sButton, 1) = $sGrSep Then $sButton = StringTrimRight($sButton, 1)
ContinueLoop 2
EndIf
Next
$sAddData = StringRegExpReplace($sAddData, '(?s)\Q' & $sCDisp & $aSplit[1] & '"' & '\E\r\n\r\n.*?\r\n',  $sCDisp & $aSplit[1] & '"' & @CRLF & @CRLF & StringReplace($sPassedData, "\", "\\") & @CRLF)
$iNumRepl = @extended
If $iNumRepl > 1 Then
$sAddData = StringRegExpReplace($sAddData, '(?s)\Q--' & $sBoundary & @CRLF & $sCDisp & $aSplit[1] & '"' & '\E\r\n\r\n.*?\r\n', "", $iNumRepl - 1)
EndIf
EndIf
Next
EndIf
__WinHttpFinalizeCtrls($sSubmit, $sRadio, $sCheckBox, $sButton, $sAddData, $sGrSep)
EndSwitch
ExitLoop
Next
If $fSend Then
If $fVarForm Then
$hInternet = _WinHttpConnect($hOpen, $sNewURL)
Else
If $sNewURL Then
$hOpen = _WinHttpQueryOption($hInternet, $WINHTTP_OPTION_PARENT_HANDLE)
_WinHttpCloseHandle($hInternet)
$hInternet = _WinHttpConnect($hOpen, $sNewURL)
EndIf
EndIf
Local $hRequest
If $iScheme = $INTERNET_SCHEME_HTTPS Then
$hRequest = __WinHttpFormSend($hInternet, $sMethod, $sAction, $fMultiPart, $sBoundary, $sAddData, True, $sAdditionalHeaders, $sCredName, $sCredPass, $iIgnoreCertErr)
Else
$hRequest = __WinHttpFormSend($hInternet, $sMethod, $sAction, $fMultiPart, $sBoundary, $sAddData, False, $sAdditionalHeaders, $sCredName, $sCredPass)
If _WinHttpQueryHeaders($hRequest, $WINHTTP_QUERY_STATUS_CODE) >= $HTTP_STATUS_BAD_REQUEST Then
_WinHttpCloseHandle($hRequest)
$hRequest = __WinHttpFormSend($hInternet, $sMethod, $sAction, $fMultiPart, $sBoundary, $sAddData, True, $sAdditionalHeaders, $sCredName, $sCredPass, $iIgnoreCertErr)
EndIf
EndIf
Local $vReturned = _WinHttpSimpleReadData($hRequest)
If @error Then
_WinHttpCloseHandle($hRequest)
Return SetError(4, 0, "")
EndIf
Local $iSCode = _WinHttpQueryHeaders($hRequest, $WINHTTP_QUERY_STATUS_CODE)
If $iRetArr Then
Local $aReturn[3] = [_WinHttpQueryHeaders($hRequest), $vReturned, _WinHttpQueryOption($hRequest, $WINHTTP_OPTION_URL)]
$vReturned = $aReturn
EndIf
_WinHttpCloseHandle($hRequest)
Return SetExtended($iSCode, $vReturned)
EndIf
Return SetError(3, 0, "")
EndFunc
Func _WinHttpSimpleFormFill_SetUploadCallback($vCallback = Default, $iNumChunks = 100)
If $iNumChunks <= 0 Then $iNumChunks = 100
Local Static $vFunc = Default, $iParts = $iNumChunks
If $vCallback <> Default Then
$vFunc = $vCallback
$iParts = Ceiling($iNumChunks)
ElseIf $vCallback = 0 Then
$vFunc = Default
$iParts = 1
EndIf
Local $aOut[2] = [$vFunc, $iParts]
Return $aOut
EndFunc
Func _WinHttpSimpleReadData($hRequest, $iMode = Default)
If $iMode = Default Then
$iMode = 0
If __WinHttpCharSet(_WinHttpQueryHeaders($hRequest, $WINHTTP_QUERY_CONTENT_TYPE)) = 65001 Then $iMode = 1
Else
__WinHttpDefault($iMode, 0)
EndIf
If $iMode > 2 Or $iMode < 0 Then Return SetError(1, 0, '')
Local $vData = Binary('')
If _WinHttpQueryDataAvailable($hRequest) Then
Do
$vData &= _WinHttpReadData($hRequest, 2)
Until @error
Switch $iMode
Case 0
Return BinaryToString($vData)
Case 1
Return BinaryToString($vData, 4)
Case Else
Return $vData
EndSwitch
EndIf
Return SetError(2, 0, $vData)
EndFunc
Func _WinHttpSimpleReadDataAsync($hInternet, ByRef $pBuffer, $iNumberOfBytesToRead = Default)
__WinHttpDefault($iNumberOfBytesToRead, 8192)
Local $vOut = _WinHttpReadData($hInternet, 2, $iNumberOfBytesToRead, $pBuffer)
Return SetError(@error, @extended, $vOut)
EndFunc
Func _WinHttpSimpleRequest($hConnect, $sType = Default, $sPath = Default, $sReferrer = Default, $sDta = Default, $sHeader = Default, $fGetHeaders = Default, $iMode = Default, $sCredName = Default, $sCredPass = Default)
__WinHttpDefault($sType, "GET")
__WinHttpDefault($sPath, "")
__WinHttpDefault($sReferrer, $WINHTTP_NO_REFERER)
__WinHttpDefault($sDta, $WINHTTP_NO_REQUEST_DATA)
__WinHttpDefault($sHeader, $WINHTTP_NO_ADDITIONAL_HEADERS)
__WinHttpDefault($fGetHeaders, False)
__WinHttpDefault($iMode, Default)
__WinHttpDefault($sCredName, "")
__WinHttpDefault($sCredPass, "")
If $iMode > 2 Or $iMode < 0 Then Return SetError(4, 0, 0)
Local $hRequest = _WinHttpSimpleSendRequest($hConnect, $sType, $sPath, $sReferrer, $sDta, $sHeader)
If @error Then Return SetError(@error, 0, 0)
__WinHttpSetCredentials($hRequest, $sHeader, $sDta, $sCredName, $sCredPass)
Local $iExtended = _WinHttpQueryHeaders($hRequest, $WINHTTP_QUERY_STATUS_CODE)
If $fGetHeaders Then
Local $aData[3] = [_WinHttpQueryHeaders($hRequest), _WinHttpSimpleReadData($hRequest, $iMode), _WinHttpQueryOption($hRequest, $WINHTTP_OPTION_URL)]
_WinHttpCloseHandle($hRequest)
Return SetExtended($iExtended, $aData)
EndIf
Local $sOutData = _WinHttpSimpleReadData($hRequest, $iMode)
_WinHttpCloseHandle($hRequest)
Return SetExtended($iExtended, $sOutData)
EndFunc
Func _WinHttpSimpleSendRequest($hConnect, $sType = Default, $sPath = Default, $sReferrer = Default, $sDta = Default, $sHeader = Default)
__WinHttpDefault($sType, "GET")
__WinHttpDefault($sPath, "")
__WinHttpDefault($sReferrer, $WINHTTP_NO_REFERER)
__WinHttpDefault($sDta, $WINHTTP_NO_REQUEST_DATA)
__WinHttpDefault($sHeader, $WINHTTP_NO_ADDITIONAL_HEADERS)
Local $hRequest = _WinHttpOpenRequest($hConnect, $sType, $sPath, Default, $sReferrer)
If Not $hRequest Then Return SetError(1, @error, 0)
If $sType = "POST" And $sHeader = $WINHTTP_NO_ADDITIONAL_HEADERS Then $sHeader = "Content-Type: application/x-www-form-urlencoded" & @CRLF
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_DECOMPRESSION, $WINHTTP_DECOMPRESSION_FLAG_ALL)
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_UNSAFE_HEADER_PARSING, 1)
_WinHttpSendRequest($hRequest, $sHeader, $sDta)
If @error Then Return SetError(2, 0 * _WinHttpCloseHandle($hRequest), 0)
_WinHttpReceiveResponse($hRequest)
If @error Then Return SetError(3, 0 * _WinHttpCloseHandle($hRequest), 0)
Return $hRequest
EndFunc
Func _WinHttpSimpleSendSSLRequest($hConnect, $sType = Default, $sPath = Default, $sReferrer = Default, $sDta = Default, $sHeader = Default, $iIgnoreAllCertErrors = 0)
__WinHttpDefault($sType, "GET")
__WinHttpDefault($sPath, "")
__WinHttpDefault($sReferrer, $WINHTTP_NO_REFERER)
__WinHttpDefault($sDta, $WINHTTP_NO_REQUEST_DATA)
__WinHttpDefault($sHeader, $WINHTTP_NO_ADDITIONAL_HEADERS)
Local $hRequest = _WinHttpOpenRequest($hConnect, $sType, $sPath, Default, $sReferrer, Default, BitOR($WINHTTP_FLAG_SECURE, $WINHTTP_FLAG_ESCAPE_DISABLE))
If Not $hRequest Then Return SetError(1, @error, 0)
If $iIgnoreAllCertErrors Then _WinHttpSetOption($hRequest, $WINHTTP_OPTION_SECURITY_FLAGS, BitOR($SECURITY_FLAG_IGNORE_UNKNOWN_CA, $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID, $SECURITY_FLAG_IGNORE_CERT_CN_INVALID, $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE))
If $sType = "POST" And $sHeader = $WINHTTP_NO_ADDITIONAL_HEADERS Then $sHeader = "Content-Type: application/x-www-form-urlencoded" & @CRLF
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_DECOMPRESSION, $WINHTTP_DECOMPRESSION_FLAG_ALL)
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_UNSAFE_HEADER_PARSING, 1)
_WinHttpSendRequest($hRequest, $sHeader, $sDta)
If @error Then Return SetError(2, 0 * _WinHttpCloseHandle($hRequest), 0)
_WinHttpReceiveResponse($hRequest)
If @error Then Return SetError(3, 0 * _WinHttpCloseHandle($hRequest), 0)
Return $hRequest
EndFunc
Func _WinHttpSimpleSSLRequest($hConnect, $sType = Default, $sPath = Default, $sReferrer = Default, $sDta = Default, $sHeader = Default, $fGetHeaders = Default, $iMode = Default, $sCredName = Default, $sCredPass = Default, $iIgnoreCertErrors = 0)
__WinHttpDefault($sType, "GET")
__WinHttpDefault($sPath, "")
__WinHttpDefault($sReferrer, $WINHTTP_NO_REFERER)
__WinHttpDefault($sDta, $WINHTTP_NO_REQUEST_DATA)
__WinHttpDefault($sHeader, $WINHTTP_NO_ADDITIONAL_HEADERS)
__WinHttpDefault($fGetHeaders, False)
__WinHttpDefault($iMode, Default)
__WinHttpDefault($sCredName, "")
__WinHttpDefault($sCredPass, "")
If $iMode > 2 Or $iMode < 0 Then Return SetError(4, 0, 0)
Local $hRequest = _WinHttpSimpleSendSSLRequest($hConnect, $sType, $sPath, $sReferrer, $sDta, $sHeader, $iIgnoreCertErrors)
If @error Then Return SetError(@error, 0, 0)
__WinHttpSetCredentials($hRequest, $sHeader, $sDta, $sCredName, $sCredPass)
If $fGetHeaders Then
Local $aData[3] = [_WinHttpQueryHeaders($hRequest), _WinHttpSimpleReadData($hRequest, $iMode), _WinHttpQueryOption($hRequest, $WINHTTP_OPTION_URL)]
_WinHttpCloseHandle($hRequest)
Return $aData
EndIf
Local $sOutData = _WinHttpSimpleReadData($hRequest, $iMode)
_WinHttpCloseHandle($hRequest)
Return $sOutData
EndFunc
Func _WinHttpTimeFromSystemTime()
Local $SYSTEMTIME = DllStructCreate("word Year;" &  "word Month;" &  "word DayOfWeek;" &  "word Day;" &  "word Hour;" &  "word Minute;" &  "word Second;" &  "word Milliseconds")
DllCall("kernel32.dll", "none", "GetSystemTime", "struct*", $SYSTEMTIME)
If @error Then Return SetError(1, 0, "")
Local $tTime = DllStructCreate("wchar[62]")
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpTimeFromSystemTime", "struct*", $SYSTEMTIME, "struct*", $tTime)
If @error Or Not $aCall[0] Then Return SetError(2, 0, "")
Return DllStructGetData($tTime, 1)
EndFunc
Func _WinHttpTimeToSystemTime($sHttpTime)
Local $SYSTEMTIME = DllStructCreate("word Year;" &  "word Month;" &  "word DayOfWeek;" &  "word Day;" &  "word Hour;" &  "word Minute;" &  "word Second;" &  "word Milliseconds")
Local $tTime = DllStructCreate("wchar[62]")
DllStructSetData($tTime, 1, $sHttpTime)
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpTimeToSystemTime", "struct*", $tTime, "struct*", $SYSTEMTIME)
If @error Or Not $aCall[0] Then Return SetError(2, 0, 0)
Local $aRet[8] = [DllStructGetData($SYSTEMTIME, "Year"),  DllStructGetData($SYSTEMTIME, "Month"),  DllStructGetData($SYSTEMTIME, "DayOfWeek"),  DllStructGetData($SYSTEMTIME, "Day"),  DllStructGetData($SYSTEMTIME, "Hour"),  DllStructGetData($SYSTEMTIME, "Minute"),  DllStructGetData($SYSTEMTIME, "Second"),  DllStructGetData($SYSTEMTIME, "Milliseconds")]
Return $aRet
EndFunc
Func _WinHttpWriteData($hRequest, $vData, $iMode = Default)
__WinHttpDefault($iMode, 0)
Local $iNumberOfBytesToWrite, $tData
If $iMode = 1 Then
$iNumberOfBytesToWrite = BinaryLen($vData)
$tData = DllStructCreate("byte[" & $iNumberOfBytesToWrite & "]")
DllStructSetData($tData, 1, $vData)
ElseIf IsDllStruct($vData) Then
$iNumberOfBytesToWrite = DllStructGetSize($vData)
$tData = $vData
Else
$iNumberOfBytesToWrite = StringLen($vData)
$tData = DllStructCreate("char[" & $iNumberOfBytesToWrite + 1 & "]")
DllStructSetData($tData, 1, $vData)
EndIf
Local $aCall = DllCall($hWINHTTPDLL__WINHTTP, "bool", "WinHttpWriteData",  "handle", $hRequest,  "struct*", $tData,  "dword", $iNumberOfBytesToWrite,  "dword*", 0)
If @error Or Not $aCall[0] Then Return SetError(1, 0, 0)
Return SetExtended($aCall[4], 1)
EndFunc
Func __WinHttpFileContent($sAccept, $sName, $sFileString, $sBoundaryMain = "")
#forceref $sAccept
Local $fNonStandard = False
If StringLeft($sFileString, 10) = "PHP#50338:" Then
$sFileString = StringTrimLeft($sFileString, 10)
$fNonStandard = True
EndIf
Local $sOut = 'Content-Disposition: form-data; name="' & $sName & '"'
If Not $sFileString Then Return $sOut & '; filename=""' & @CRLF & @CRLF & @CRLF
If StringRight($sFileString, 1) = "|" Then $sFileString = StringTrimRight($sFileString, 1)
Local $aFiles = StringSplit($sFileString, "|", 2), $hFile
If UBound($aFiles) = 1 Then
$hFile = FileOpen($aFiles[0], 16)
$sOut &= '; filename="' & StringRegExpReplace($aFiles[0], ".*\\", "") & '"' & @CRLF &  "Content-Type: " & __WinHttpMIMEType($aFiles[0]) & @CRLF & @CRLF & BinaryToString(FileRead($hFile), 1) & @CRLF
FileClose($hFile)
Return $sOut
EndIf
If $fNonStandard Then
$sOut = ""
Local $iFiles = UBound($aFiles)
For $i = 0 To $iFiles - 1
$hFile = FileOpen($aFiles[$i], 16)
$sOut &= 'Content-Disposition: form-data; name="' & $sName & '"' &  '; filename="' & StringRegExpReplace($aFiles[$i], ".*\\", "") & '"' & @CRLF &  "Content-Type: " & __WinHttpMIMEType($aFiles[$i]) & @CRLF & @CRLF & BinaryToString(FileRead($hFile), 1) & @CRLF
FileClose($hFile)
If $i < $iFiles - 1 Then $sOut &= "--" & $sBoundaryMain & @CRLF
Next
Else
Local $sBoundary = StringFormat("%s%.5f", "----WinHttpSubBoundaryLine_", Random(10000, 99999))
$sOut &= @CRLF & "Content-Type: multipart/mixed; boundary=" & $sBoundary & @CRLF & @CRLF
For $i = 0 To UBound($aFiles) - 1
$hFile = FileOpen($aFiles[$i], 16)
$sOut &= "--" & $sBoundary & @CRLF &  'Content-Disposition: file; filename="' & StringRegExpReplace($aFiles[$i], ".*\\", "") & '"' & @CRLF &  "Content-Type: " & __WinHttpMIMEType($aFiles[$i]) & @CRLF & @CRLF & BinaryToString(FileRead($hFile), 1) & @CRLF
FileClose($hFile)
Next
$sOut &= "--" & $sBoundary & "--" & @CRLF
EndIf
Return $sOut
EndFunc
Func __WinHttpMIMEType($sFileName)
Local $aArray = StringRegExp(__WinHttpMIMEAssocString(), "(?i)\Q;" & StringRegExpReplace($sFileName, ".*\.", "") & "\E\|(.*?);", 3)
If @error Then Return "application/octet-stream"
Return $aArray[0]
EndFunc
Func __WinHttpMIMEAssocString()
Return ";ai|application/postscript;aif|audio/x-aiff;aifc|audio/x-aiff;aiff|audio/x-aiff;asc|text/plain;atom|application/atom+xml;au|audio/basic;avi|video/x-msvideo;bcpio|application/x-bcpio;bin|application/octet-stream;bmp|image/bmp;cdf|application/x-netcdf;cgm|image/cgm;class|application/octet-stream;cpio|application/x-cpio;cpt|application/mac-compactpro;csh|application/x-csh;css|text/css;dcr|application/x-director;dif|video/x-dv;dir|application/x-director;djv|image/vnd.djvu;djvu|image/vnd.djvu;dll|application/octet-stream;dmg|application/octet-stream;dms|application/octet-stream;doc|application/msword;dtd|application/xml-dtd;dv|video/x-dv;dvi|application/x-dvi;dxr|application/x-director;eps|application/postscript;etx|text/x-setext;exe|application/octet-stream;ez|application/andrew-inset;gif|image/gif;gram|application/srgs;grxml|application/srgs+xml;gtar|application/x-gtar;hdf|application/x-hdf;hqx|application/mac-binhex40;htm|text/html;html|text/html;ice|x-conference/x-cooltalk;ico|image/x-icon;ics|text/calendar;ief|image/ief;ifb|text/calendar;iges|model/iges;igs|model/iges;jnlp|application/x-java-jnlp-file;jp2|image/jp2;jpe|image/jpeg;jpeg|image/jpeg;jpg|image/jpeg;js|application/x-javascript;kar|audio/midi;latex|application/x-latex;lha|application/octet-stream;lzh|application/octet-stream;m3u|audio/x-mpegurl;m4a|audio/mp4a-latm;m4b|audio/mp4a-latm;m4p|audio/mp4a-latm;m4u|video/vnd.mpegurl;m4v|video/x-m4v;mac|image/x-macpaint;man|application/x-troff-man;mathml|application/mathml+xml;me|application/x-troff-me;mesh|model/mesh;mid|audio/midi;midi|audio/midi;mif|application/vnd.mif;mov|video/quicktime;movie|video/x-sgi-movie;mp2|audio/mpeg;mp3|audio/mpeg;mp4|video/mp4;mpe|video/mpeg;mpeg|video/mpeg;mpg|video/mpeg;mpga|audio/mpeg;ms|application/x-troff-ms;msh|model/mesh;mxu|video/vnd.mpegurl;nc|application/x-netcdf;oda|application/oda;ogg|application/ogg;pbm|image/x-portable-bitmap;pct|image/pict;pdb|chemical/x-pdb;pdf|application/pdf;pgm|image/x-portable-graymap;pgn|application/x-chess-pgn;pic|image/pict;pict|image/pict;png|image/png;pnm|image/x-portable-anymap;pnt|image/x-macpaint;pntg|image/x-macpaint;ppm|image/x-portable-pixmap;ppt|application/vnd.ms-powerpoint;ps|application/postscript;qt|video/quicktime;qti|image/x-quicktime;qtif|image/x-quicktime;ra|audio/x-pn-realaudio;ram|audio/x-pn-realaudio;ras|image/x-cmu-raster;rdf|application/rdf+xml;rgb|image/x-rgb;rm|application/vnd.rn-realmedia;roff|application/x-troff;rtf|text/rtf;rtx|text/richtext;sgm|text/sgml;sgml|text/sgml;sh|application/x-sh;shar|application/x-shar;silo|model/mesh;sit|application/x-stuffit;skd|application/x-koan;skm|application/x-koan;skp|application/x-koan;skt|application/x-koan;smi|application/smil;smil|application/smil;snd|audio/basic;so|application/octet-stream;spl|application/x-futuresplash;src|application/x-wais-source;sv4cpio|application/x-sv4cpio;sv4crc|application/x-sv4crc;svg|image/svg+xml;swf|application/x-shockwave-flash;t|application/x-troff;tar|application/x-tar;tcl|application/x-tcl;tex|application/x-tex;texi|application/x-texinfo;texinfo|application/x-texinfo;tif|image/tiff;tiff|image/tiff;tr|application/x-troff;tsv|text/tab-separated-values;txt|text/plain;ustar|application/x-ustar;vcd|application/x-cdlink;vrml|model/vrml;vxml|application/voicexml+xml;wav|audio/x-wav;wbmp|image/vnd.wap.wbmp;wbmxl|application/vnd.wap.wbxml;wml|text/vnd.wap.wml;wmlc|application/vnd.wap.wmlc;wmls|text/vnd.wap.wmlscript;wmlsc|application/vnd.wap.wmlscriptc;wrl|model/vrml;xbm|image/x-xbitmap;xht|application/xhtml+xml;xhtml|application/xhtml+xml;xls|application/vnd.ms-excel;xml|application/xml;xpm|image/x-xpixmap;xsl|application/xml;xslt|application/xslt+xml;xul|application/vnd.mozilla.xul+xml;xwd|image/x-xwindowdump;xyz|chemical/x-xyz;zip|application/zip;"
EndFunc
Func __WinHttpCharSet($sContentType)
Local $aContentType = StringRegExp($sContentType, "(?i).*?\Qcharset=\E(?U)([^ ]+)(;| |\Z)", 2)
If Not @error Then $sContentType = $aContentType[1]
If StringLeft($sContentType, 2) = "cp" Then Return Int(StringTrimLeft($sContentType, 2))
If $sContentType = "utf-8" Then Return 65001
EndFunc
Func __WinHttpURLEncode($vData, $sEncType = "")
If IsBool($vData) Then Return $vData
$vData = __WinHttpHTMLDecode($vData)
If $sEnctype = "text/plain" Then Return StringReplace($vData, " ", "+")
Local $aData = StringToASCIIArray($vData, Default, Default, 2)
Local $sOut
For $i = 0 To UBound($aData) - 1
Switch $aData[$i]
Case 45, 46, 48 To 57, 65 To 90, 95, 97 To 122, 126
$sOut &= Chr($aData[$i])
Case 32
$sOut &= "+"
Case Else
$sOut &= "%" & Hex($aData[$i], 2)
EndSwitch
Next
Return $sOut
EndFunc
Func __WinHttpHTMLDecode($vData)
Return StringReplace(StringReplace(StringReplace(StringReplace($vData, "&amp;", "&"), "&lt;", "<"), "&gt;", ">"), "&quot;", '"')
EndFunc
Func __WinHttpNormalizeActionURL($sActionPage, ByRef $sAction, ByRef $iScheme, ByRef $sNewURL, ByRef $sEnctype, ByRef $sMethod, $sURL = "")
Local $aCrackURL = _WinHttpCrackUrl($sAction)
If @error Then
If $sAction Then
If StringLeft($sAction, 2) = "//" Then
$aCrackURL = _WinHttpCrackUrl($sURL)
If Not @error Then
$aCrackURL = _WinHttpCrackUrl($aCrackURL[0] & ":" & $sAction)
If Not @error Then
$sNewURL = $aCrackURL[0] & "://" & $aCrackURL[2] & ":" & $aCrackURL[3]
$iScheme = $aCrackURL[1]
$sAction = $aCrackURL[6] & $aCrackURL[7]
$sActionPage = ""
EndIf
EndIf
ElseIf StringLeft($sAction, 1) = "?" Then
$aCrackURL = _WinHttpCrackUrl($sURL)
$sAction = $aCrackURL[6] & $sAction
ElseIf StringLeft($sAction, 1) = "#" Then
$sAction = StringReplace($sActionPage, StringRegExpReplace($sActionPage, "(.*?)(#.*?)", "$2"), $sAction)
ElseIf StringLeft($sAction, 1) <> "/" Then
Local $sCurrent
Local $aURL = StringRegExp($sActionPage, '(.*)/', 3)
If Not @error Then $sCurrent = $aURL[0]
If $sCurrent Then $sAction = $sCurrent & "/" & $sAction
EndIf
If StringLeft($sAction, 1) = "?" Then $sAction = $sActionPage & $sAction
EndIf
If Not $sAction Then $sAction = $sActionPage
$sAction = StringRegExpReplace($sAction, "\A(/*\.\./)*", "")
Else
$iScheme = $aCrackURL[1]
$sNewURL = $aCrackURL[0] & "://" & $aCrackURL[2] & ":" & $aCrackURL[3]
$sAction = $aCrackURL[6] & $aCrackURL[7]
EndIf
If Not $sMethod Then $sMethod = "GET"
If $sMethod = "GET" Then $sEnctype = ""
EndFunc
Func __WinHttpHTML5FormAttribs(ByRef $aDtas, ByRef $aFlds, ByRef $iNumParams, ByRef $aInput, ByRef $sAction, ByRef $sEnctype, ByRef $sMethod)
Local $aSpl, $iSubmitHTML5 = 0, $iInpSubm, $sImgAppx = "."
For $k = 1 To $iNumParams
$aSpl = StringSplit($aFlds[$k], ":", 2)
If $aSpl[0] = "type" And ($aSpl[1] = "submit" Or $aSpl[1] = "image") Then
Local $iSubmIndex = $aDtas[$k], $iSubmCur = 0, $iImgCur = 0, $sType, $sInpNme
If $aSpl[1] = "image" Then
$iSubmIndex = Int($aDtas[$k])
EndIf
For $i = 0 To UBound($aInput) - 1
Switch __WinHttpAttribVal($aInput[$i], "type")
Case "submit"
If $iSubmCur = $iSubmIndex Then
$iSubmitHTML5 = 1
$iInpSubm = $i
ExitLoop 2
EndIf
$iSubmCur += 1
Case "image"
If $iImgCur = $iSubmIndex Then
$iSubmitHTML5 = 1
$iInpSubm = $i
$sInpNme = __WinHttpAttribVal($aInput[$iInpSubm], "name")
If $sInpNme Then $sInpNme &= $sImgAppx
$aInput[$iInpSubm] = 'type="image" formaction="' & __WinHttpAttribVal($aInput[$iInpSubm], "formaction") & '" formenctype="' & __WinHttpAttribVal($aInput[$iInpSubm], "formenctype") & '" formmethod="' & __WinHttpAttribVal($aInput[$iInpSubm], "formmethod") & '"'
Local $iX = 0, $iY = 0
$iX = Int(StringRegExpReplace($aDtas[$k], "(\d+)\h*(\d+),(\d+)", "$2", 1))
$iY = Int(StringRegExpReplace($aDtas[$k], "(\d+)\h*(\d+),(\d+)", "$3", 1))
ReDim $aInput[UBound($aInput) + 2]
$aInput[UBound($aInput) - 2] = 'type="image" name="' & $sInpNme & 'x" value="' & $iX & '"'
$aInput[UBound($aInput) - 1] = 'type="image" name="' & $sInpNme & 'y" value="' & $iY & '"'
ExitLoop 2
EndIf
$iImgCur += 1
EndSwitch
Next
ElseIf $aSpl[0] = "name" Then
Local $sInpNme = $aSpl[1], $sType
For $i = 0 To UBound($aInput) - 1
$sType = __WinHttpAttribVal($aInput[$i], "type")
If $sType = "submit" Then
If __WinHttpAttribVal($aInput[$i], "name") = $sInpNme And $aDtas[$k] = True Then
$iSubmitHTML5 = 1
$iInpSubm = $i
ExitLoop 2
EndIf
ElseIf $sType = "image" Then
If __WinHttpAttribVal($aInput[$i], "name") = $sInpNme And $aDtas[$k] Then
$iSubmitHTML5 = 1
$iInpSubm = $i
Local $aStrSplit = StringSplit($aDtas[$k], ",", 3), $iX = 0, $iY = 0
If Not @error Then
$iX = Int($aStrSplit[0])
$iY = Int($aStrSplit[1])
EndIf
$aInput[$iInpSubm] = 'type="image" formaction="' & __WinHttpAttribVal($aInput[$iInpSubm], "formaction") & '" formenctype="' & __WinHttpAttribVal($aInput[$iInpSubm], "formenctype") & '" formmethod="' & __WinHttpAttribVal($aInput[$iInpSubm], "formmethod") & '"'
$sInpNme &= $sImgAppx
ReDim $aInput[UBound($aInput) + 2]
$aInput[UBound($aInput) - 2] = 'type="image" name="' & $sInpNme & 'x" value="' & $iX & '"'
$aInput[UBound($aInput) - 1] = 'type="image" name="' & $sInpNme & 'y" value="' & $iY & '"'
ExitLoop 2
EndIf
EndIf
Next
Else
Local $sInpId, $sType
If @error Then
$sInpId = $aSpl[0]
ElseIf $aSpl[0] = "id" Then
$sInpId = $aSpl[1]
EndIf
For $i = 0 To UBound($aInput) - 1
$sType = __WinHttpAttribVal($aInput[$i], "type")
If $sType = "submit" Then
If __WinHttpAttribVal($aInput[$i], "id") = $sInpId And $aDtas[$k] = True Then
$iSubmitHTML5 = 1
$iInpSubm = $i
ExitLoop 2
EndIf
ElseIf $sType = "image" Then
If __WinHttpAttribVal($aInput[$i], "id") = $sInpId And $aDtas[$k] Then
$iSubmitHTML5 = 1
$iInpSubm = $i
Local $sInpNme = __WinHttpAttribVal($aInput[$iInpSubm], "name")
If $sInpNme Then $sInpNme &= $sImgAppx
Local $aStrSplit = StringSplit($aDtas[$k], ",", 3), $iX = 0, $iY = 0
If Not @error Then
$iX = Int($aStrSplit[0])
$iY = Int($aStrSplit[1])
EndIf
$aInput[$iInpSubm] = 'type="image" formaction="' & __WinHttpAttribVal($aInput[$iInpSubm], "formaction") & '" formenctype="' & __WinHttpAttribVal($aInput[$iInpSubm], "formenctype") & '" formmethod="' & __WinHttpAttribVal($aInput[$iInpSubm], "formmethod") & '"'
ReDim $aInput[UBound($aInput) + 2]
$aInput[UBound($aInput) - 2] = 'type="image" name="' & $sInpNme & 'x" value="' & $iX & '"'
$aInput[UBound($aInput) - 1] = 'type="image" name="' & $sInpNme & 'y" value="' & $iY & '"'
ExitLoop 2
EndIf
EndIf
Next
EndIf
Next
If $iSubmitHTML5 Then
Local $iUbound = UBound($aInput) - 1
If __WinHttpAttribVal($aInput[$iInpSubm], "type") = "image" Then $iUbound -= 2
For $j = 0 To $iUbound
If $j = $iInpSubm Then ContinueLoop
Switch __WinHttpAttribVal($aInput[$j], "type")
Case "submit", "image"
$aInput[$j] = ""
EndSwitch
Next
Local $sAttr = __WinHttpAttribVal($aInput[$iInpSubm], "formaction")
If $sAttr Then $sAction = $sAttr
$sAttr = __WinHttpAttribVal($aInput[$iInpSubm], "formenctype")
If $sAttr Then $sEnctype = $sAttr
$sAttr = __WinHttpAttribVal($aInput[$iInpSubm], "formmethod")
If $sAttr Then $sMethod = $sAttr
If __WinHttpAttribVal($aInput[$iInpSubm], "type") = "image" Then $aInput[$iInpSubm] = ""
EndIf
EndFunc
Func __WinHttpNormalizeForm(ByRef $sForm, $sSpr1, $sSpr2)
Local $aData = StringToASCIIArray($sForm, Default, Default, 2)
Local $sOut, $bQuot = False, $bSQuot = False, $bOpTg = True
For $i = 0 To UBound($aData) - 1
Switch $aData[$i]
Case 34
If $bOpTg Then $bQuot = Not $bQuot
$sOut &= Chr($aData[$i])
Case 39
If $bOpTg Then $bSQuot = Not $bSQuot
$sOut &= Chr($aData[$i])
Case 32
If $bQuot Or $bSQuot Then
$sOut &= $sSpr1
Else
$sOut &= Chr($aData[$i])
EndIf
Case 60
If Not $bOpTg Then $bOpTg = True
$sOut &= Chr($aData[$i])
Case 62
If $bQuot Or $bSQuot Then
$sOut &= $sSpr2
Else
If $bOpTg Then $bOpTg = False
$sOut &= Chr($aData[$i])
EndIf
Case Else
$sOut &= Chr($aData[$i])
EndSwitch
Next
$sForm = $sOut
EndFunc
Func __WinHttpFinalizeCtrls($sSubmit, $sRadio, $sCheckBox, $sButton, ByRef $sAddData, $sGrSep, $sBound = "")
If $sSubmit Then
Local $aSubmit = StringSplit($sSubmit, $sGrSep, 3)
For $m = 1 To UBound($aSubmit) - 1
$sAddData = StringRegExpReplace($sAddData, "(?:\Q" & $sBound & "\E|\A)\Q" & $aSubmit[$m] & "\E(?:\Q" & $sBound & "\E|\z)", $sBound)
Next
__WinHttpTrimBounds($sAddData, $sBound)
EndIf
If $sRadio Then
If $sRadio <> $sGrSep Then
For $sElem In StringSplit($sRadio, $sGrSep, 3)
$sAddData = StringRegExpReplace($sAddData, "(?:\Q" & $sBound & "\E|\A)\Q" & $sElem & "\E(?:\Q" & $sBound & "\E|\z)", $sBound)
Next
__WinHttpTrimBounds($sAddData, $sBound)
EndIf
EndIf
If $sCheckBox Then
For $sElem In StringSplit($sCheckBox, $sGrSep, 3)
$sAddData = StringRegExpReplace($sAddData, "(?:\Q" & $sBound & "\E|\A)\Q" & $sElem & "\E(?:\Q" & $sBound & "\E|\z)", $sBound)
Next
__WinHttpTrimBounds($sAddData, $sBound)
EndIf
If $sButton Then
For $sElem In StringSplit($sButton, $sGrSep, 3)
$sAddData = StringRegExpReplace($sAddData, "(?:\Q" & $sBound & "\E|\A)\Q" & $sElem & "\E(?:\Q" & $sBound & "\E|\z)", $sBound)
Next
__WinHttpTrimBounds($sAddData, $sBound)
EndIf
EndFunc
Func __WinHttpTrimBounds(ByRef $sDta, $sBound)
Local $iBLen = StringLen($sBound)
If StringRight($sDta, $iBLen) = $sBound Then $sDta = StringTrimRight($sDta, $iBLen)
If StringLeft($sDta, $iBLen) = $sBound Then $sDta = StringTrimLeft($sDta, $iBLen)
EndFunc
Func __WinHttpFormAttrib(ByRef $aAttrib, $i, $sElement)
$aAttrib[0][$i] = __WinHttpAttribVal($sElement, "id")
$aAttrib[1][$i] = __WinHttpAttribVal($sElement, "name")
$aAttrib[2][$i] = __WinHttpAttribVal($sElement, "value")
$aAttrib[3][$i] = __WinHttpAttribVal($sElement, "type")
EndFunc
Func __WinHttpAttribVal($sIn, $sAttrib)
Local $aArray = StringRegExp($sIn, '(?i).*?(\A| )\b' & $sAttrib & '\h*=(\h*"(.*?)"|' & "\h*'(.*?)'|" & '\h*(.*?)(?: |\Z))', 1)
If @error Then Return ""
Return $aArray[UBound($aArray) - 1]
EndFunc
Func __WinHttpFormSend($hInternet, $sMethod, $sAction, $fMultiPart, $sBoundary, $sAddData, $fSecure = False, $sAdditionalHeaders = "", $sCredName = "", $sCredPass = "", $iIgnoreAllCertErrors = 0)
Local $hRequest
If $fSecure Then
$hRequest = _WinHttpOpenRequest($hInternet, $sMethod, $sAction, Default, Default, Default, $WINHTTP_FLAG_SECURE)
If $iIgnoreAllCertErrors Then _WinHttpSetOption($hRequest, $WINHTTP_OPTION_SECURITY_FLAGS, BitOR($SECURITY_FLAG_IGNORE_UNKNOWN_CA, $SECURITY_FLAG_IGNORE_CERT_DATE_INVALID, $SECURITY_FLAG_IGNORE_CERT_CN_INVALID, $SECURITY_FLAG_IGNORE_CERT_WRONG_USAGE))
Else
$hRequest = _WinHttpOpenRequest($hInternet, $sMethod, $sAction)
EndIf
If $fMultiPart Then
_WinHttpAddRequestHeaders($hRequest, "Content-Type: multipart/form-data; boundary=" & $sBoundary)
Else
If $sMethod = "POST" Then _WinHttpAddRequestHeaders($hRequest, "Content-Type: application/x-www-form-urlencoded")
EndIf
_WinHttpAddRequestHeaders($hRequest, "Accept: application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,*/*;q=0.5")
_WinHttpAddRequestHeaders($hRequest, "Accept-Charset: utf-8;q=0.7")
If $sAdditionalHeaders Then _WinHttpAddRequestHeaders($hRequest, $sAdditionalHeaders, BitOR($WINHTTP_ADDREQ_FLAG_REPLACE, $WINHTTP_ADDREQ_FLAG_ADD))
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_DECOMPRESSION, $WINHTTP_DECOMPRESSION_FLAG_ALL)
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_UNSAFE_HEADER_PARSING, 1)
__WinHttpFormUpload($hRequest, "", $sAddData)
_WinHttpReceiveResponse($hRequest)
__WinHttpSetCredentials($hRequest, "", $sAddData, $sCredName, $sCredPass, 1)
Return $hRequest
EndFunc
Func __WinHttpSetCredentials($hRequest, $sHeaders = "", $sOptional = "", $sCredName = "", $sCredPass = "", $iFormFill = 0)
If $sCredName And $sCredPass Then
Local $iStatusCode = _WinHttpQueryHeaders($hRequest, $WINHTTP_QUERY_STATUS_CODE)
If $iStatusCode = $HTTP_STATUS_DENIED Or $iStatusCode = $HTTP_STATUS_PROXY_AUTH_REQ Then
Local $iSupportedSchemes, $iFirstScheme, $iAuthTarget
If _WinHttpQueryAuthSchemes($hRequest, $iSupportedSchemes, $iFirstScheme, $iAuthTarget) Then
If $iFirstScheme = $WINHTTP_AUTH_SCHEME_PASSPORT And $iStatusCode = $HTTP_STATUS_PROXY_AUTH_REQ Then
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH, $WINHTTP_ENABLE_PASSPORT_AUTH)
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_PROXY_USERNAME, $sCredName)
_WinHttpSetOption($hRequest, $WINHTTP_OPTION_PROXY_PASSWORD, $sCredPass)
Else
_WinHttpSetCredentials($hRequest, $iAuthTarget, $iFirstScheme, $sCredName, $sCredPass)
EndIf
If $iFormFill Then
__WinHttpFormUpload($hRequest, $sHeaders, $sOptional)
Else
_WinHttpSendRequest($hRequest, $sHeaders, $sOptional)
EndIf
_WinHttpReceiveResponse($hRequest)
EndIf
EndIf
EndIf
EndFunc
Func __WinHttpFormUpload($hRequest, $sHeaders, $sData)
Local $aClbk = _WinHttpSimpleFormFill_SetUploadCallback()
If $aClbk[0] <> Default Then
Local $iSize = StringLen($sData), $iChunk = Floor($iSize / $aClbk[1]), $iRest = $iSize - ($aClbk[1] - 1) * $iChunk, $iCurCh = $iChunk
_WinHttpSendRequest($hRequest, Default, Default, $iSize)
For $i = 1 To $aClbk[1]
If $i = $aClbk[1] Then $iCurCh = $iRest
_WinHttpWriteData($hRequest, StringMid($sData, 1 + $iChunk * ($i -1), $iCurCh))
Call($aClbk[0], Floor($i * 100 / $aClbk[1]))
Next
Else
_WinHttpSendRequest($hRequest, Default, $sData)
EndIf
EndFunc
Func __WinHttpDefault(ByRef $vInput, $vOutput)
If $vInput = Default Or Number($vInput) = -1 Then $vInput = $vOutput
EndFunc
Func __WinHttpMemGlobalFree($pMem)
Local $aCall = DllCall("kernel32.dll", "ptr", "GlobalFree", "ptr", $pMem)
If @error Or $aCall[0] Then Return SetError(1, 0, 0)
Return 1
EndFunc
Func __WinHttpPtrStringLenW($pStr)
Local $aCall = DllCall("kernel32.dll", "dword", "lstrlenW", "ptr", $pStr)
If @error Then Return SetError(1, 0, 0)
Return $aCall[0]
EndFunc
Func __WinHttpUA()
Local Static $sUA = "Mozilla/5.0 " & __WinHttpSysInfo() & " WinHttp/" & __WinHttpVer() & " (WinHTTP/5.1) like Gecko"
Return $sUA
EndFunc
Func __WinHttpSysInfo()
Local $sDta = FileGetVersion("kernel32.dll")
$sDta = "(Windows NT " & StringLeft($sDta, StringInStr($sDta, ".", 1, 2) - 1)
If StringInStr(@OSArch, "64") And Not @AutoItX64 Then $sDta &= "; WOW64"
$sDta &= ")"
Return $sDta
EndFunc
Func __WinHttpVer()
Return "1.6.4.1"
EndFunc
Func _WinHttpBinaryConcat(ByRef $bBinary1, ByRef $bBinary2)
Local $bOut = _WinHttpSimpleBinaryConcat($bBinary1, $bBinary2)
Return SetError(@error, 0, $bOut)
EndFunc
#Region Copyright
#EndRegion Copyright
#ignorefunc _WD_IsLatestRelease
#Region Description
#EndRegion Description
#Region Copyright
#EndRegion Copyright
#Region Many thanks to:
#EndRegion Many thanks to:
#Region Global Constants
Global Const $__WDVERSION = "0.4.1.1"
Global Const $_WD_ELEMENT_ID = "element-6066-11e4-a52e-4f735466cecf"
Global Const $_WD_SHADOW_ID  = "shadow-6066-11e4-a52e-4f735466cecf"
Global Const $_WD_EmptyDict  = "{}"
Global Const $_WD_LOCATOR_ByCSSSelector = "css selector"
Global Const $_WD_LOCATOR_ByXPath = "xpath"
Global Const $_WD_LOCATOR_ByLinkText = "link text"
Global Const $_WD_LOCATOR_ByPartialLinkText = "partial link text"
Global Const $_WD_LOCATOR_ByTagName = "tag name"
Global Enum  $_WD_DEBUG_None = 0,  $_WD_DEBUG_Error,     $_WD_DEBUG_Info
Global Enum  $_WD_ERROR_Success = 0,  $_WD_ERROR_GeneralError,  $_WD_ERROR_SocketError,  $_WD_ERROR_InvalidDataType,  $_WD_ERROR_InvalidValue,  $_WD_ERROR_InvalidArgue,  $_WD_ERROR_SendRecv,  $_WD_ERROR_Timeout,  $_WD_ERROR_NoMatch,  $_WD_ERROR_RetValue,  $_WD_ERROR_Exception,  $_WD_ERROR_InvalidExpression,  $_WD_ERROR_NoAlert,  $_WD_ERROR_NotFound,  $_WD_ERROR_ElementIssue,  $_WD_ERROR_SessionInvalid,  $_WD_ERROR_UnknownCommand,  $_WD_ERROR_UserAbort,  $_WD_ERROR_COUNTER
Global Const $aWD_ERROR_DESC[$_WD_ERROR_COUNTER] = [  "Success",  "General Error",  "Socket Error",  "Invalid data type",  "Invalid value",  "Invalid argument",  "Send / Recv error",  "Timeout",  "No match",  "Error return value",  "Webdriver Exception",  "Invalid Expression",  "No alert present",  "Not found",  "Element interaction issue",  "Invalid session ID",  "Unknown Command",  "User Aborted"  ]
Global Const $WD_ErrorInvalidSession = "invalid session id"
Global Const $WD_ErrorUnknownCommand = "unknown command"
Global Const $WD_ErrorTimeout = "timeout"
Global Const $WD_Element_NotFound = "no such element"
Global Const $WD_Element_Stale = "stale element reference"
Global Const $WD_Element_Invalid = "invalid argument"
Global Const $WD_Element_Intercept = "element click intercepted"
Global Const $WD_Element_NotInteract = "element not interactable"
Global Const $WD_WinHTTPTimeoutMsg = "WinHTTP request timed out before Webdriver"
#EndRegion Global Constants
#Region Global Variables
Global $_WD_DRIVER = ""
Global $_WD_DRIVER_PARAMS = ""
Global $_WD_BASE_URL = "HTTP://127.0.0.1"
Global $_WD_PORT = 0
Global $_WD_OHTTP = ObjCreate("winhttp.winhttprequest.5.1")
Global $_WD_HTTPRESULT
Global $_WD_SESSION_DETAILS = ""
Global $_WD_BFORMAT = $SB_UTF8
Global $_WD_ESCAPE_CHARS = '\\"'
Global $_WD_DRIVER_CLOSE = True
Global $_WD_DRIVER_DETECT = True
Global $_WD_RESPONSE_TRIM = 100
Global $_WD_ERROR_MSGBOX = True
Global $_WD_DEBUG = $_WD_DEBUG_Info
Global $_WD_CONSOLE = Default
Global $_WD_IFILTER = 16
Global $_WD_Sleep = Sleep
Global $_WD_DefaultTimeout = 10000
Global $_WD_WINHTTP_TIMEOUTS = True
Global $_WD_HTTPTimeOuts[4] = [0, 60000, 30000, 30000]
Global $_WD_HTTPContentType = "Content-Type: application/json"
#EndRegion Global Variables
Func _WD_CreateSession($sDesiredCapabilities = Default)
Local Const $sFuncName = "_WD_CreateSession"
Local $sSession = ""
If $sDesiredCapabilities = Default Then $sDesiredCapabilities = $_WD_EmptyDict
Local $sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session", $sDesiredCapabilities)
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr = $_WD_ERROR_Success Then
Local $oJSON = Json_Decode($sResponse)
$sSession = Json_Get($oJSON, "[value][sessionId]")
If @error Then
Local $sMessage = Json_Get($oJSON, "[value][message]")
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception, $sMessage), $_WD_HTTPRESULT, "")
EndIf
Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
EndIf
$_WD_SESSION_DETAILS = $sResponse
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sSession)
EndFunc
Func _WD_DeleteSession($sSession)
Local Const $sFuncName = "_WD_DeleteSession"
Local $sResponse = __WD_Delete($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession)
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, 0)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, 1)
EndFunc
Func _WD_Status()
Local Const $sFuncName = "_WD_Status"
Local $sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/status")
Local $iErr = @error, $oResult = Null
If $iErr = $_WD_ERROR_Success Then
Local $oJSON = Json_Decode($sResponse)
$oResult = Json_Get($oJSON, "[value]")
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, 0)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $oResult)
EndFunc
Func _WD_GetSession($sSession)
Local Const $sFuncName = "_WD_GetSession"
Local $sResult
#forceref $sSession, $sFuncName
Local $sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession)
Local $iErr = @error, $sResult = ''
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr = $_WD_ERROR_Success Then
Local $oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, $sResult)
EndIf
EndFunc
Func _WD_Timeouts($sSession, $sTimeouts = Default)
Local Const $sFuncName = "_WD_Timeouts"
Local $sResponse, $sURL
If $sTimeouts = Default Then $sTimeouts = ''
$sURL = $_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/timeouts"
If $sTimeouts = '' Then
$sResponse = __WD_Get($sURL)
Else
$sResponse = __WD_Post($sURL, $sTimeouts)
EndIf
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, 0)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResponse)
EndFunc
Func _WD_Navigate($sSession, $sURL)
Local Const $sFuncName = "_WD_Navigate"
Local $sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/url", '{"url":"' & $sURL & '"}')
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, 0)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, 1)
EndFunc
Func _WD_Action($sSession, $sCommand, $sOption = Default)
Local Const $sFuncName = "_WD_Action"
Local $sResponse, $sResult = "", $iErr, $oJSON, $sURL
If $sOption = Default Then $sOption = ''
$sCommand = StringLower($sCommand)
$sURL = $_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand
Switch $sCommand
Case 'back', 'forward', 'refresh'
$sResponse = __WD_Post($sURL, $_WD_EmptyDict)
$iErr = @error
Case 'url', 'title'
$sResponse = __WD_Get($sURL)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
EndIf
Case 'actions'
If $sOption <> '' Then
$sResponse = __WD_Post($sURL, $sOption)
Else
$sResponse = __WD_Delete($sURL)
EndIf
$iErr = @error
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Back|Forward|Refresh|Url|Title|Actions) $sCommand=>" & $sCommand), 0, "")
EndSwitch
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_Window($sSession, $sCommand, $sOption = Default)
Local Const $sFuncName = "_WD_Window"
Local $sResponse, $oJSON, $sResult = "", $iErr
If $sOption = Default Then $sOption = ''
$sCommand = StringLower($sCommand)
Switch $sCommand
Case 'window'
If $sOption = '' Then
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand)
Else
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand, $sOption)
EndIf
$iErr = @error
Case 'handles'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window/" & $sCommand)
$iErr = @error
Case 'maximize', 'minimize', 'fullscreen'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window/" & $sCommand, $_WD_EmptyDict)
$iErr = @error
Case 'new'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window/" & $sCommand, $sOption)
$iErr = @error
Case 'rect'
If $sOption = '' Then
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window/" & $sCommand)
Else
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window/" & $sCommand, $sOption)
EndIf
$iErr = @error
Case 'screenshot'
If $sOption = '' Then
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand)
Else
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand & '/' & $sOption)
EndIf
$iErr = @error
Case 'close'
$sResponse = __WD_Delete($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window")
$iErr = @error
Case 'switch'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/window", $sOption)
$iErr = @error
Case 'frame', 'print'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/" & $sCommand, $sOption)
$iErr = @error
Case 'parent'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/frame/parent", $sOption)
$iErr = @error
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Window|Handles|Maximize|Minimize|Fullscreen|New|Rect|Screenshot|Close|Switch|Frame|Parent|Print) $sCommand=>" & $sCommand), 0, "")
EndSwitch
If $iErr = $_WD_ERROR_Success Then
If $_WD_HTTPRESULT = $HTTP_STATUS_OK Then
Switch $sCommand
Case 'maximize', 'minimize', 'fullscreen', 'close', 'switch', 'frame', 'parent'
$sResult = $sResponse
Case 'new'
$oJson = Json_Decode($sResponse)
$sResult = Json_Get($oJson, "[value][handle]")
Case Else
$oJson = Json_Decode($sResponse)
$sResult = Json_Get($oJson, "[value]")
EndSwitch
Else
$iErr = $_WD_ERROR_Exception
EndIf
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & StringLeft($sResponse, $_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_FindElement($sSession, $sStrategy, $sSelector, $sStartNodeID = Default, $bMultiple = Default, $bShadowRoot = Default)
Local Const $sFuncName = "_WD_FindElement"
Local $sCmd, $sBaseCmd = '', $sResponse, $sResult, $iErr
Local $oJson, $oValues, $sKey, $iRow, $aElements[0]
If $sStartNodeID = Default Then $sStartNodeID = ""
If $bMultiple = Default Then $bMultiple = False
If $bShadowRoot = Default Then $bShadowRoot = False
If $sStartNodeID Then
$sBaseCmd = ($bShadowRoot) ? "/shadow/" : "/element/"
$sBaseCmd &= $sStartNodeID
If $sStrategy = $_WD_LOCATOR_ByXPath And StringLeft($sSelector, 1) <> '.' Then
$iErr = $_WD_ERROR_InvalidExpression
$sResponse = "Selector must be relative when supplying a starting element"
EndIf
EndIf
If $iErr = $_WD_ERROR_Success Then
$sCmd = '/element' & (($bMultiple) ? 's' : '')
$sSelector = __WD_EscapeString($sSelector)
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & $sBaseCmd & $sCmd, '{"using":"' & $sStrategy & '","value":"' & $sSelector & '"}')
$iErr = @error
EndIf
If $iErr = $_WD_ERROR_Success Then
If $_WD_HTTPRESULT = $HTTP_STATUS_OK Then
If $bMultiple Then
$oJson = Json_Decode($sResponse)
$oValues = Json_Get($oJson, '[value]')
If UBound($oValues) > 0 Then
$sKey = "[" & $_WD_ELEMENT_ID & "]"
Dim $aElements[UBound($oValues)]
For $oValue In $oValues
$aElements[$iRow] = Json_Get($oValue, $sKey)
$iRow += 1
Next
Else
$iErr = $_WD_ERROR_NoMatch
EndIf
Else
$oJson = Json_Decode($sResponse)
$sResult = Json_Get($oJson, "[value][" & $_WD_ELEMENT_ID & "]")
EndIf
Else
$iErr = $_WD_ERROR_Exception
EndIf
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, ($bMultiple) ? $aElements : $sResult)
EndFunc
Func _WD_ElementAction($sSession, $sElement, $sCommand, $sOption = Default)
Local Const $sFuncName = "_WD_ElementAction"
Local $sResponse, $sResult = '', $iErr, $oJson
If $sOption = Default Then $sOption = ''
$sCommand = StringLower($sCommand)
Switch $sCommand
Case 'name', 'rect', 'text', 'selected', 'enabled', 'displayed', 'screenshot', 'shadow', 'comprole', 'complabel'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sElement & "/" & $sCommand)
$iErr = @error
Case 'active'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sCommand)
$iErr = @error
Case 'attribute', 'property', 'css'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sElement & "/" & $sCommand & "/" & $sOption)
$iErr = @error
Case 'clear', 'click'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sElement & "/" & $sCommand, '{"id":"' & $sElement & '"}')
$iErr = @error
Case 'value'
If $sOption Then
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sElement & "/" & $sCommand, '{"id":"' & $sElement & '", "text":"' & __WD_EscapeString($sOption) & '"}')
Else
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/element/" & $sElement & "/property/value")
EndIf
$iErr = @error
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Name|Rect|Text|Selected|Enabled|Displayed|Active|Attribute|Property|CSS|Clear|Click|Value|Screenshot|Shadow|CompRole|CompLabel) $sCommand=>" & $sCommand), 0, "")
EndSwitch
If $iErr = $_WD_ERROR_Success Then
Switch $_WD_HTTPRESULT
Case $HTTP_STATUS_OK
Switch $sCommand
Case 'clear', 'click'
$sResult = $sResponse
Case 'value'
If $sOption Then
$sResult = $sResponse
Else
$oJson = Json_Decode($sResponse)
$sResult = Json_Get($oJson, "[value]")
EndIf
Case Else
$oJson = Json_Decode($sResponse)
$sResult = Json_Get($oJson, "[value]")
EndSwitch
Case Else
$iErr = $_WD_ERROR_Exception
EndSwitch
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & StringLeft($sResponse,$_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, $sResponse), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_ExecuteScript($sSession, $sScript, $sArguments = Default, $bAsync = Default)
Local Const $sFuncName = "_WD_ExecuteScript"
Local $sResponse, $sData, $sCmd
If $sArguments = Default Then $sArguments = ""
If $bAsync = Default Then $bAsync = False
$sScript = __WD_EscapeString($sScript)
$sData = '{"script":"' & $sScript & '", "args":[' & $sArguments & ']}'
$sCmd = ($bAsync) ? 'async' : 'sync'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/execute/" & $sCmd, $sData)
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & StringLeft($sResponse,$_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, $sResponse)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResponse)
EndFunc
Func _WD_Alert($sSession, $sCommand, $sOption = Default)
Local Const $sFuncName = "_WD_Alert"
Local $sResponse, $iErr, $oJSON, $sResult = ''
If $sOption = Default Then $sOption = ''
$sCommand = StringLower($sCommand)
Switch $sCommand
Case 'dismiss', 'accept'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/alert/" & $sCommand, $_WD_EmptyDict)
$iErr = @error
If $iErr = $_WD_ERROR_Success And $_WD_HTTPRESULT = $HTTP_STATUS_NOT_FOUND Then
$iErr = $_WD_ERROR_NoAlert
EndIf
Case 'gettext'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/alert/text")
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
If $_WD_HTTPRESULT = $HTTP_STATUS_NOT_FOUND Then
$sResult = ""
$iErr = $_WD_ERROR_NoAlert
Else
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
EndIf
EndIf
Case 'sendtext'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/alert/text", '{"text":"' & $sOption & '"}')
$iErr = @error
If $iErr = $_WD_ERROR_Success And $_WD_HTTPRESULT = $HTTP_STATUS_NOT_FOUND Then
$iErr = $_WD_ERROR_NoAlert
EndIf
Case 'status'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/alert/text")
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sResult = ($_WD_HTTPRESULT = $HTTP_STATUS_NOT_FOUND) ? False : True
EndIf
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Dismiss|Accept|GetText|SendText|Status) $sCommand=>" & $sCommand), 0, "")
EndSwitch
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, $sResponse), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_GetSource($sSession)
Local Const $sFuncName = "_WD_GetSource"
Local $sResponse, $iErr, $sResult = "", $oJSON
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/source")
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, $sResponse), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_Cookies($sSession, $sCommand, $sOption = Default)
Local Const $sFuncName = "_WD_Cookies"
Local $sResult, $sResponse, $iErr
If $sOption = Default Then $sOption = ''
Switch $sCommand
Case 'getall'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/cookie")
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sResult = $sResponse
EndIf
Case 'get'
$sResponse = __WD_Get($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/cookie/" & $sOption)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sResult = $sResponse
EndIf
Case 'add'
$sResponse = __WD_Post($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/cookie", $sOption)
$iErr = @error
Case 'delete'
$sResponse = __WD_Delete($_WD_BASE_URL & ":" & $_WD_PORT & "/session/" & $sSession & "/cookie/" & $sOption)
$iErr = @error
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(GetAll|Get|Add|Delete) $sCommand=>" & $sCommand), 0, "")
EndSwitch
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResponse & @CRLF)
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, $sResponse), $_WD_HTTPRESULT, "")
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_Option($sOption, $vValue = Default)
Local Const $sFuncName = "_WD_Option"
If $vValue = Default Then $vValue = ''
Switch $sOption
Case "driver"
If $vValue == "" Then Return $_WD_DRIVER
If Not IsString($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(string) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_DRIVER = $vValue
Case "driverparams"
If $vValue == "" Then Return $_WD_DRIVER_PARAMS
If Not IsString($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(string) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_DRIVER_PARAMS = $vValue
Case "baseurl"
If $vValue == "" Then Return $_WD_BASE_URL
If Not IsString($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(string) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_BASE_URL = $vValue
Case "port"
If $vValue == "" Then Return $_WD_PORT
If Not IsInt($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_PORT = $vValue
Case "binaryformat"
If $vValue == "" Then Return $_WD_BFORMAT
If Not IsInt($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_BFORMAT = $vValue
Case "driverclose"
If $vValue == "" Then Return $_WD_DRIVER_CLOSE
If Not IsBool($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(bool) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_DRIVER_CLOSE = $vValue
Case "driverdetect"
If $vValue == "" Then Return $_WD_DRIVER_DETECT
If Not IsBool($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(bool) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_DRIVER_DETECT = $vValue
Case "httptimeouts"
If $vValue == "" Then Return $_WD_WINHTTP_TIMEOUTS
If Not IsBool($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(bool) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_WINHTTP_TIMEOUTS = $vValue
Case "debugtrim"
If $vValue == "" Then Return $_WD_RESPONSE_TRIM
If Not IsInt($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_RESPONSE_TRIM = $vValue
Case "console"
If $vValue == "" Then Return $_WD_CONSOLE
If Not (IsString($vValue) Or IsInt($vValue)) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(string/int) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_CONSOLE = $vValue
Case "DefaultTimeout"
If $vValue == "" Then Return $_WD_DefaultTimeout
If Not IsInt($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_DefaultTimeout = $vValue
Case "Sleep"
If $vValue == "" Then Return $_WD_Sleep
If Not IsFunc($vValue) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(func) $vValue: " & $vValue), 0, 0)
EndIf
$_WD_Sleep = $vValue
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Driver|DriverParams|BaseURL|Port|BinaryFormat|DriverClose|DriverDetect|HTTPTimeouts|DebugTrim|Console|Sleep) $sOption=>" & $sOption), 0, 0)
EndSwitch
Return 1
EndFunc
Func _WD_Startup()
Local Const $sFuncName = "_WD_Startup"
Local $sFunction, $bLatest, $sUpdate, $sFile, $pid
If $_WD_DRIVER = "" Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidValue, "Location for Web Driver not set." & @CRLF), 0, 0)
EndIf
If $_WD_DRIVER_CLOSE Then __WD_CloseDriver()
Local $sCommand = StringFormat('"%s" %s ', $_WD_DRIVER, $_WD_DRIVER_PARAMS)
If $_WD_DEBUG = $_WD_DEBUG_Info Then
$sFunction = "_WD_IsLatestRelease"
$bLatest = Call($sFunction)
Select
Case @error = 0xDEAD And @extended = 0xBEEF
$sUpdate = ""
Case @error
$sUpdate = " (Update status unknown [" & @error & "])"
Case $bLatest
$sUpdate = " (Up to date)"
Case Not $bLatest
$sUpdate = " (Update available)"
EndSelect
Local $sWinHttpVer = __WinHttpVer()
If $sWinHttpVer < "1.6.4.2" Then
$sWinHttpVer &= " (Download latest source at <https://raw.githubusercontent.com/dragana-r/autoit-winhttp/master/WinHttp.au3>)"
EndIf
__WD_ConsoleWrite($sFuncName & ": OS:" & @TAB & @OSVersion & " " & @OSType & " " & @OSBuild & " " & @OSServicePack & @CRLF)
__WD_ConsoleWrite($sFuncName & ": AutoIt:" & @TAB & @AutoItVersion & @CRLF)
__WD_ConsoleWrite($sFuncName & ": WD.au3:" & @TAB & $__WDVERSION & $sUpdate & @CRLF)
__WD_ConsoleWrite($sFuncName & ": WinHTTP:" & @TAB & $sWinHttpVer & @CRLF)
__WD_ConsoleWrite($sFuncName & ": Driver:" & @TAB & $_WD_DRIVER & @CRLF)
__WD_ConsoleWrite($sFuncName & ": Params:" & @TAB & $_WD_DRIVER_PARAMS & @CRLF)
__WD_ConsoleWrite($sFuncName & ": Port:" & @TAB & $_WD_PORT & @CRLF)
Else
__WD_ConsoleWrite($sFuncName & ': ' & $sCommand & @CRLF)
EndIf
$sFile = __WD_StripPath($_WD_DRIVER)
$pid = ProcessExists($sFile)
If $_WD_DRIVER_DETECT And $pid Then
__WD_ConsoleWrite($sFuncName & ": Existing instance of " & $sFile & " detected!" & @CRLF)
Else
$pid = Run($sCommand, "", ($_WD_DEBUG = $_WD_DEBUG_Info) ? @SW_SHOW : @SW_HIDE)
EndIf
If @error Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_GeneralError, "Error launching web driver!"), 0, 0)
EndIf
Return SetError($_WD_ERROR_Success, 0, $pid)
EndFunc
Func _WD_Shutdown($vDriver = Default)
__WD_CloseDriver($vDriver)
EndFunc
Func __WD_Get($sURL)
Local Const $sFuncName = "__WD_Get"
Local $iResult = $_WD_ERROR_Success, $sResponseText, $iErr
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': URL=' & $sURL & @CRLF)
EndIf
$_WD_HTTPRESULT = 0
Local $aURL = _WinHttpCrackUrl($sURL)
If IsArray($aURL) Then
Local $hOpen = _WinHttpOpen()
If $_WD_WINHTTP_TIMEOUTS Then
_WinHttpSetTimeouts($hOpen, $_WD_HTTPTimeOuts[0], $_WD_HTTPTimeOuts[1], $_WD_HTTPTimeOuts[2], $_WD_HTTPTimeOuts[3])
EndIf
Local $hConnect = _WinHttpConnect($hOpen, $aURL[2], $aURL[3])
If @error Then
$iResult = $_WD_ERROR_SocketError
Else
Switch $aURL[1]
Case $INTERNET_SCHEME_HTTP
$sResponseText = _WinHttpSimpleRequest($hConnect, "GET", $aURL[6] & $aURL[7], Default, Default, $_WD_HTTPContentType)
Case $INTERNET_SCHEME_HTTPS
$sResponseText = _WinHttpSimpleSSLRequest($hConnect, "GET", $aURL[6] & $aURL[7], Default, Default, $_WD_HTTPContentType)
Case Else
SetError($_WD_ERROR_InvalidValue)
EndSwitch
$iErr = @error
$_WD_HTTPRESULT = @extended
If $iErr Then
$iResult = $_WD_ERROR_SendRecv
$sResponseText = $WD_WinHTTPTimeoutMsg
Else
__WD_DetectError($iErr, $sResponseText)
$iResult = $iErr
EndIf
EndIf
_WinHttpCloseHandle($hConnect)
_WinHttpCloseHandle($hOpen)
Else
$iResult = $_WD_ERROR_InvalidValue
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': StatusCode=' & $_WD_HTTPRESULT & "; $iResult = " & $iResult & "; $sResponseText=" & StringLeft($sResponseText,$_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iResult Then
Return SetError(__WD_Error($sFuncName, $iResult, $sResponseText), $_WD_HTTPRESULT, $sResponseText)
EndIf
Return SetError($_WD_ERROR_Success, 0, $sResponseText)
EndFunc
Func __WD_Post($sURL, $sData)
Local Const $sFuncName = "__WD_Post"
Local $iResult, $sResponseText, $iErr
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': URL=' & $sURL & "; $sData=" & $sData & @CRLF)
EndIf
$_WD_HTTPRESULT = 0
Local $aURL = _WinHttpCrackUrl($sURL)
If @error Then
$iResult = $_WD_ERROR_InvalidValue
Else
Local $hOpen = _WinHttpOpen()
If $_WD_WINHTTP_TIMEOUTS Then
_WinHttpSetTimeouts($hOpen, $_WD_HTTPTimeOuts[0], $_WD_HTTPTimeOuts[1], $_WD_HTTPTimeOuts[2], $_WD_HTTPTimeOuts[3])
EndIf
Local $hConnect = _WinHttpConnect($hOpen, $aURL[2], $aURL[3])
If @error Then
$iResult = $_WD_ERROR_SocketError
Else
Switch $aURL[1]
Case $INTERNET_SCHEME_HTTP
$sResponseText = _WinHttpSimpleRequest($hConnect, "POST", $aURL[6] & $aURL[7], Default, StringToBinary($sData, $_WD_BFORMAT), $_WD_HTTPContentType)
Case $INTERNET_SCHEME_HTTPS
$sResponseText = _WinHttpSimpleSSLRequest($hConnect, "POST", $aURL[6] & $aURL[7], Default, StringToBinary($sData, $_WD_BFORMAT), $_WD_HTTPContentType)
Case Else
SetError($_WD_ERROR_InvalidValue)
EndSwitch
$iErr = @error
$_WD_HTTPRESULT = @extended
If $iErr Then
$iResult = $_WD_ERROR_SendRecv
$sResponseText = $WD_WinHTTPTimeoutMsg
Else
__WD_DetectError($iErr, $sResponseText)
$iResult = $iErr
EndIf
EndIf
_WinHttpCloseHandle($hConnect)
_WinHttpCloseHandle($hOpen)
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': StatusCode=' & $_WD_HTTPRESULT & "; ResponseText=" & StringLeft($sResponseText,$_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iResult Then
Return SetError(__WD_Error($sFuncName, $iResult, $sResponseText), $_WD_HTTPRESULT, $sResponseText)
EndIf
Return SetError($_WD_ERROR_Success, $_WD_HTTPRESULT, $sResponseText)
EndFunc
Func __WD_Delete($sURL)
Local Const $sFuncName = "__WD_Delete"
Local $iResult, $sResponseText, $iErr
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': URL=' & $sURL & @CRLF)
EndIf
$_WD_HTTPRESULT = 0
Local $aURL = _WinHttpCrackUrl($sURL)
If @error Then
$iResult = $_WD_ERROR_InvalidValue
Else
Local $hOpen = _WinHttpOpen()
If $_WD_WINHTTP_TIMEOUTS Then
_WinHttpSetTimeouts($hOpen, $_WD_HTTPTimeOuts[0], $_WD_HTTPTimeOuts[1], $_WD_HTTPTimeOuts[2], $_WD_HTTPTimeOuts[3])
EndIf
Local $hConnect = _WinHttpConnect($hOpen, $aURL[2], $aURL[3])
If @error Then
$iResult = $_WD_ERROR_SocketError
Else
Switch $aURL[1]
Case $INTERNET_SCHEME_HTTP
$sResponseText = _WinHttpSimpleRequest($hConnect, "DELETE", $aURL[6] & $aURL[7], Default, Default, $_WD_HTTPContentType)
Case $INTERNET_SCHEME_HTTPS
$sResponseText = _WinHttpSimpleSSLRequest($hConnect, "DELETE", $aURL[6] & $aURL[7], Default, Default, $_WD_HTTPContentType)
Case Else
SetError($_WD_ERROR_InvalidValue)
EndSwitch
$iErr = @error
$_WD_HTTPRESULT = @extended
If $iErr Then
$iResult = $_WD_ERROR_SendRecv
$sResponseText = $WD_WinHTTPTimeoutMsg
Else
__WD_DetectError($iErr, $sResponseText)
$iResult = $iErr
EndIf
EndIf
_WinHttpCloseHandle($hConnect)
_WinHttpCloseHandle($hOpen)
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': StatusCode=' & $_WD_HTTPRESULT & "; ResponseText=" & StringLeft($sResponseText,$_WD_RESPONSE_TRIM) & "..." & @CRLF)
EndIf
If $iResult Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception, $sResponseText), $_WD_HTTPRESULT, $sResponseText)
EndIf
Return SetError($_WD_ERROR_Success, 0, $sResponseText)
EndFunc
Func __WD_Error($sWhere, $i_WD_ERROR, $sMessage = Default)
Local $sMsg
If $sMessage = Default Then $sMessage = ''
Switch $_WD_DEBUG
Case $_WD_DEBUG_None
Case $_WD_DEBUG_Error
If $i_WD_ERROR <> $_WD_ERROR_Success Then ContinueCase
Case $_WD_DEBUG_Info
$sMsg = $sWhere & " ==> " & $aWD_ERROR_DESC[$i_WD_ERROR]
If $sMessage <> "" Then
$sMsg = $sMsg & ": " & $sMessage
EndIf
__WD_ConsoleWrite($sMsg & @CRLF)
If @Compiled Then
If $_WD_ERROR_MSGBOX And $i_WD_ERROR <> $_WD_ERROR_Success And $i_WD_ERROR < 6 Then MsgBox(16, "WD_Core.au3 Error:", $sMsg)
DllCall("kernel32.dll", "none", "OutputDebugString", "str", $sMsg)
EndIf
EndSwitch
Return $i_WD_ERROR
EndFunc
Func __WD_CloseDriver($vDriver = Default)
Local $sFile, $aData, $aProcessList[2][2]
If $vDriver = Default Then $vDriver = $_WD_DRIVER
If IsInt($vDriver) Then
$aProcessList[0][0] = 1
$aProcessList[1][1] = $vDriver
Else
$sFile = __WD_StripPath($vDriver)
$aProcessList = ProcessList($sFile)
EndIf
For $i = 1 To $aProcessList[0][0]
$aData = _WinAPI_EnumChildProcess($aProcessList[$i][1])
If IsArray($aData) Then
For $j = 0 To UBound($aData) - 1
If $aData[$j][1] == 'conhost.exe' Then
ProcessClose($aData[$j][0])
ProcessWaitClose($aData[$j][0], 5)
EndIf
Next
EndIf
ProcessClose($aProcessList[$i][1])
ProcessWaitClose($aProcessList[$i][1], 5)
Next
EndFunc
Func __WD_EscapeString($sData)
Local $sRegEx = "([" & $_WD_ESCAPE_CHARS & "])"
Local $sEscaped = StringRegExpReplace($sData, $sRegEx, "\\$1")
Return SetError($_WD_ERROR_Success, 0, $sEscaped)
EndFunc
Func __WD_TranslateQuotes($sData)
Local $sResult = StringReplace($sData, '"' , "'")
Return SetError($_WD_ERROR_Success, 0, $sResult)
EndFunc
Func __WD_DetectError(ByRef $iErr, $vResult)
If $iErr or $vResult == Null Then Return
If Not IsObj($vResult) Then
Local $oJSON = Json_Decode($vResult)
$vResult = Json_Get($oJSON, "[value]")
If @error Or $vResult == Null Then Return
EndIf
If (Not IsObj($vResult)) Or ObjName($vResult, $OBJ_STRING) <> 'Scripting.Dictionary' Then Return
If $vResult.Exists('error') Then
Switch $vResult.item('error')
Case ""
Case $WD_ErrorInvalidSession
$iErr = $_WD_ERROR_SessionInvalid
Case $WD_ErrorUnknownCommand
$iErr = $_WD_ERROR_UnknownCommand
Case $WD_ErrorTimeout
$iErr = $_WD_ERROR_Timeout
Case $WD_Element_NotFound, $WD_Element_Stale
$iErr =  $_WD_ERROR_NoMatch
Case $WD_Element_Invalid
$iErr = $_WD_ERROR_InvalidArgue
Case $WD_Element_Intercept, $WD_Element_NotInteract
$iErr = $_WD_ERROR_ElementIssue
Case Else
$iErr = $_WD_ERROR_Exception
EndSwitch
EndIf
EndFunc
Func __WD_StripPath($sFilePath)
Return StringRegExpReplace($sFilePath, "^.*\\(.*)$", "$1")
EndFunc
Func __WD_ConsoleWrite($sMsg)
If $_WD_CONSOLE = Default Then
ConsoleWrite($sMsg)
Else
FileWrite($_WD_CONSOLE, $sMsg)
EndIf
EndFunc
Func __WD_Sleep($iPause)
$_WD_Sleep($iPause)
If @error Then SetError($_WD_ERROR_Timeout)
EndFunc
#Region Global Variables and Constants
Global Const $_ARRAYCONSTANT_SORTINFOSIZE = 11
Global $__g_aArrayDisplay_SortInfo[$_ARRAYCONSTANT_SORTINFOSIZE]
Global Const $ARRAYDISPLAY_COLALIGNLEFT = 0
Global Const $ARRAYDISPLAY_TRANSPOSE = 1
Global Const $ARRAYDISPLAY_COLALIGNRIGHT = 2
Global Const $ARRAYDISPLAY_COLALIGNCENTER = 4
Global Const $ARRAYDISPLAY_VERBOSE = 8
Global Const $ARRAYDISPLAY_NOROW = 64
Global Const $_ARRAYCONSTANT_tagHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
Global Const $_ARRAYCONSTANT_tagLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" &  "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
Func __ArrayDisplay_Share(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default, $hUser_Function = Default, $bDebug = True)
Local $vTmp, $sMsgBoxTitle = (($bDebug) ? ("DebugArray") : ("ArrayDisplay"))
If $sTitle = Default Then $sTitle = $sMsgBoxTitle
If $sArrayRange = Default Then $sArrayRange = ""
If $iFlags = Default Then $iFlags = 0
If $vUser_Separator = Default Then $vUser_Separator = ""
If $sHeader = Default Then $sHeader = ""
If $iMax_ColWidth = Default Then $iMax_ColWidth = 350
If $hUser_Function = Default Then $hUser_Function = 0
Local $iTranspose = BitAND($iFlags, $ARRAYDISPLAY_TRANSPOSE)
Local $iColAlign = BitAND($iFlags, 6)
Local $iVerbose = BitAND($iFlags, $ARRAYDISPLAY_VERBOSE)
Local $iNoRow = BitAND($iFlags, $ARRAYDISPLAY_NOROW)
Local $iButtonBorder = (($bDebug) ? (40) : (20))
Local $sMsg = "", $iRet = 1
If IsArray($aArray) Then
Local $iDimension = UBound($aArray, $UBOUND_DIMENSIONS), $iRowCount = UBound($aArray, $UBOUND_ROWS), $iColCount = UBound($aArray, $UBOUND_COLUMNS)
If $iDimension > 2 Then
$sMsg = "Larger than 2D array passed to function"
$iRet = 2
EndIf
If $iDimension = 1 Then
$iTranspose = 0
EndIf
Else
$sMsg = "No array variable passed to function"
EndIf
If $sMsg Then
If $iVerbose And MsgBox($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO,  $sMsgBoxTitle & " Error: " & $sTitle, $sMsg & @CRLF & @CRLF & "Exit the script?") = $IDYES Then
Exit
Else
Return SetError($iRet, 0, 0)
EndIf
EndIf
Local $iCW_ColWidth = Number($vUser_Separator)
Local $sCurr_Separator = Opt("GUIDataSeparatorChar")
If $vUser_Separator = "" Then $vUser_Separator = $sCurr_Separator
Local $iItem_Start = 0, $iItem_End = $iRowCount - 1, $iSubItem_Start = 0, $iSubItem_End = (($iDimension = 2) ? ($iColCount - 1) : (0))
Local $bRange_Flag = False, $avRangeSplit
If $sArrayRange Then
Local $aArray_Range = StringRegExp($sArrayRange & "||", "(?U)(.*)\|", 3)
If $aArray_Range[0] Then
$avRangeSplit = StringSplit($aArray_Range[0], ":")
If @error Then
$iItem_End = Number($avRangeSplit[1])
Else
$iItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$iItem_End = Number($avRangeSplit[2])
EndIf
EndIf
EndIf
If $iItem_Start < 0 Then $iItem_Start = 0
If $iItem_End > $iRowCount - 1 Then $iItem_End = $iRowCount - 1
If $iItem_Start > $iItem_End Then
$vTmp = $iItem_Start
$iItem_Start = $iItem_End
$iItem_End = $vTmp
EndIf
If $iItem_Start <> 0 Or $iItem_End <> $iRowCount - 1 Then $bRange_Flag = True
If $iDimension = 2 And $aArray_Range[1] Then
$avRangeSplit = StringSplit($aArray_Range[1], ":")
If @error Then
$iSubItem_End = Number($avRangeSplit[1])
Else
$iSubItem_Start = Number($avRangeSplit[1])
If $avRangeSplit[2] <> "" Then
$iSubItem_End = Number($avRangeSplit[2])
EndIf
EndIf
If $iSubItem_Start > $iSubItem_End Then
$vTmp = $iSubItem_Start
$iSubItem_Start = $iSubItem_End
$iSubItem_End = $vTmp
EndIf
If $iSubItem_Start < 0 Then $iSubItem_Start = 0
If $iSubItem_End > $iColCount - 1 Then $iSubItem_End = $iColCount - 1
If $iSubItem_Start <> 0 Or $iSubItem_End <> $iColCount - 1 Then $bRange_Flag = True
EndIf
EndIf
Local $sDisplayData = "[" & $iRowCount & "]"
If $iDimension = 2 Then
$sDisplayData &= " [" & $iColCount & "]"
EndIf
Local $sTipData = ""
If $bRange_Flag Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Range set"
EndIf
If $iTranspose Then
If $sTipData Then $sTipData &= " - "
$sTipData &= "Transposed"
EndIf
Local $asHeader = StringSplit($sHeader, $sCurr_Separator, $STR_NOCOUNT)
If UBound($asHeader) = 0 Then Local $asHeader[1] = [""]
$sHeader = "Row"
Local $iIndex = $iSubItem_Start
If $iTranspose Then
$sHeader = "Col"
For $j = $iItem_Start To $iItem_End
$sHeader &= $sCurr_Separator & "Row " & $j
Next
Else
If $asHeader[0] Then
For $iIndex = $iSubItem_Start To $iSubItem_End
If $iIndex >= UBound($asHeader) Then ExitLoop
$sHeader &= $sCurr_Separator & $asHeader[$iIndex]
Next
EndIf
For $j = $iIndex To $iSubItem_End
$sHeader &= $sCurr_Separator & "Col " & $j
Next
EndIf
If $iNoRow Then $sHeader = StringTrimLeft($sHeader, 4)
If $iVerbose And ($iItem_End - $iItem_Start + 1) * ($iSubItem_End - $iSubItem_Start + 1) > 10000 Then
SplashTextOn($sMsgBoxTitle, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local Const $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
Local Const $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
Local Const $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
Local Const $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
Local Const $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
Local Const $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
Local Const $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
Local Const $_ARRAYCONSTANT_GUI_FOCUS = 256
Local Const $_ARRAYCONSTANT_SS_CENTER = 0x1
Local Const $_ARRAYCONSTANT_SS_CENTERIMAGE = 0x0200
Local Const $_ARRAYCONSTANT_LVM_GETITEMCOUNT = (0x1000 + 4)
Local Const $_ARRAYCONSTANT_LVM_GETITEMRECT = (0x1000 + 14)
Local Const $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH = (0x1000 + 29)
Local Const $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH = (0x1000 + 30)
Local Const $_ARRAYCONSTANT_LVM_GETITEMSTATE = (0x1000 + 44)
Local Const $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (0x1000 + 50)
Local Const $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000 + 54)
Local Const $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 0x1
Local Const $_ARRAYCONSTANT_LVIS_SELECTED = 0x0002
Local Const $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 0x8
Local Const $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 0x20
Local Const $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 0x0200
Local Const $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Local Const $_ARRAYCONSTANT_WS_MINIMIZEBOX = 0x00020000
Local Const $_ARRAYCONSTANT_WS_SIZEBOX = 0x00040000
Local Const $_ARRAYCONSTANT_WM_SETREDRAW = 11
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE = -1
Local Const $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER = -2
Local $iCoordMode = Opt("GUICoordMode", 1)
Local $iOrgWidth = 210, $iHeight = 200, $iMinSize = 250
Local $hGUI = GUICreate($sTitle, $iOrgWidth, $iHeight, Default, Default, BitOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
Local $aiGUISize = WinGetClientSize($hGUI)
Local $iButtonWidth_1 = $aiGUISize[0] / 2
Local $iButtonWidth_2 = $aiGUISize[0] / 3
Local $idListView = GUICtrlCreateListView($sHeader, 0, 0, $aiGUISize[0], $aiGUISize[1] - $iButtonBorder, $_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
Local $idCopy_ID = 9999, $idCopy_Data = 99999, $idData_Label = 99999, $idUser_Func = 99999, $idExit_Script = 99999
If $bDebug Then
$idCopy_ID = GUICtrlCreateButton("Copy Data && Hdr/Row", 0, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
$idCopy_Data = GUICtrlCreateButton("Copy Data Only", $iButtonWidth_1, $aiGUISize[1] - $iButtonBorder, $iButtonWidth_1, 20)
Local $iButtonWidth_Var = $iButtonWidth_1
Local $iOffset = $iButtonWidth_1
If IsFunc($hUser_Function) Then
$idUser_Func = GUICtrlCreateButton("Run User Func", $iButtonWidth_2, $aiGUISize[1] - 20, $iButtonWidth_2, 20)
$iButtonWidth_Var = $iButtonWidth_2
$iOffset = $iButtonWidth_2 * 2
EndIf
$idExit_Script = GUICtrlCreateButton("Exit Script", $iOffset, $aiGUISize[1] - 20, $iButtonWidth_Var, 20)
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $iButtonWidth_Var, 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
Else
$idData_Label = GUICtrlCreateLabel($sDisplayData, 0, $aiGUISize[1] - 20, $aiGUISize[0], 18, BitOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
EndIf
Select
Case $iTranspose Or $bRange_Flag
GUICtrlSetColor($idData_Label, 0xFF0000)
GUICtrlSetTip($idData_Label, $sTipData)
EndSelect
GUICtrlSetResizing($idListView, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
GUICtrlSetResizing($idCopy_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idCopy_Data, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idData_Label, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idUser_Func, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSetResizing($idExit_Script, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 0, 0)
Local $iRowIndex, $iColFill
If $iTranspose Then
For $i = $iSubItem_Start To $iSubItem_End
$iRowIndex = __ArrayDisplay_AddItem($idListView, "NULL")
If $iNoRow Then
$iColFill = 0
Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "Col " & $i, 0)
$iColFill = 1
EndIf
For $j = $iItem_Start To $iItem_End
If $iDimension = 2 Then
$vTmp = $aArray[$j][$i]
Else
$vTmp = $aArray[$j]
EndIf
Switch VarGetType($vTmp)
Case "Array"
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "{Array}", $iColFill)
Case Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, $vTmp, $iColFill)
EndSwitch
$iColFill += 1
Next
Next
Else
For $i = $iItem_Start To $iItem_End
$iRowIndex = __ArrayDisplay_AddItem($idListView, "NULL")
If $iNoRow Then
$iColFill = 0
Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "Row " & $i, 0)
$iColFill = 1
EndIf
For $j = $iSubItem_Start To $iSubItem_End
If $iDimension = 2 Then
$vTmp = $aArray[$i][$j]
Else
$vTmp = $aArray[$i]
EndIf
Switch VarGetType($vTmp)
Case "Array"
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, "{Array}", $iColFill)
Case Else
__ArrayDisplay_AddSubItem($idListView, $iRowIndex, $vTmp, $iColFill)
EndSwitch
$iColFill += 1
Next
Next
EndIf
If $iColAlign Then
For $i = 0 To $iColFill - 1
__ArrayDisplay_JustifyColumn($idListView, $i, $iColAlign / 2)
Next
EndIf
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_WM_SETREDRAW, 1, 0)
Local $iBorder = (($iRowIndex > 19) ? (65) : (45))
Local $iWidth = $iBorder, $iColWidth = 0, $aiColWidth[$iColFill], $iMin_ColWidth = 55
For $i = 0 To UBound($aiColWidth) - 1
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE)
$iColWidth = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $sHeader <> "" Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER)
Local $iColWidthHeader = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $i, 0)
If $iColWidth < $iMin_ColWidth And $iColWidthHeader < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
ElseIf $iColWidthHeader < $iColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iColWidth)
Else
$iColWidth = $iColWidthHeader
EndIf
Else
If $iColWidth < $iMin_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMin_ColWidth)
$iColWidth = $iMin_ColWidth
EndIf
EndIf
$iWidth += $iColWidth
$aiColWidth[$i] = $iColWidth
Next
If $iWidth > @DesktopWidth - 100 Then
$iWidth = $iBorder
For $i = 0 To UBound($aiColWidth) - 1
If $aiColWidth[$i] > $iMax_ColWidth Then
GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $i, $iMax_ColWidth)
$iWidth += $iMax_ColWidth
Else
$iWidth += $aiColWidth[$i]
EndIf
Next
EndIf
If $iWidth > @DesktopWidth - 100 Then
$iWidth = @DesktopWidth - 100
ElseIf $iWidth < $iMinSize Then
$iWidth = $iMinSize
EndIf
Local $tRECT = DllStructCreate("struct; long Left;long Top;long Right;long Bottom; endstruct")
DllCall("user32.dll", "struct*", "SendMessageW", "hwnd", GUICtrlGetHandle($idListView), "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $tRECT)
Local $aiWin_Pos = WinGetPos($hGUI)
Local $aiLV_Pos = ControlGetPos($hGUI, "", $idListView)
$iHeight = (($iRowIndex + 4) * (DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top"))) + $aiWin_Pos[3] - $aiLV_Pos[3]
If $iHeight > @DesktopHeight - 100 Then
$iHeight = @DesktopHeight - 100
ElseIf $iHeight < $iMinSize Then
$iHeight = $iMinSize
EndIf
If $iVerbose Then SplashOff()
GUISetState(@SW_HIDE, $hGUI)
WinMove($hGUI, "", (@DesktopWidth - $iWidth) / 2, (@DesktopHeight - $iHeight) / 2, $iWidth, $iHeight)
GUISetState(@SW_SHOW, $hGUI)
Local $iOnEventMode = Opt("GUIOnEventMode", 0), $iMsg
__ArrayDisplay_RegisterSortCallBack($idListView, 2, True, "__ArrayDisplay_SortCallBack")
While 1
$iMsg = GUIGetMsg()
Switch $iMsg
Case $_ARRAYCONSTANT_GUI_EVENT_CLOSE
ExitLoop
Case $idCopy_ID, $idCopy_Data
Local $iSel_Count = GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
If $iVerbose And (Not $iSel_Count) And ($iItem_End - $iItem_Start) * ($iSubItem_End - $iSubItem_Start) > 10000 Then
SplashTextOn($sMsgBoxTitle, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
EndIf
Local $sClip = "", $sItem, $aSplit
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
If $iSel_Count And Not (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
ContinueLoop
EndIf
$sItem = __ArrayDisplay_GetItemTextString($idListView, $i)
If $iMsg = $idCopy_ID And $iNoRow Then
$sItem = "Row " & ($i + (($iTranspose) ? ($iSubItem_Start) : ($iItem_Start))) & $sCurr_Separator & $sItem
EndIf
If $iMsg = $idCopy_Data And Not $iNoRow Then
$sItem = StringRegExpReplace($sItem, "^Row\s\d+\|(.*)$", "$1")
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip &= $sItem & @CRLF
Next
$sItem = $sHeader
If $iMsg = $idCopy_ID Then
$sItem = $sHeader
If $iNoRow Then
$sItem = "Row|" & $sItem
EndIf
If $iCW_ColWidth Then
$aSplit = StringSplit($sItem, $sCurr_Separator)
$sItem = ""
For $j = 1 To $aSplit[0]
$sItem &= StringFormat("%-" & $iCW_ColWidth + 1 & "s", StringLeft($aSplit[$j], $iCW_ColWidth))
Next
Else
$sItem = StringReplace($sItem, $sCurr_Separator, $vUser_Separator)
EndIf
$sClip = $sItem & @CRLF & $sClip
EndIf
ClipPut($sClip)
SplashOff()
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idListView
__ArrayDisplay_SortItems($idListView, GUICtrlGetState($idListView))
Case $idUser_Func
Local $aiSelItems[1] = [0]
For $i = 0 To GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
If (GUICtrlSendMsg($idListView, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $i, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) Then
$aiSelItems[0] += 1
ReDim $aiSelItems[$aiSelItems[0] + 1]
$aiSelItems[$aiSelItems[0]] = $i + $iItem_Start
EndIf
Next
$hUser_Function($aArray, $aiSelItems)
GUICtrlSetState($idListView, $_ARRAYCONSTANT_GUI_FOCUS)
Case $idExit_Script
GUIDelete($hGUI)
Exit
EndSwitch
WEnd
GUIDelete($hGUI)
Opt("GUICoordMode", $iCoordMode)
Opt("GUIOnEventMode", $iOnEventMode)
Return 1
EndFunc
Func __ArrayDisplay_RegisterSortCallBack($hWnd, $vCompareType = 2, $bArrows = True, $sSort_Callback = "__ArrayDisplay_SortCallBack")
#Au3Stripper_Ignore_Funcs=$sSort_Callback
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $hHeader =  HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
$__g_aArrayDisplay_SortInfo[1] = $hWnd
$__g_aArrayDisplay_SortInfo[2] = DllCallbackRegister($sSort_Callback, "int", "int;int;hwnd")
$__g_aArrayDisplay_SortInfo[3] = -1
$__g_aArrayDisplay_SortInfo[4] = -1
$__g_aArrayDisplay_SortInfo[5] = 1
$__g_aArrayDisplay_SortInfo[6] = -1
$__g_aArrayDisplay_SortInfo[7] = 0
$__g_aArrayDisplay_SortInfo[8] = $vCompareType
$__g_aArrayDisplay_SortInfo[9] = $bArrows
$__g_aArrayDisplay_SortInfo[10] = $hHeader
Return $__g_aArrayDisplay_SortInfo[2] <> 0
EndFunc
#Au3Stripper_Ignore_Funcs=__ArrayDisplay_SortCallBack
Func __ArrayDisplay_SortCallBack($nItem1, $nItem2, $hWnd)
If $__g_aArrayDisplay_SortInfo[3] = $__g_aArrayDisplay_SortInfo[4] Then
If Not $__g_aArrayDisplay_SortInfo[7] Then
$__g_aArrayDisplay_SortInfo[5] *= -1
$__g_aArrayDisplay_SortInfo[7] = 1
EndIf
Else
$__g_aArrayDisplay_SortInfo[7] = 1
EndIf
$__g_aArrayDisplay_SortInfo[6] = $__g_aArrayDisplay_SortInfo[3]
Local $sVal1 = __ArrayDisplay_GetItemText($hWnd, $nItem1, $__g_aArrayDisplay_SortInfo[3])
Local $sVal2 = __ArrayDisplay_GetItemText($hWnd, $nItem2, $__g_aArrayDisplay_SortInfo[3])
If $__g_aArrayDisplay_SortInfo[8] = 1 Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
Local $nResult
If $__g_aArrayDisplay_SortInfo[8] < 2 Then
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
Else
$nResult = DllCall('shlwapi.dll', 'int', 'StrCmpLogicalW', 'wstr', $sVal1, 'wstr', $sVal2)[0]
EndIf
$nResult = $nResult * $__g_aArrayDisplay_SortInfo[5]
Return $nResult
EndFunc
Func __ArrayDisplay_SortItems($hWnd, $iCol)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Local $pFunction = DllCallbackGetPtr($__g_aArrayDisplay_SortInfo[2])
$__g_aArrayDisplay_SortInfo[3] = $iCol
$__g_aArrayDisplay_SortInfo[7] = 0
$__g_aArrayDisplay_SortInfo[4] = $__g_aArrayDisplay_SortInfo[6]
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1051, "hwnd", $hWnd, "ptr", $pFunction)
If $aResult[0] <> 0 Then
If $__g_aArrayDisplay_SortInfo[9] Then
Local $hHeader = $__g_aArrayDisplay_SortInfo[10], $iFormat
For $x = 0 To __ArrayDisplay_GetItemCount($hHeader) - 1
$iFormat = __ArrayDisplay_GetItemFormat($hHeader, $x)
If BitAND($iFormat, 0x00000200) Then
__ArrayDisplay_SetItemFormat($hHeader, $x, BitXOR($iFormat, 0x00000200))
ElseIf BitAND($iFormat, 0x00000400) Then
__ArrayDisplay_SetItemFormat($hHeader, $x, BitXOR($iFormat, 0x00000400))
EndIf
Next
$iFormat = __ArrayDisplay_GetItemFormat($hHeader, $iCol)
If $__g_aArrayDisplay_SortInfo[5] = 1 Then
__ArrayDisplay_SetItemFormat($hHeader, $iCol, BitOR($iFormat, 0x00000400))
Else
__ArrayDisplay_SetItemFormat($hHeader, $iCol, BitOR($iFormat, 0x00000200))
EndIf
EndIf
Return True
EndIf
Return False
EndFunc
Func __ArrayDisplay_AddItem($hWnd, $sText)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
DllStructSetData($tItem, "Param", 0)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iMask = 0x00000005
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", 999999999)
DllStructSetData($tItem, "Image", -1)
Local $pItem = DllStructGetPtr($tItem)
Local $iRet = GUICtrlSendMsg($hWnd, 0x104D, 0, $pItem)
Return $iRet
EndFunc
Func __ArrayDisplay_AddSubItem($hWnd, $iIndex, $sText, $iSubItem)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
Local $iMask = 0x00000001
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", -1)
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
Local $iRet = GUICtrlSendMsg($hWnd, 0x104C, 0, $pItem)
Return $iRet <> 0
EndFunc
Func __ArrayDisplay_GetColumnCount($hWnd)
Local $hHeader = HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
Return __ArrayDisplay_GetItemCount($hHeader)
EndFunc
Func __ArrayDisplay_GetHeader($hWnd)
Return HWnd(GUICtrlSendMsg($hWnd, 0x101F, 0, 0))
EndFunc
Func __ArrayDisplay_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x120B, "wparam", $iIndex, "struct*", $tItem)
Return $aResult[0] <> 0
EndFunc
Func __ArrayDisplay_GetItemCount($hWnd)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1200, "wparam", 0, "lparam", 0)
Return $aResult[0]
EndFunc
Func __ArrayDisplay_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagHDITEM)
DllStructSetData($tItem, "Mask", 0x00000004)
__ArrayDisplay_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func __ArrayDisplay_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $tBuffer = DllStructCreate("wchar Text[4096]")
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
DllStructSetData($tItem, "Text", $pBuffer)
If IsHWnd($hWnd) Then
DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x1073, "wparam", $iIndex, "struct*", $tItem)
Else
Local $pItem = DllStructGetPtr($tItem)
GUICtrlSendMsg($hWnd, 0x1073, $iIndex, $pItem)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func __ArrayDisplay_GetItemTextString($hWnd, $iItem)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iSelected = $iItem
For $x = 0 To __ArrayDisplay_GetColumnCount($hWnd) - 1
$sRow &= __ArrayDisplay_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func __ArrayDisplay_JustifyColumn($idListView, $iIndex, $iAlign = -1)
Local $tColumn = DllStructCreate("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
DllStructSetData($tColumn, "Mask", 0x01)
DllStructSetData($tColumn, "Fmt", $iAlign)
Local $pColumn = DllStructGetPtr($tColumn)
Local $iRet = GUICtrlSendMsg($idListView, 0x1060 , $iIndex, $pColumn)
Return $iRet <> 0
EndFunc
Func __ArrayDisplay_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($_ARRAYCONSTANT_tagHDITEM)
DllStructSetData($tItem, "Mask", 0x00000004)
DllStructSetData($tItem, "Fmt", $iFormat)
Local $aResult = DllCall("user32.dll", "lresult", "SendMessageW", "hwnd", $hWnd, "uint", 0x120C, "wparam", $iIndex, "struct*", $tItem)
Return $aResult[0] <> 0
EndFunc
Global Enum $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER,  $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
Global Enum $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
Global Enum $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
Func _ArrayAdd(ByRef $aArray, $vValue, $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
Case $ARRAYFILL_FORCE_BOOLEAN
$hDataType = "Boolean"
EndSwitch
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + 1]
$aArray[$iDim_1] = $vValue
Return $iDim_1
EndIf
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
EndIf
$vValue = $aTmp
EndIf
Local $iAdd = UBound($vValue, $UBOUND_ROWS)
ReDim $aArray[$iDim_1 + $iAdd]
For $i = 0 To $iAdd - 1
If String($hDataType) = "Boolean" Then
Switch $vValue[$i]
Case "True", "1"
$aArray[$iDim_1 + $i] = True
Case "False", "0", ""
$aArray[$iDim_1 + $i] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iDim_1 + $i] = $hDataType($vValue[$i])
Else
$aArray[$iDim_1 + $i] = $vValue[$i]
EndIf
Next
Return $iDim_1 + $iAdd - 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(4, 0, -1)
Local $iValDim_1, $iValDim_2 = 0, $iColCount
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(5, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
Local $aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
Local $aTmp[$iValDim_1][0], $aSplit_2
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iColCount = UBound($aSplit_2)
If $iColCount > $iValDim_2 Then
$iValDim_2 = $iColCount
ReDim $aTmp[$iValDim_1][$iValDim_2]
EndIf
For $j = 0 To $iColCount - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1 + $iValDim_1][$iDim_2]
For $iWriteTo_Index = 0 To $iValDim_1 - 1
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = ""
Else
If String($hDataType) = "Boolean" Then
Switch $vValue[$iWriteTo_Index][$j - $iStart]
Case "True", "1"
$aArray[$iWriteTo_Index + $iDim_1][$j] = True
Case "False", "0", ""
$aArray[$iWriteTo_Index + $iDim_1][$j] = False
EndSwitch
ElseIf IsFunc($hDataType) Then
$aArray[$iWriteTo_Index + $iDim_1][$j] = $hDataType($vValue[$iWriteTo_Index][$j - $iStart])
Else
$aArray[$iWriteTo_Index + $iDim_1][$j] = $vValue[$iWriteTo_Index][$j - $iStart]
EndIf
EndIf
Next
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS) - 1
EndFunc
Func _ArrayBinarySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iColumn = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iColumn = Default Then $iColumn = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iDim_1 = 0 Then Return SetError(6, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_1 - 1 Then $iEnd = $iDim_1 - 1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Local $iMid = Int(($iEnd + $iStart) / 2)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $aArray[$iStart] > $vValue Or $aArray[$iEnd] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid]
If $vValue < $aArray[$iMid] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(7, 0, -1)
If $aArray[$iStart][$iColumn] > $vValue Or $aArray[$iEnd][$iColumn] < $vValue Then Return SetError(2, 0, -1)
While $iStart <= $iMid And $vValue <> $aArray[$iMid][$iColumn]
If $vValue < $aArray[$iMid][$iColumn] Then
$iEnd = $iMid - 1
Else
$iStart = $iMid + 1
EndIf
$iMid = Int(($iEnd + $iStart) / 2)
WEnd
If $iStart > $iEnd Then Return SetError(3, 0, -1)
Case Else
Return SetError(5, 0, -1)
EndSwitch
Return $iMid
EndFunc
Func _ArrayColDelete(ByRef $aArray, $iColumn, $bConvert = False)
If $bConvert = Default Then $bConvert = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(2, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
Switch $iDim_2
Case 2
If $iColumn < 0 Or $iColumn > 1 Then Return SetError(3, 0, -1)
If $bConvert Then
Local $aTempArray[$iDim_1]
For $i = 0 To $iDim_1 - 1
$aTempArray[$i] = $aArray[$i][(Not $iColumn)]
Next
$aArray = $aTempArray
Else
ContinueCase
EndIf
Case Else
If $iColumn < 0 Or $iColumn > $iDim_2 - 1 Then Return SetError(3, 0, -1)
For $i = 0 To $iDim_1 - 1
For $j = $iColumn To $iDim_2 - 2
$aArray[$i][$j] = $aArray[$i][$j + 1]
Next
Next
ReDim $aArray[$iDim_1][$iDim_2 - 1]
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayColInsert(ByRef $aArray, $iColumn)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aTempArray[$iDim_1][2]
Switch $iColumn
Case 0, 1
For $i = 0 To $iDim_1 - 1
$aTempArray[$i][(Not $iColumn)] = $aArray[$i]
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
$aArray = $aTempArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iColumn < 0 Or $iColumn > $iDim_2 Then Return SetError(3, 0, -1)
ReDim $aArray[$iDim_1][$iDim_2 + 1]
For $i = 0 To $iDim_1 - 1
For $j = $iDim_2 To $iColumn + 1 Step -1
$aArray[$i][$j] = $aArray[$i][$j - 1]
Next
$aArray[$i][$iColumn] = ""
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_COLUMNS)
EndFunc
Func _ArrayCombinations(Const ByRef $aArray, $iSet, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iN = UBound($aArray)
Local $iR = $iSet
Local $aIdx[$iR]
For $i = 0 To $iR - 1
$aIdx[$i] = $i
Next
Local $iTotal = __Array_Combinations($iN, $iR)
Local $iLeft = $iTotal
Local $aResult[$iTotal + 1]
$aResult[0] = $iTotal
Local $iCount = 1
While $iLeft > 0
__Array_GetNext($iN, $iR, $iLeft, $iTotal, $aIdx)
For $i = 0 To $iSet - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], 1)
$iCount += 1
WEnd
Return $aResult
EndFunc
Func _ArrayConcatenate(ByRef $aArrayTarget, Const ByRef $aArraySource, $iStart = 0)
If $iStart = Default Then $iStart = 0
If Not IsArray($aArrayTarget) Then Return SetError(1, 0, -1)
If Not IsArray($aArraySource) Then Return SetError(2, 0, -1)
Local $iDim_Total_Tgt = UBound($aArrayTarget, $UBOUND_DIMENSIONS)
Local $iDim_Total_Src = UBound($aArraySource, $UBOUND_DIMENSIONS)
Local $iDim_1_Tgt = UBound($aArrayTarget, $UBOUND_ROWS)
Local $iDim_1_Src = UBound($aArraySource, $UBOUND_ROWS)
If $iStart < 0 Or $iStart > $iDim_1_Src - 1 Then Return SetError(6, 0, -1)
Switch $iDim_Total_Tgt
Case 1
If $iDim_Total_Src <> 1 Then Return SetError(4, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart]
For $i = $iStart To $iDim_1_Src - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart] = $aArraySource[$i]
Next
Case 2
If $iDim_Total_Src <> 2 Then Return SetError(4, 0, -1)
Local $iDim_2_Tgt = UBound($aArrayTarget, $UBOUND_COLUMNS)
If UBound($aArraySource, $UBOUND_COLUMNS) <> $iDim_2_Tgt Then Return SetError(5, 0, -1)
ReDim $aArrayTarget[$iDim_1_Tgt + $iDim_1_Src - $iStart][$iDim_2_Tgt]
For $i = $iStart To $iDim_1_Src - 1
For $j = 0 To $iDim_2_Tgt - 1
$aArrayTarget[$iDim_1_Tgt + $i - $iStart][$j] = $aArraySource[$i][$j]
Next
Next
Case Else
Return SetError(3, 0, -1)
EndSwitch
Return UBound($aArrayTarget, $UBOUND_ROWS)
EndFunc
Func _ArrayDelete(ByRef $aArray, $vRange)
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber, $aSplit_1, $aSplit_2
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
Local $iCopyTo_Index = 0
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
$aArray[$iCopyTo_Index] = $aArray[$iReadFrom_Index]
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1]
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
For $i = 1 To $vRange[0]
$aArray[$vRange[$i]][0] = ChrW(0xFAB1)
Next
For $iReadFrom_Index = 0 To $iDim_1
If $aArray[$iReadFrom_Index][0] == ChrW(0xFAB1) Then
ContinueLoop
Else
If $iReadFrom_Index <> $iCopyTo_Index Then
For $j = 0 To $iDim_2
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFrom_Index][$j]
Next
EndIf
$iCopyTo_Index += 1
EndIf
Next
ReDim $aArray[$iDim_1 - $vRange[0] + 1][$iDim_2 + 1]
Case Else
Return SetError(2, 0, False)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayDisplay(Const ByRef $aArray, $sTitle = Default, $sArrayRange = Default, $iFlags = Default, $vUser_Separator = Default, $sHeader = Default, $iMax_ColWidth = Default)
#forceref $vUser_Separator
Local $iRet = __ArrayDisplay_Share($aArray, $sTitle, $sArrayRange, $iFlags, Default, $sHeader, $iMax_ColWidth, 0, False)
Return SetError(@error, @extended, $iRet)
EndFunc
Func _ArrayExtract(Const ByRef $aArray, $iStart_Row = -1, $iEnd_Row = -1, $iStart_Col = -1, $iEnd_Col = -1)
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
For $i = 0 To $iEnd_Row - $iStart_Row
$aRetArray[$i] = $aArray[$i + $iStart_Row]
Next
Return $aRetArray
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col = -1 Then $iStart_Col = 0
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
If $iStart_Col = $iEnd_Col Then
Local $aRetArray[$iEnd_Row - $iStart_Row + 1]
Else
Local $aRetArray[$iEnd_Row - $iStart_Row + 1][$iEnd_Col - $iStart_Col + 1]
EndIf
For $i = 0 To $iEnd_Row - $iStart_Row
For $j = 0 To $iEnd_Col - $iStart_Col
If $iStart_Col = $iEnd_Col Then
$aRetArray[$i] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
Else
$aRetArray[$i][$j] = $aArray[$i + $iStart_Row][$j + $iStart_Col]
EndIf
Next
Next
Return $aRetArray
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayFindAll(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iSubItem = 0, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iSubItem = Default Then $iSubItem = 0
If $bRow = Default Then $bRow = False
$iStart = _ArraySearch($aArray, $vValue, $iStart, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
If @error Then Return SetError(@error, 0, -1)
Local $iIndex = 0, $avResult[UBound($aArray, ($bRow ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
Do
$avResult[$iIndex] = $iStart
$iIndex += 1
$iStart = _ArraySearch($aArray, $vValue, $iStart + 1, $iEnd, $iCase, $iCompare, 1, $iSubItem, $bRow)
Until @error
ReDim $avResult[$iIndex]
Return $avResult
EndFunc
Func _ArrayInsert(ByRef $aArray, $vRange, $vValue = "", $iStart = 0, $sDelim_Item = "|", $sDelim_Row = @CRLF, $iForce = $ARRAYFILL_FORCE_DEFAULT)
If $vValue = Default Then $vValue = ""
If $iStart = Default Then $iStart = 0
If $sDelim_Item = Default Then $sDelim_Item = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iForce = Default Then $iForce = $ARRAYFILL_FORCE_DEFAULT
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $hDataType = 0
Switch $iForce
Case $ARRAYFILL_FORCE_INT
$hDataType = Int
Case $ARRAYFILL_FORCE_NUMBER
$hDataType = Number
Case $ARRAYFILL_FORCE_PTR
$hDataType = Ptr
Case $ARRAYFILL_FORCE_HWND
$hDataType = Hwnd
Case $ARRAYFILL_FORCE_STRING
$hDataType = String
EndSwitch
Local $aSplit_1, $aSplit_2
If IsArray($vRange) Then
If UBound($vRange, $UBOUND_DIMENSIONS) <> 1 Or UBound($vRange, $UBOUND_ROWS) < 2 Then Return SetError(4, 0, -1)
Else
Local $iNumber
$vRange = StringStripWS($vRange, 8)
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
If Not StringRegExp($aSplit_1[$i], "^\d+(-\d+)?$") Then Return SetError(3, 0, -1)
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
Switch $aSplit_2[0]
Case 1
$vRange &= $aSplit_2[1] & ";"
Case 2
If Number($aSplit_2[2]) >= Number($aSplit_2[1]) Then
$iNumber = $aSplit_2[1] - 1
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
EndIf
EndSwitch
Next
$vRange = StringSplit(StringTrimRight($vRange, 1), ";")
EndIf
If $vRange[1] < 0 Or $vRange[$vRange[0]] > $iDim_1 Then Return SetError(5, 0, -1)
For $i = 2 To $vRange[0]
If $vRange[$i] < $vRange[$i - 1] Then Return SetError(3, 0, -1)
Next
Local $iCopyTo_Index = $iDim_1 + $vRange[0]
Local $iInsertPoint_Index = $vRange[0]
Local $iInsert_Index = $vRange[$iInsertPoint_Index]
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iForce = $ARRAYFILL_FORCE_SINGLEITEM Then
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
$aArray[$iCopyTo_Index] = $vValue
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index < 1 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Return $iDim_1 + $vRange[0] + 1
EndIf
ReDim $aArray[$iDim_1 + $vRange[0] + 1]
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(5, 0, -1)
$hDataType = 0
Else
Local $aTmp = StringSplit($vValue, $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
If UBound($aTmp, $UBOUND_ROWS) = 1 Then
$aTmp[0] = $vValue
$hDataType = 0
EndIf
$vValue = $aTmp
EndIf
For $iReadFromIndex = $iDim_1 To 0 Step -1
$aArray[$iCopyTo_Index] = $aArray[$iReadFromIndex]
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
If $iInsertPoint_Index <= UBound($vValue, $UBOUND_ROWS) Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index] = $hDataType($vValue[$iInsertPoint_Index - 1])
Else
$aArray[$iCopyTo_Index] = $vValue[$iInsertPoint_Index - 1]
EndIf
Else
$aArray[$iCopyTo_Index] = ""
EndIf
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iStart < 0 Or $iStart > $iDim_2 - 1 Then Return SetError(6, 0, -1)
Local $iValDim_1, $iValDim_2
If IsArray($vValue) Then
If UBound($vValue, $UBOUND_DIMENSIONS) <> 2 Then Return SetError(7, 0, -1)
$iValDim_1 = UBound($vValue, $UBOUND_ROWS)
$iValDim_2 = UBound($vValue, $UBOUND_COLUMNS)
$hDataType = 0
Else
$aSplit_1 = StringSplit($vValue, $sDelim_Row, $STR_NOCOUNT + $STR_ENTIRESPLIT)
$iValDim_1 = UBound($aSplit_1, $UBOUND_ROWS)
StringReplace($aSplit_1[0], $sDelim_Item, "")
$iValDim_2 = @extended + 1
Local $aTmp[$iValDim_1][$iValDim_2]
For $i = 0 To $iValDim_1 - 1
$aSplit_2 = StringSplit($aSplit_1[$i], $sDelim_Item, $STR_NOCOUNT + $STR_ENTIRESPLIT)
For $j = 0 To $iValDim_2 - 1
$aTmp[$i][$j] = $aSplit_2[$j]
Next
Next
$vValue = $aTmp
EndIf
If UBound($vValue, $UBOUND_COLUMNS) + $iStart > UBound($aArray, $UBOUND_COLUMNS) Then Return SetError(8, 0, -1)
ReDim $aArray[$iDim_1 + $vRange[0] + 1][$iDim_2]
For $iReadFromIndex = $iDim_1 To 0 Step -1
For $j = 0 To $iDim_2 - 1
$aArray[$iCopyTo_Index][$j] = $aArray[$iReadFromIndex][$j]
Next
$iCopyTo_Index -= 1
$iInsert_Index = $vRange[$iInsertPoint_Index]
While $iReadFromIndex = $iInsert_Index
For $j = 0 To $iDim_2 - 1
If $j < $iStart Then
$aArray[$iCopyTo_Index][$j] = ""
ElseIf $j - $iStart > $iValDim_2 - 1 Then
$aArray[$iCopyTo_Index][$j] = ""
Else
If $iInsertPoint_Index - 1 < $iValDim_1 Then
If IsFunc($hDataType) Then
$aArray[$iCopyTo_Index][$j] = $hDataType($vValue[$iInsertPoint_Index - 1][$j - $iStart])
Else
$aArray[$iCopyTo_Index][$j] = $vValue[$iInsertPoint_Index - 1][$j - $iStart]
EndIf
Else
$aArray[$iCopyTo_Index][$j] = ""
EndIf
EndIf
Next
$iCopyTo_Index -= 1
$iInsertPoint_Index -= 1
If $iInsertPoint_Index = 0 Then ExitLoop 2
$iInsert_Index = $vRange[$iInsertPoint_Index]
WEnd
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return UBound($aArray, $UBOUND_ROWS)
EndFunc
Func _ArrayMax(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMaxIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_GreaterThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayMin(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
Local $iResult = _ArrayMinIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem)
If @error Then Return SetError(@error, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then
Return $aArray[$iResult]
Else
Return $aArray[$iResult][$iSubItem]
EndIf
EndFunc
Func _ArrayMinIndex(Const ByRef $aArray, $iCompNumeric = 0, $iStart = -1, $iEnd = -1, $iSubItem = 0)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If $iSubItem = Default Then $iSubItem = 0
Local $iRet = __Array_MinMaxIndex($aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, __Array_LessThan)
Return SetError(@error, 0, $iRet)
EndFunc
Func _ArrayPermute(ByRef $aArray, $sDelimiter = "")
If $sDelimiter = Default Then $sDelimiter = ""
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, 0)
Local $iSize = UBound($aArray), $iFactorial = 1, $aIdx[$iSize], $aResult[1], $iCount = 1
If UBound($aArray) Then
For $i = 0 To $iSize - 1
$aIdx[$i] = $i
Next
For $i = $iSize To 1 Step -1
$iFactorial *= $i
Next
ReDim $aResult[$iFactorial + 1]
$aResult[0] = $iFactorial
__Array_ExeterInternal($aArray, 0, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
Else
$aResult[0] = 0
EndIf
Return $aResult
EndFunc
Func _ArrayPop(ByRef $aArray)
If (Not IsArray($aArray)) Then Return SetError(1, 0, "")
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(2, 0, "")
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(3, 0, "")
Local $sLastVal = $aArray[$iUBound]
If $iUBound > -1 Then
ReDim $aArray[$iUBound]
EndIf
Return $sLastVal
EndFunc
Func _ArrayPush(ByRef $aArray, $vValue, $iDirection = 0)
If $iDirection = Default Then $iDirection = 0
If (Not IsArray($aArray)) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
Local $iUBound = UBound($aArray) - 1
If IsArray($vValue) Then
Local $iUBoundS = UBound($vValue)
If ($iUBoundS - 1) > $iUBound Then Return SetError(2, 0, 0)
If $iDirection Then
For $i = $iUBound To $iUBoundS Step -1
$aArray[$i] = $aArray[$i - $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i] = $vValue[$i]
Next
Else
For $i = 0 To $iUBound - $iUBoundS
$aArray[$i] = $aArray[$i + $iUBoundS]
Next
For $i = 0 To $iUBoundS - 1
$aArray[$i + $iUBound - $iUBoundS + 1] = $vValue[$i]
Next
EndIf
Else
If $iUBound > -1 Then
If $iDirection Then
For $i = $iUBound To 1 Step -1
$aArray[$i] = $aArray[$i - 1]
Next
$aArray[0] = $vValue
Else
For $i = 0 To $iUBound - 1
$aArray[$i] = $aArray[$i + 1]
Next
$aArray[$iUBound] = $vValue
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _ArrayReverse(ByRef $aArray, $iStart = 0, $iEnd = 0)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
If UBound($aArray, $UBOUND_DIMENSIONS) <> 1 Then Return SetError(3, 0, 0)
If Not UBound($aArray) Then Return SetError(4, 0, 0)
Local $vTmp, $iUBound = UBound($aArray) - 1
If $iEnd < 1 Or $iEnd > $iUBound Then $iEnd = $iUBound
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
For $i = $iStart To Int(($iStart + $iEnd - 1) / 2)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iEnd]
$aArray[$iEnd] = $vTmp
$iEnd -= 1
Next
Return 1
EndFunc
Func _ArraySearch(Const ByRef $aArray, $vValue, $iStart = 0, $iEnd = 0, $iCase = 0, $iCompare = 0, $iForward = 1, $iSubItem = -1, $bRow = False)
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iCase = Default Then $iCase = 0
If $iCompare = Default Then $iCompare = 0
If $iForward = Default Then $iForward = 1
If $iSubItem = Default Then $iSubItem = -1
If $bRow = Default Then $bRow = False
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray) - 1
If $iDim_1 = -1 Then Return SetError(3, 0, -1)
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
Local $bCompType = False
If $iCompare = 2 Then
$iCompare = 0
$bCompType = True
EndIf
If $bRow Then
If UBound($aArray, $UBOUND_DIMENSIONS) = 1 Then Return SetError(5, 0, -1)
If $iEnd < 1 Or $iEnd > $iDim_2 Then $iEnd = $iDim_2
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Else
If $iEnd < 1 Or $iEnd > $iDim_1 Then $iEnd = $iDim_1
If $iStart < 0 Then $iStart = 0
If $iStart > $iEnd Then Return SetError(4, 0, -1)
EndIf
Local $iStep = 1
If Not $iForward Then
Local $iTmp = $iStart
$iStart = $iEnd
$iEnd = $iTmp
$iStep = -1
EndIf
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] = $vValue Then Return $i
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bCompType And VarGetType($aArray[$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i] == $vValue Then Return $i
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If StringRegExp($aArray[$i], $vValue) Then Return $i
Else
If StringInStr($aArray[$i], $vValue, $iCase) > 0 Then Return $i
EndIf
Next
EndIf
Case 2
Local $iDim_Sub
If $bRow Then
$iDim_Sub = $iDim_1
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
Else
$iDim_Sub = $iDim_2
If $iSubItem > $iDim_Sub Then $iSubItem = $iDim_Sub
If $iSubItem < 0 Then
$iSubItem = 0
Else
$iDim_Sub = $iSubItem
EndIf
EndIf
For $j = $iSubItem To $iDim_Sub
If Not $iCompare Then
If Not $iCase Then
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] = $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] = $vValue Then Return $i
EndIf
Next
Else
For $i = $iStart To $iEnd Step $iStep
If $bRow Then
If $bCompType And VarGetType($aArray[$j][$i]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$j][$i] == $vValue Then Return $i
Else
If $bCompType And VarGetType($aArray[$i][$j]) <> VarGetType($vValue) Then ContinueLoop
If $aArray[$i][$j] == $vValue Then Return $i
EndIf
Next
EndIf
Else
For $i = $iStart To $iEnd Step $iStep
If $iCompare = 3 Then
If $bRow Then
If StringRegExp($aArray[$j][$i], $vValue) Then Return $i
Else
If StringRegExp($aArray[$i][$j], $vValue) Then Return $i
EndIf
Else
If $bRow Then
If StringInStr($aArray[$j][$i], $vValue, $iCase) > 0 Then Return $i
Else
If StringInStr($aArray[$i][$j], $vValue, $iCase) > 0 Then Return $i
EndIf
EndIf
Next
EndIf
Next
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return SetError(6, 0, -1)
EndFunc
Func _ArrayShuffle(ByRef $aArray, $iStart_Row = 0, $iEnd_Row = 0, $iCol = -1)
If $iStart_Row = Default Then $iStart_Row = 0
If $iEnd_Row = Default Then $iEnd_Row = 0
If $iCol = Default Then $iCol = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS)
If $iEnd_Row = 0 Then $iEnd_Row = $iDim_1 - 1
If $iStart_Row < 0 Or $iStart_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iEnd_Row < 1 Or $iEnd_Row > $iDim_1 - 1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $vTmp, $iRand
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
$vTmp = $aArray[$i]
$aArray[$i] = $aArray[$iRand]
$aArray[$iRand] = $vTmp
Next
Return 1
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS)
If $iCol < -1 Or $iCol > $iDim_2 - 1 Then Return SetError(5, 0, -1)
Local $iCol_Start, $iCol_End
If $iCol = -1 Then
$iCol_Start = 0
$iCol_End = $iDim_2 - 1
Else
$iCol_Start = $iCol
$iCol_End = $iCol
EndIf
For $i = $iEnd_Row To $iStart_Row + 1 Step -1
$iRand = Random($iStart_Row, $i, 1)
For $j = $iCol_Start To $iCol_End
$vTmp = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$iRand][$j]
$aArray[$iRand][$j] = $vTmp
Next
Next
Return 1
Case Else
Return SetError(2, 0, -1)
EndSwitch
EndFunc
Func _ArraySort(ByRef $aArray, $iDescending = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0, $iPivot = 0)
If $iDescending = Default Then $iDescending = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If $iPivot = Default Then $iPivot = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iUBound = UBound($aArray) - 1
If $iUBound = -1 Then Return SetError(5, 0, 0)
If $iEnd = Default Then $iEnd = 0
If $iEnd < 1 Or $iEnd > $iUBound Or $iEnd = Default Then $iEnd = $iUBound
If $iStart < 0 Or $iStart = Default Then $iStart = 0
If $iStart > $iEnd Then Return SetError(2, 0, 0)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iPivot Then
__ArrayDualPivotSort($aArray, $iStart, $iEnd)
Else
__ArrayQuickSort1D($aArray, $iStart, $iEnd)
EndIf
If $iDescending Then _ArrayReverse($aArray, $iStart, $iEnd)
Case 2
If $iPivot Then Return SetError(6, 0, 0)
Local $iSubMax = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem > $iSubMax Then Return SetError(3, 0, 0)
If $iDescending Then
$iDescending = -1
Else
$iDescending = 1
EndIf
__ArrayQuickSort2D($aArray, $iDescending, $iStart, $iEnd, $iSubItem, $iSubMax)
Case Else
Return SetError(4, 0, 0)
EndSwitch
Return 1
EndFunc
Func __ArrayQuickSort1D(ByRef $aArray, Const ByRef $iStart, Const ByRef $iEnd)
If $iEnd <= $iStart Then Return
Local $vTmp
If ($iEnd - $iStart) < 15 Then
Local $vCur
For $i = $iStart + 1 To $iEnd
$vTmp = $aArray[$i]
If IsNumber($vTmp) Then
For $j = $i - 1 To $iStart Step -1
$vCur = $aArray[$j]
If ($vTmp >= $vCur And IsNumber($vCur)) Or (Not IsNumber($vCur) And StringCompare($vTmp, $vCur) >= 0) Then ExitLoop
$aArray[$j + 1] = $vCur
Next
Else
For $j = $i - 1 To $iStart Step -1
If (StringCompare($vTmp, $aArray[$j]) >= 0) Then ExitLoop
$aArray[$j + 1] = $aArray[$j]
Next
EndIf
$aArray[$j + 1] = $vTmp
Next
Return
EndIf
Local $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($aArray[$L] < $vPivot And IsNumber($aArray[$L])) Or (Not IsNumber($aArray[$L]) And StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While ($aArray[$R] > $vPivot And IsNumber($aArray[$R])) Or (Not IsNumber($aArray[$R]) And StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
Else
While (StringCompare($aArray[$L], $vPivot) < 0)
$L += 1
WEnd
While (StringCompare($aArray[$R], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
$vTmp = $aArray[$L]
$aArray[$L] = $aArray[$R]
$aArray[$R] = $vTmp
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort1D($aArray, $iStart, $R)
__ArrayQuickSort1D($aArray, $L, $iEnd)
EndFunc
Func __ArrayQuickSort2D(ByRef $aArray, Const ByRef $iStep, Const ByRef $iStart, Const ByRef $iEnd, Const ByRef $iSubItem, Const ByRef $iSubMax)
If $iEnd <= $iStart Then Return
Local $vTmp, $L = $iStart, $R = $iEnd, $vPivot = $aArray[Int(($iStart + $iEnd) / 2)][$iSubItem], $bNum = IsNumber($vPivot)
Do
If $bNum Then
While ($iStep * ($aArray[$L][$iSubItem] - $vPivot) < 0 And IsNumber($aArray[$L][$iSubItem])) Or (Not IsNumber($aArray[$L][$iSubItem]) And $iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * ($aArray[$R][$iSubItem] - $vPivot) > 0 And IsNumber($aArray[$R][$iSubItem])) Or (Not IsNumber($aArray[$R][$iSubItem]) And $iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
Else
While ($iStep * StringCompare($aArray[$L][$iSubItem], $vPivot) < 0)
$L += 1
WEnd
While ($iStep * StringCompare($aArray[$R][$iSubItem], $vPivot) > 0)
$R -= 1
WEnd
EndIf
If $L <= $R Then
For $i = 0 To $iSubMax
$vTmp = $aArray[$L][$i]
$aArray[$L][$i] = $aArray[$R][$i]
$aArray[$R][$i] = $vTmp
Next
$L += 1
$R -= 1
EndIf
Until $L > $R
__ArrayQuickSort2D($aArray, $iStep, $iStart, $R, $iSubItem, $iSubMax)
__ArrayQuickSort2D($aArray, $iStep, $L, $iEnd, $iSubItem, $iSubMax)
EndFunc
Func __ArrayDualPivotSort(ByRef $aArray, $iPivot_Left, $iPivot_Right, $bLeftMost = True)
If $iPivot_Left > $iPivot_Right Then Return
Local $iLength = $iPivot_Right - $iPivot_Left + 1
Local $i, $j, $k, $iAi, $iAk, $iA1, $iA2, $iLast
If $iLength < 45 Then
If $bLeftMost Then
$i = $iPivot_Left
While $i < $iPivot_Right
$j = $i
$iAi = $aArray[$i + 1]
While $iAi < $aArray[$j]
$aArray[$j + 1] = $aArray[$j]
$j -= 1
If $j + 1 = $iPivot_Left Then ExitLoop
WEnd
$aArray[$j + 1] = $iAi
$i += 1
WEnd
Else
While 1
If $iPivot_Left >= $iPivot_Right Then Return 1
$iPivot_Left += 1
If $aArray[$iPivot_Left] < $aArray[$iPivot_Left - 1] Then ExitLoop
WEnd
While 1
$k = $iPivot_Left
$iPivot_Left += 1
If $iPivot_Left > $iPivot_Right Then ExitLoop
$iA1 = $aArray[$k]
$iA2 = $aArray[$iPivot_Left]
If $iA1 < $iA2 Then
$iA2 = $iA1
$iA1 = $aArray[$iPivot_Left]
EndIf
$k -= 1
While $iA1 < $aArray[$k]
$aArray[$k + 2] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 2] = $iA1
While $iA2 < $aArray[$k]
$aArray[$k + 1] = $aArray[$k]
$k -= 1
WEnd
$aArray[$k + 1] = $iA2
$iPivot_Left += 1
WEnd
$iLast = $aArray[$iPivot_Right]
$iPivot_Right -= 1
While $iLast < $aArray[$iPivot_Right]
$aArray[$iPivot_Right + 1] = $aArray[$iPivot_Right]
$iPivot_Right -= 1
WEnd
$aArray[$iPivot_Right + 1] = $iLast
EndIf
Return 1
EndIf
Local $iSeventh = BitShift($iLength, 3) + BitShift($iLength, 6) + 1
Local $iE1, $iE2, $iE3, $iE4, $iE5, $t
$iE3 = Ceiling(($iPivot_Left + $iPivot_Right) / 2)
$iE2 = $iE3 - $iSeventh
$iE1 = $iE2 - $iSeventh
$iE4 = $iE3 + $iSeventh
$iE5 = $iE4 + $iSeventh
If $aArray[$iE2] < $aArray[$iE1] Then
$t = $aArray[$iE2]
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
If $aArray[$iE3] < $aArray[$iE2] Then
$t = $aArray[$iE3]
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
If $aArray[$iE4] < $aArray[$iE3] Then
$t = $aArray[$iE4]
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
If $aArray[$iE5] < $aArray[$iE4] Then
$t = $aArray[$iE5]
$aArray[$iE5] = $aArray[$iE4]
$aArray[$iE4] = $t
If $t < $aArray[$iE3] Then
$aArray[$iE4] = $aArray[$iE3]
$aArray[$iE3] = $t
If $t < $aArray[$iE2] Then
$aArray[$iE3] = $aArray[$iE2]
$aArray[$iE2] = $t
If $t < $aArray[$iE1] Then
$aArray[$iE2] = $aArray[$iE1]
$aArray[$iE1] = $t
EndIf
EndIf
EndIf
EndIf
Local $iLess = $iPivot_Left
Local $iGreater = $iPivot_Right
If (($aArray[$iE1] <> $aArray[$iE2]) And ($aArray[$iE2] <> $aArray[$iE3]) And ($aArray[$iE3] <> $aArray[$iE4]) And ($aArray[$iE4] <> $aArray[$iE5])) Then
Local $iPivot_1 = $aArray[$iE2]
Local $iPivot_2 = $aArray[$iE4]
$aArray[$iE2] = $aArray[$iPivot_Left]
$aArray[$iE4] = $aArray[$iPivot_Right]
Do
$iLess += 1
Until $aArray[$iLess] >= $iPivot_1
Do
$iGreater -= 1
Until $aArray[$iGreater] <= $iPivot_2
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk > $iPivot_2 Then
While $aArray[$iGreater] > $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] < $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
$aArray[$iPivot_Left] = $aArray[$iLess - 1]
$aArray[$iLess - 1] = $iPivot_1
$aArray[$iPivot_Right] = $aArray[$iGreater + 1]
$aArray[$iGreater + 1] = $iPivot_2
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 2, True)
__ArrayDualPivotSort($aArray, $iGreater + 2, $iPivot_Right, False)
If ($iLess < $iE1) And ($iE5 < $iGreater) Then
While $aArray[$iLess] = $iPivot_1
$iLess += 1
WEnd
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
WEnd
$k = $iLess
While $k <= $iGreater
$iAk = $aArray[$k]
If $iAk = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
ElseIf $iAk = $iPivot_2 Then
While $aArray[$iGreater] = $iPivot_2
$iGreater -= 1
If $iGreater + 1 = $k Then ExitLoop 2
WEnd
If $aArray[$iGreater] = $iPivot_1 Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iPivot_1
$iLess += 1
Else
$aArray[$k] = $aArray[$iGreater]
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
EndIf
__ArrayDualPivotSort($aArray, $iLess, $iGreater, False)
Else
Local $iPivot = $aArray[$iE3]
$k = $iLess
While $k <= $iGreater
If $aArray[$k] = $iPivot Then
$k += 1
ContinueLoop
EndIf
$iAk = $aArray[$k]
If $iAk < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $iAk
$iLess += 1
Else
While $aArray[$iGreater] > $iPivot
$iGreater -= 1
WEnd
If $aArray[$iGreater] < $iPivot Then
$aArray[$k] = $aArray[$iLess]
$aArray[$iLess] = $aArray[$iGreater]
$iLess += 1
Else
$aArray[$k] = $iPivot
EndIf
$aArray[$iGreater] = $iAk
$iGreater -= 1
EndIf
$k += 1
WEnd
__ArrayDualPivotSort($aArray, $iPivot_Left, $iLess - 1, True)
__ArrayDualPivotSort($aArray, $iGreater + 1, $iPivot_Right, False)
EndIf
EndFunc
Func _ArraySwap(ByRef $aArray, $iIndex_1, $iIndex_2, $bCol = False, $iStart = -1, $iEnd = -1)
If $bCol = Default Then $bCol = False
If $iStart = Default Then $iStart = -1
If $iEnd = Default Then $iEnd = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iDim_2 = -1 Then
$bCol = False
$iStart = -1
$iEnd = -1
EndIf
If $iStart > $iEnd Then Return SetError(5, 0, -1)
If $bCol Then
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_2 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_1
Else
If $iIndex_1 < 0 Or $iIndex_2 > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart = -1 Then $iStart = 0
If $iEnd = -1 Then $iEnd = $iDim_2
EndIf
Local $vTmp
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
$vTmp = $aArray[$iIndex_1]
$aArray[$iIndex_1] = $aArray[$iIndex_2]
$aArray[$iIndex_2] = $vTmp
Case 2
If $iStart < -1 Or $iEnd < -1 Then Return SetError(4, 0, -1)
If $bCol Then
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$j][$iIndex_1]
$aArray[$j][$iIndex_1] = $aArray[$j][$iIndex_2]
$aArray[$j][$iIndex_2] = $vTmp
Next
Else
If $iStart > $iDim_2 Or $iEnd > $iDim_2 Then Return SetError(4, 0, -1)
For $j = $iStart To $iEnd
$vTmp = $aArray[$iIndex_1][$j]
$aArray[$iIndex_1][$j] = $aArray[$iIndex_2][$j]
$aArray[$iIndex_2][$j] = $vTmp
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayToClip(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
Local $sResult = _ArrayToString($aArray, $sDelim_Col, $iStart_Row, $iEnd_Row, $sDelim_Row, $iStart_Col, $iEnd_Col)
If @error Then Return SetError(@error, 0, 0)
If ClipPut($sResult) Then Return 1
Return SetError(-1, 0, 0)
EndFunc
Func _ArrayToString(Const ByRef $aArray, $sDelim_Col = "|", $iStart_Row = -1, $iEnd_Row = -1, $sDelim_Row = @CRLF, $iStart_Col = -1, $iEnd_Col = -1)
If $sDelim_Col = Default Then $sDelim_Col = "|"
If $sDelim_Row = Default Then $sDelim_Row = @CRLF
If $iStart_Row = Default Then $iStart_Row = -1
If $iEnd_Row = Default Then $iEnd_Row = -1
If $iStart_Col = Default Then $iStart_Col = -1
If $iEnd_Col = Default Then $iEnd_Col = -1
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iStart_Row = -1 Then $iStart_Row = 0
If $iEnd_Row = -1 Then $iEnd_Row = $iDim_1
If $iStart_Row < -1 Or $iEnd_Row < -1 Then Return SetError(3, 0, -1)
If $iStart_Row > $iDim_1 Or $iEnd_Row > $iDim_1 Then Return SetError(3, 0, "")
If $iStart_Row > $iEnd_Row Then Return SetError(4, 0, -1)
Local $sRet = ""
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = $iStart_Row To $iEnd_Row
$sRet &= $aArray[$i] & $sDelim_Col
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iStart_Col = -1 Then $iStart_Col = 0
If $iEnd_Col = -1 Then $iEnd_Col = $iDim_2
If $iStart_Col < -1 Or $iEnd_Col < -1 Then Return SetError(5, 0, -1)
If $iStart_Col > $iDim_2 Or $iEnd_Col > $iDim_2 Then Return SetError(5, 0, -1)
If $iStart_Col > $iEnd_Col Then Return SetError(6, 0, -1)
For $i = $iStart_Row To $iEnd_Row
For $j = $iStart_Col To $iEnd_Col
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return 1
EndFunc
Func _ArrayTranspose(ByRef $aArray)
Switch UBound($aArray, 0)
Case 0
Return SetError(2, 0, 0)
Case 1
Local $aTemp[1][UBound($aArray)]
For $i = 0 To UBound($aArray) - 1
$aTemp[0][$i] = $aArray[$i]
Next
$aArray = $aTemp
Case 2
Local $iDim_1 = UBound($aArray, 1), $iDim_2 = UBound($aArray, 2)
If $iDim_1 <> $iDim_2 Then
Local $aTemp[$iDim_2][$iDim_1]
For $i = 0 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aTemp[$j][$i] = $aArray[$i][$j]
Next
Next
$aArray = $aTemp
Else
Local $vElement
For $i = 0 To $iDim_1 - 1
For $j = $i + 1 To $iDim_2 - 1
$vElement = $aArray[$i][$j]
$aArray[$i][$j] = $aArray[$j][$i]
$aArray[$j][$i] = $vElement
Next
Next
EndIf
Case Else
Return SetError(1, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayTrim(ByRef $aArray, $iTrimNum, $iDirection = 0, $iStart = 0, $iEnd = 0, $iSubItem = 0)
If $iDirection = Default Then $iDirection = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, 0)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iEnd = 0 Then $iEnd = $iDim_1
If $iStart > $iEnd Then Return SetError(3, 0, -1)
If $iStart < 0 Or $iEnd < 0 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimRight($aArray[$i], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i] = StringTrimLeft($aArray[$i], $iTrimNum)
Next
EndIf
Case 2
Local $iDim_2 = UBound($aArray, $UBOUND_COLUMNS) - 1
If $iSubItem < 0 Or $iSubItem > $iDim_2 Then Return SetError(5, 0, -1)
If $iDirection Then
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimRight($aArray[$i][$iSubItem], $iTrimNum)
Next
Else
For $i = $iStart To $iEnd
$aArray[$i][$iSubItem] = StringTrimLeft($aArray[$i][$iSubItem], $iTrimNum)
Next
EndIf
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _ArrayUnique(Const ByRef $aArray, $iColumn = 0, $iBase = 0, $iCase = 0, $iCount = $ARRAYUNIQUE_COUNT, $iIntType = $ARRAYUNIQUE_AUTO)
If $iColumn = Default Then $iColumn = 0
If $iBase = Default Then $iBase = 0
If $iCase = Default Then $iCase = 0
If $iCount = Default Then $iCount = $ARRAYUNIQUE_COUNT
If UBound($aArray, $UBOUND_ROWS) = 0 Then Return SetError(1, 0, 0)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS), $iNumColumns = UBound($aArray, $UBOUND_COLUMNS)
If $iDims > 2 Then Return SetError(2, 0, 0)
If $iBase < 0 Or $iBase > 1 Or (Not IsInt($iBase)) Then Return SetError(3, 0, 0)
If $iCase < 0 Or $iCase > 1 Or (Not IsInt($iCase)) Then Return SetError(3, 0, 0)
If $iCount < 0 Or $iCount > 1 Or (Not IsInt($iCount)) Then Return SetError(4, 0, 0)
If $iIntType < 0 Or $iIntType > 4 Or (Not IsInt($iIntType)) Then Return SetError(5, 0, 0)
If $iColumn < 0 Or ($iNumColumns = 0 And $iColumn > 0) Or ($iNumColumns > 0 And $iColumn >= $iNumColumns) Then Return SetError(6, 0, 0)
If $iIntType = $ARRAYUNIQUE_AUTO Then
Local $bInt, $sVarType
If $iDims = 1 Then
$bInt = IsInt($aArray[$iBase])
$sVarType = VarGetType($aArray[$iBase])
Else
$bInt = IsInt($aArray[$iBase][$iColumn])
$sVarType = VarGetType($aArray[$iBase][$iColumn])
EndIf
If $bInt And $sVarType = "Int64" Then
$iIntType = $ARRAYUNIQUE_FORCE64
Else
$iIntType = $ARRAYUNIQUE_FORCE32
EndIf
EndIf
ObjEvent("AutoIt.Error", __ArrayUnique_AutoErrFunc)
Local $oDictionary = ObjCreate("Scripting.Dictionary")
$oDictionary.CompareMode = Number(Not $iCase)
Local $vElem, $sType, $vKey, $bCOMError = False
For $i = $iBase To UBound($aArray) - 1
If $iDims = 1 Then
$vElem = $aArray[$i]
Else
$vElem = $aArray[$i][$iColumn]
EndIf
Switch $iIntType
Case $ARRAYUNIQUE_FORCE32
$oDictionary.Item($vElem)
If @error Then
$bCOMError = True
ExitLoop
EndIf
Case $ARRAYUNIQUE_FORCE64
$sType = VarGetType($vElem)
If $sType = "Int32" Then
$bCOMError = True
ExitLoop
EndIf
$vKey = "#" & $sType & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_MATCH
$sType = VarGetType($vElem)
If StringLeft($sType, 3) = "Int" Then
$vKey = "#Int#" & String($vElem)
Else
$vKey = "#" & $sType & "#" & String($vElem)
EndIf
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
Case $ARRAYUNIQUE_DISTINCT
$vKey = "#" & VarGetType($vElem) & "#" & String($vElem)
If Not $oDictionary.Item($vKey) Then
$oDictionary($vKey) = $vElem
EndIf
EndSwitch
Next
Local $aValues, $j = 0
If $bCOMError Then
Return SetError(7, 0, 0)
ElseIf $iIntType <> $ARRAYUNIQUE_FORCE32 Then
Local $aValues[$oDictionary.Count]
For $vKey In $oDictionary.Keys()
$aValues[$j] = $oDictionary($vKey)
If StringLeft($vKey, 5) = "#Ptr#" Then
$aValues[$j] = Ptr($aValues[$j])
EndIf
$j += 1
Next
Else
$aValues = $oDictionary.Keys()
EndIf
If $iCount Then
_ArrayInsert($aValues, 0, $oDictionary.Count)
EndIf
Return $aValues
EndFunc
Func _Array1DToHistogram($aArray, $iSizing = 100)
If UBound($aArray, 0) > 1 Then Return SetError(1, 0, "")
$iSizing = $iSizing * 8
Local $t, $n, $iMin = 0, $iMax = 0, $iOffset = 0
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
$t = IsNumber($t) ? Round($t) : 0
If $t < $iMin Then $iMin = $t
If $t > $iMax Then $iMax = $t
Next
Local $iRange = Int(Round(($iMax - $iMin) / 8)) * 8
Local $iSpaceRatio = 4
For $i = 0 To UBound($aArray) - 1
$t = $aArray[$i]
If $t Then
$n = Abs(Round(($iSizing * $t) / $iRange) / 8)
$aArray[$i] = ""
If $t > 0 Then
If $iMin Then
$iOffset = Int(Abs(Round(($iSizing * $iMin) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
Else
If $iMin <> $t Then
$iOffset = Int(Abs(Round(($iSizing * ($t - $iMin)) / $iRange) / 8) / 8 * $iSpaceRatio)
$aArray[$i] = __Array_StringRepeat(ChrW(0x20), $iOffset)
EndIf
EndIf
$aArray[$i] &= __Array_StringRepeat(ChrW(0x2588), Int($n / 8))
$n = Mod($n, 8)
If $n > 0 Then $aArray[$i] &= ChrW(0x2588 + 8 - $n)
$aArray[$i] &= ' ' & $t
Else
$aArray[$i] = ""
EndIf
Next
Return $aArray
EndFunc
Func __Array_StringRepeat($sString, $iRepeatCount)
$iRepeatCount = Int($iRepeatCount)
If StringLen($sString) < 1 Or $iRepeatCount <= 0 Then Return SetError(1, 0, "")
Local $sResult = ""
While $iRepeatCount > 1
If BitAND($iRepeatCount, 1) Then $sResult &= $sString
$sString &= $sString
$iRepeatCount = BitShift($iRepeatCount, 1)
WEnd
Return $sString & $sResult
EndFunc
Func __Array_ExeterInternal(ByRef $aArray, $iStart, $iSize, $sDelimiter, ByRef $aIdx, ByRef $aResult, ByRef $iCount)
If $iStart == $iSize - 1 Then
For $i = 0 To $iSize - 1
$aResult[$iCount] &= $aArray[$aIdx[$i]] & $sDelimiter
Next
If $sDelimiter <> "" Then $aResult[$iCount] = StringTrimRight($aResult[$iCount], StringLen($sDelimiter))
$iCount += 1
Else
Local $iTemp
For $i = $iStart To $iSize - 1
$iTemp = $aIdx[$i]
$aIdx[$i] = $aIdx[$iStart]
$aIdx[$iStart] = $iTemp
__Array_ExeterInternal($aArray, $iStart + 1, $iSize, $sDelimiter, $aIdx, $aResult, $iCount)
$aIdx[$iStart] = $aIdx[$i]
$aIdx[$i] = $iTemp
Next
EndIf
EndFunc
Func __Array_Combinations($iN, $iR)
Local $i_Total = 1
For $i = $iR To 1 Step -1
$i_Total *= ($iN / $i)
$iN -= 1
Next
Return Round($i_Total)
EndFunc
Func __Array_GetNext($iN, $iR, ByRef $iLeft, $iTotal, ByRef $aIdx)
If $iLeft == $iTotal Then
$iLeft -= 1
Return
EndIf
Local $i = $iR - 1
While $aIdx[$i] == $iN - $iR + $i
$i -= 1
WEnd
$aIdx[$i] += 1
For $j = $i + 1 To $iR - 1
$aIdx[$j] = $aIdx[$i] + $j - $i
Next
$iLeft -= 1
EndFunc
Func __Array_MinMaxIndex(Const ByRef $aArray, $iCompNumeric, $iStart, $iEnd, $iSubItem, $fuComparison)
If $iCompNumeric = Default Then $iCompNumeric = 0
If $iCompNumeric <> 1 Then $iCompNumeric = 0
If $iStart = Default Then $iStart = 0
If $iEnd = Default Then $iEnd = 0
If $iSubItem = Default Then $iSubItem = 0
If Not IsArray($aArray) Then Return SetError(1, 0, -1)
Local $iDim_1 = UBound($aArray, $UBOUND_ROWS) - 1
If $iDim_1 < 0 Then Return SetError(1, 0, -1)
If $iEnd = -1 Then $iEnd = $iDim_1
If $iStart = -1 Then $iStart = 0
If $iStart < -1 Or $iEnd < -1 Then Return SetError(3, 0, -1)
If $iStart > $iDim_1 Or $iEnd > $iDim_1 Then Return SetError(3, 0, -1)
If $iStart > $iEnd Then Return SetError(4, 0, -1)
If $iDim_1 < 0 Then Return SetError(5, 0, -1)
Local $iMaxMinIndex = $iStart
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i]), Number($aArray[$iMaxMinIndex])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i], $aArray[$iMaxMinIndex]) Then $iMaxMinIndex = $i
Next
EndIf
Case 2
If $iSubItem < 0 Or $iSubItem > UBound($aArray, $UBOUND_COLUMNS) - 1 Then Return SetError(6, 0, -1)
If $iCompNumeric Then
For $i = $iStart To $iEnd
If $fuComparison(Number($aArray[$i][$iSubItem]), Number($aArray[$iMaxMinIndex][$iSubItem])) Then $iMaxMinIndex = $i
Next
Else
For $i = $iStart To $iEnd
If $fuComparison($aArray[$i][$iSubItem], $aArray[$iMaxMinIndex][$iSubItem]) Then $iMaxMinIndex = $i
Next
EndIf
Case Else
Return SetError(2, 0, -1)
EndSwitch
Return $iMaxMinIndex
EndFunc
Func __Array_GreaterThan($vValue1, $vValue2)
Return $vValue1 > $vValue2
EndFunc
Func __Array_LessThan($vValue1, $vValue2)
Return $vValue1 < $vValue2
EndFunc
Func __ArrayUnique_AutoErrFunc()
EndFunc
Func _FileCountLines($sFilePath)
FileReadToArray($sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return @extended
EndFunc
Func _FileCreate($sFilePath)
Local $hFileOpen = FileOpen($sFilePath, BitOR($FO_OVERWRITE, $FO_CREATEPATH))
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iFileWrite = FileWrite($hFileOpen, "")
FileClose($hFileOpen)
If Not $iFileWrite Then Return SetError(2, 0, 0)
Return 1
EndFunc
Func _FileListToArray($sFilePath, $sFilter = "*", $iFlag = $FLTA_FILESFOLDERS, $bReturnPath = False)
Local $sDelimiter = "|", $sFileList = "", $sFileName = "", $sFullPath = ""
$sFilePath = StringRegExpReplace($sFilePath, "[\\/]+$", "") & "\"
If $iFlag = Default Then $iFlag = $FLTA_FILESFOLDERS
If $bReturnPath Then $sFullPath = $sFilePath
If $sFilter = Default Then $sFilter = "*"
If Not FileExists($sFilePath) Then Return SetError(1, 0, 0)
If StringRegExp($sFilter, "[\\/:><\|]|(?s)^\s*$") Then Return SetError(2, 0, 0)
If Not ($iFlag = 0 Or $iFlag = 1 Or $iFlag = 2) Then Return SetError(3, 0, 0)
Local $hSearch = FileFindFirstFile($sFilePath & $sFilter)
If @error Then Return SetError(4, 0, 0)
While 1
$sFileName = FileFindNextFile($hSearch)
If @error Then ExitLoop
If ($iFlag + @extended = 2) Then ContinueLoop
$sFileList &= $sDelimiter & $sFullPath & $sFileName
WEnd
FileClose($hSearch)
If $sFileList = "" Then Return SetError(4, 0, 0)
Return StringSplit(StringTrimLeft($sFileList, 1), $sDelimiter)
EndFunc
Func _FileListToArrayRec($sFilePath, $sMask = "*", $iReturn = $FLTAR_FILESFOLDERS, $iRecur = $FLTAR_NORECUR, $iSort = $FLTAR_NOSORT, $iReturnPath = $FLTAR_RELPATH)
If Not FileExists($sFilePath) Then Return SetError(1, 1, "")
If $sMask = Default Then $sMask = "*"
If $iReturn = Default Then $iReturn = $FLTAR_FILESFOLDERS
If $iRecur = Default Then $iRecur = $FLTAR_NORECUR
If $iSort = Default Then $iSort = $FLTAR_NOSORT
If $iReturnPath = Default Then $iReturnPath = $FLTAR_RELPATH
If $iRecur > 1 Or Not IsInt($iRecur) Then Return SetError(1, 6, "")
Local $bLongPath = False
If StringLeft($sFilePath, 4) == "\\?\" Then
$bLongPath = True
EndIf
Local $sFolderSlash = ""
If StringRight($sFilePath, 1) = "\" Then
$sFolderSlash = "\"
Else
$sFilePath = $sFilePath & "\"
EndIf
Local $asFolderSearchList[100] = [1]
$asFolderSearchList[1] = $sFilePath
Local $iHide_HS = 0,  $sHide_HS = ""
If BitAND($iReturn, $FLTAR_NOHIDDEN) Then
$iHide_HS += 2
$sHide_HS &= "H"
$iReturn -= $FLTAR_NOHIDDEN
EndIf
If BitAND($iReturn, $FLTAR_NOSYSTEM) Then
$iHide_HS += 4
$sHide_HS &= "S"
$iReturn -= $FLTAR_NOSYSTEM
EndIf
Local $iHide_Link = 0
If BitAND($iReturn, $FLTAR_NOLINK) Then
$iHide_Link = 0x400
$iReturn -= $FLTAR_NOLINK
EndIf
Local $iMaxLevel = 0
If $iRecur < 0 Then
StringReplace($sFilePath, "\", "", 0, $STR_NOCASESENSEBASIC)
$iMaxLevel = @extended - $iRecur
EndIf
Local $sExclude_List = "", $sExclude_List_Folder = "", $sInclude_List = "*"
Local $aMaskSplit = StringSplit($sMask, "|")
Switch $aMaskSplit[0]
Case 3
$sExclude_List_Folder = $aMaskSplit[3]
ContinueCase
Case 2
$sExclude_List = $aMaskSplit[2]
ContinueCase
Case 1
$sInclude_List = $aMaskSplit[1]
EndSwitch
Local $sInclude_File_Mask = ".+"
If $sInclude_List <> "*" Then
If Not __FLTAR_ListToMask($sInclude_File_Mask, $sInclude_List) Then Return SetError(1, 2, "")
EndIf
Local $sInclude_Folder_Mask = ".+"
Switch $iReturn
Case 0
Switch $iRecur
Case 0
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Case 2
$sInclude_Folder_Mask = $sInclude_File_Mask
EndSwitch
Local $sExclude_File_Mask = ":"
If $sExclude_List <> "" Then
If Not __FLTAR_ListToMask($sExclude_File_Mask, $sExclude_List) Then Return SetError(1, 3, "")
EndIf
Local $sExclude_Folder_Mask = ":"
If $iRecur Then
If $sExclude_List_Folder Then
If Not __FLTAR_ListToMask($sExclude_Folder_Mask, $sExclude_List_Folder) Then Return SetError(1, 4, "")
EndIf
If $iReturn = 2 Then
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
Else
$sExclude_Folder_Mask = $sExclude_File_Mask
EndIf
If Not ($iReturn = 0 Or $iReturn = 1 Or $iReturn = 2) Then Return SetError(1, 5, "")
If Not ($iSort = 0 Or $iSort = 1 Or $iSort = 2) Then Return SetError(1, 7, "")
If Not ($iReturnPath = 0 Or $iReturnPath = 1 Or $iReturnPath = 2) Then Return SetError(1, 8, "")
If $iHide_Link Then
Local $tFile_Data = DllStructCreate("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" &  "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
Local $hDLL = DllOpen('kernel32.dll'), $aDLL_Ret
EndIf
Local $asReturnList[100] = [0]
Local $asFileMatchList = $asReturnList, $asRootFileMatchList = $asReturnList, $asFolderMatchList = $asReturnList
Local $bFolder = False,  $hSearch = 0,  $sCurrentPath = "", $sName = "", $sRetPath = ""
Local $iAttribs = 0,  $sAttribs = ''
Local $asFolderFileSectionList[100][2] = [[0, 0]]
While $asFolderSearchList[0] > 0
$sCurrentPath = $asFolderSearchList[$asFolderSearchList[0]]
$asFolderSearchList[0] -= 1
Switch $iReturnPath
Case 1
$sRetPath = StringReplace($sCurrentPath, $sFilePath, "")
Case 2
If $bLongPath Then
$sRetPath = StringTrimLeft($sCurrentPath, 4)
Else
$sRetPath = $sCurrentPath
EndIf
EndSwitch
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'handle', 'FindFirstFileW', 'wstr', $sCurrentPath & "*", 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ContinueLoop
EndIf
$hSearch = $aDLL_Ret[0]
Else
$hSearch = FileFindFirstFile($sCurrentPath & "*")
If $hSearch = -1 Then
ContinueLoop
EndIf
EndIf
If $iReturn = 0 And $iSort And $iReturnPath Then
__FLTAR_AddToList($asFolderFileSectionList, $sRetPath, $asFileMatchList[0] + 1)
EndIf
$sAttribs = ''
While 1
If $iHide_Link Then
$aDLL_Ret = DllCall($hDLL, 'int', 'FindNextFileW', 'handle', $hSearch, 'struct*', $tFile_Data)
If @error Or Not $aDLL_Ret[0] Then
ExitLoop
EndIf
$sName = DllStructGetData($tFile_Data, "FileName")
If $sName = ".." Then
ContinueLoop
EndIf
$iAttribs = DllStructGetData($tFile_Data, "FileAttributes")
If $iHide_HS And BitAND($iAttribs, $iHide_HS) Then
ContinueLoop
EndIf
If BitAND($iAttribs, $iHide_Link) Then
ContinueLoop
EndIf
$bFolder = False
If BitAND($iAttribs, 16) Then
$bFolder = True
EndIf
Else
$bFolder = False
$sName = FileFindNextFile($hSearch, 1)
If @error Then
ExitLoop
EndIf
$sAttribs = @extended
If StringInStr($sAttribs, "D") Then
$bFolder = True
EndIf
If StringRegExp($sAttribs, "[" & $sHide_HS & "]") Then
ContinueLoop
EndIf
EndIf
If $bFolder Then
Select
Case $iRecur < 0
StringReplace($sCurrentPath, "\", "", 0, $STR_NOCASESENSEBASIC)
If @extended < $iMaxLevel Then
ContinueCase
EndIf
Case $iRecur = 1
If Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderSearchList, $sCurrentPath & $sName & "\")
EndIf
EndSelect
EndIf
If $iSort Then
If $bFolder Then
If StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asFolderMatchList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
If $sCurrentPath = $sFilePath Then
__FLTAR_AddToList($asRootFileMatchList, $sRetPath & $sName)
Else
__FLTAR_AddToList($asFileMatchList, $sRetPath & $sName)
EndIf
EndIf
EndIf
Else
If $bFolder Then
If $iReturn <> 1 And StringRegExp($sName, $sInclude_Folder_Mask) And Not StringRegExp($sName, $sExclude_Folder_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName & $sFolderSlash)
EndIf
Else
If $iReturn <> 2 And StringRegExp($sName, $sInclude_File_Mask) And Not StringRegExp($sName, $sExclude_File_Mask) Then
__FLTAR_AddToList($asReturnList, $sRetPath & $sName)
EndIf
EndIf
EndIf
WEnd
If $iHide_Link Then
DllCall($hDLL, 'int', 'FindClose', 'ptr', $hSearch)
Else
FileClose($hSearch)
EndIf
WEnd
If $iHide_Link Then
DllClose($hDLL)
EndIf
If $iSort Then
Switch $iReturn
Case 2
If $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
$asReturnList = $asFolderMatchList
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Case 1
If $asRootFileMatchList[0] = 0 And $asFileMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList, 1)
EndIf
Case 0
If $asRootFileMatchList[0] = 0 And $asFolderMatchList[0] = 0 Then Return SetError(1, 9, "")
If $iReturnPath = 0 Then
__FLTAR_AddFileLists($asReturnList, $asRootFileMatchList, $asFileMatchList)
$asReturnList[0] += $asFolderMatchList[0]
ReDim $asFolderMatchList[$asFolderMatchList[0] + 1]
_ArrayConcatenate($asReturnList, $asFolderMatchList, 1)
__ArrayDualPivotSort($asReturnList, 1, $asReturnList[0])
Else
Local $asReturnList[$asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0] + 1]
$asReturnList[0] = $asFileMatchList[0] + $asRootFileMatchList[0] + $asFolderMatchList[0]
__ArrayDualPivotSort($asRootFileMatchList, 1, $asRootFileMatchList[0])
For $i = 1 To $asRootFileMatchList[0]
$asReturnList[$i] = $asRootFileMatchList[$i]
Next
Local $iNextInsertionIndex = $asRootFileMatchList[0] + 1
__ArrayDualPivotSort($asFolderMatchList, 1, $asFolderMatchList[0])
Local $sFolderToFind = ""
For $i = 1 To $asFolderMatchList[0]
$asReturnList[$iNextInsertionIndex] = $asFolderMatchList[$i]
$iNextInsertionIndex += 1
If $sFolderSlash Then
$sFolderToFind = $asFolderMatchList[$i]
Else
$sFolderToFind = $asFolderMatchList[$i] & "\"
EndIf
Local $iFileSectionEndIndex = 0, $iFileSectionStartIndex = 0
For $j = 1 To $asFolderFileSectionList[0][0]
If $sFolderToFind = $asFolderFileSectionList[$j][0] Then
$iFileSectionStartIndex = $asFolderFileSectionList[$j][1]
If $j = $asFolderFileSectionList[0][0] Then
$iFileSectionEndIndex = $asFileMatchList[0]
Else
$iFileSectionEndIndex = $asFolderFileSectionList[$j + 1][1] - 1
EndIf
If $iSort = 1 Then
__ArrayDualPivotSort($asFileMatchList, $iFileSectionStartIndex, $iFileSectionEndIndex)
EndIf
For $k = $iFileSectionStartIndex To $iFileSectionEndIndex
$asReturnList[$iNextInsertionIndex] = $asFileMatchList[$k]
$iNextInsertionIndex += 1
Next
ExitLoop
EndIf
Next
Next
EndIf
EndSwitch
Else
If $asReturnList[0] = 0 Then Return SetError(1, 9, "")
ReDim $asReturnList[$asReturnList[0] + 1]
EndIf
Return $asReturnList
EndFunc
Func __FLTAR_AddFileLists(ByRef $asTarget, $asSource_1, $asSource_2, $iSort = 0)
ReDim $asSource_1[$asSource_1[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_1, 1, $asSource_1[0])
$asTarget = $asSource_1
$asTarget[0] += $asSource_2[0]
ReDim $asSource_2[$asSource_2[0] + 1]
If $iSort = 1 Then __ArrayDualPivotSort($asSource_2, 1, $asSource_2[0])
_ArrayConcatenate($asTarget, $asSource_2, 1)
EndFunc
Func __FLTAR_AddToList(ByRef $aList, $vValue_0, $vValue_1 = -1)
If $vValue_1 = -1 Then
$aList[0] += 1
If UBound($aList) <= $aList[0] Then ReDim $aList[UBound($aList) * 2]
$aList[$aList[0]] = $vValue_0
Else
$aList[0][0] += 1
If UBound($aList) <= $aList[0][0] Then ReDim $aList[UBound($aList) * 2][2]
$aList[$aList[0][0]][0] = $vValue_0
$aList[$aList[0][0]][1] = $vValue_1
EndIf
EndFunc
Func __FLTAR_ListToMask(ByRef $sMask, $sList)
If StringRegExp($sList, "\\|/|:|\<|\>|\|") Then Return 0
$sList = StringReplace(StringStripWS(StringRegExpReplace($sList, "\s*;\s*", ";"), BitOR($STR_STRIPLEADING, $STR_STRIPTRAILING)), ";", "|")
$sList = StringReplace(StringReplace(StringRegExpReplace($sList, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
$sMask = "(?i)^(" & $sList & ")\z"
Return 1
EndFunc
Func _FilePrint($sFilePath, $iShow = @SW_HIDE)
Return ShellExecute($sFilePath, "", @WorkingDir, "print", $iShow = Default ? @SW_HIDE : $iShow)
EndFunc
Func _FileReadToArray($sFilePath, ByRef $vReturn, $iFlags = $FRTA_COUNT, $sDelimiter = "")
$vReturn = 0
If $iFlags = Default Then $iFlags = $FRTA_COUNT
If $sDelimiter = Default Then $sDelimiter = ""
Local $bExpand = True
If BitAND($iFlags, $FRTA_INTARRAYS) Then
$bExpand = False
$iFlags -= $FRTA_INTARRAYS
EndIf
Local $iEntire = $STR_CHRSPLIT
If BitAND($iFlags, $FRTA_ENTIRESPLIT) Then
$iEntire = $STR_ENTIRESPLIT
$iFlags -= $FRTA_ENTIRESPLIT
EndIf
Local $iNoCount = 0
If $iFlags <> $FRTA_COUNT Then
$iFlags = $FRTA_NOCOUNT
$iNoCount = $STR_NOCOUNT
EndIf
If $sDelimiter Then
Local $aLines = FileReadToArray($sFilePath)
If @error Then Return SetError(@error, 0, 0)
Local $iDim_1 = UBound($aLines) + $iFlags
If $bExpand Then
Local $iDim_2 = UBound(StringSplit($aLines[0], $sDelimiter, $iEntire + $STR_NOCOUNT))
Local $aTemp_Array[$iDim_1][$iDim_2]
Local $iFields,  $aSplit
For $i = 0 To $iDim_1 - $iFlags - 1
$aSplit = StringSplit($aLines[$i], $sDelimiter, $iEntire + $STR_NOCOUNT)
$iFields = UBound($aSplit)
If $iFields <> $iDim_2 Then
Return SetError(3, 0, 0)
EndIf
For $j = 0 To $iFields - 1
$aTemp_Array[$i + $iFlags][$j] = $aSplit[$j]
Next
Next
If $iDim_2 < 2 Then Return SetError(4, 0, 0)
If $iFlags Then
$aTemp_Array[0][0] = $iDim_1 - $iFlags
$aTemp_Array[0][1] = $iDim_2
EndIf
Else
Local $aTemp_Array[$iDim_1]
For $i = 0 To $iDim_1 - $iFlags - 1
$aTemp_Array[$i + $iFlags] = StringSplit($aLines[$i], $sDelimiter, $iEntire + $iNoCount)
Next
If $iFlags Then
$aTemp_Array[0] = $iDim_1 - $iFlags
EndIf
EndIf
$vReturn = $aTemp_Array
Else
If $iFlags Then
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If StringLen($sFileRead) Then
$vReturn = StringRegExp(@LF & $sFileRead, "(?|(\N+)\z|(\N*)(?:\R))", $STR_REGEXPARRAYGLOBALMATCH)
$vReturn[0] = UBound($vReturn) - 1
Else
Return SetError(2, 0, 0)
EndIf
Else
$vReturn = FileReadToArray($sFilePath)
If @error Then
$vReturn = 0
Return SetError(@error, 0, 0)
EndIf
EndIf
EndIf
Return 1
EndFunc
Func _FileWriteFromArray($sFilePath, Const ByRef $aArray, $iBase = Default, $iUBound = Default, $sDelimiter = "|")
Local $iReturn = 0
If Not IsArray($aArray) Then Return SetError(2, 0, $iReturn)
Local $iDims = UBound($aArray, $UBOUND_DIMENSIONS)
If $iDims > 2 Then Return SetError(4, 0, 0)
Local $iLast = UBound($aArray) - 1
If $iUBound = Default Or $iUBound > $iLast Then $iUBound = $iLast
If $iBase < 0 Or $iBase = Default Then $iBase = 0
If $iBase > $iUBound Then Return SetError(5, 0, $iReturn)
If $sDelimiter = Default Then $sDelimiter = "|"
Local $hFileOpen = $sFilePath
If IsString($sFilePath) Then
$hFileOpen = FileOpen($sFilePath, $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(1, 0, $iReturn)
EndIf
Local $iError = 0
$iReturn = 1
Switch $iDims
Case 1
For $i = $iBase To $iUBound
If Not FileWrite($hFileOpen, $aArray[$i] & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
Case 2
Local $sTemp = ""
For $i = $iBase To $iUBound
$sTemp = $aArray[$i][0]
For $j = 1 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sTemp &= $sDelimiter & $aArray[$i][$j]
Next
If Not FileWrite($hFileOpen, $sTemp & @CRLF) Then
$iError = 3
$iReturn = 0
ExitLoop
EndIf
Next
EndSwitch
If IsString($sFilePath) Then FileClose($hFileOpen)
Return SetError($iError, 0, $iReturn)
EndFunc
Func _FileWriteLog($sLogPath, $sLogMsg, $iFlag = -1)
Local $iOpenMode = $FO_APPEND
Local $sMsg = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $sLogMsg
If $iFlag = Default Then $iFlag = -1
If $iFlag <> -1 Then
$iOpenMode = $FO_OVERWRITE
$sMsg &= @CRLF & FileRead($sLogPath)
EndIf
Local $hFileOpen = $sLogPath
If IsString($sLogPath) Then $hFileOpen = FileOpen($sLogPath, $iOpenMode)
If $hFileOpen = -1 Then Return SetError(1, 0, 0)
Local $iReturn = FileWriteLine($hFileOpen, $sMsg)
If IsString($sLogPath) Then $iReturn = FileClose($hFileOpen)
If $iReturn <= 0 Then Return SetError(2, $iReturn, 0)
Return $iReturn
EndFunc
Func _FileWriteToLine($sFilePath, $iLine, $sText, $bOverWrite = False, $bFill = False)
If $bOverWrite = Default Then $bOverWrite = False
If $bFill = Default Then $bFill = False
If Not FileExists($sFilePath) Then Return SetError(2, 0, 0)
If $iLine <= 0 Then Return SetError(4, 0, 0)
If Not (IsBool($bOverWrite) Or $bOverWrite = 0 Or $bOverWrite = 1) Then Return SetError(5, 0, 0)
If Not IsString($sText) Then
$sText = String($sText)
If $sText = "" Then Return SetError(6, 0, 0)
EndIf
If Not IsBool($bFill) Then Return SetError(7, 0, 0)
Local $aArray = FileReadToArray($sFilePath)
If @error Then Local $aArray[0]
Local $iUBound = UBound($aArray) - 1
If $bFill Then
If $iUBound < $iLine Then
ReDim $aArray[$iLine]
$iUBound = $iLine - 1
EndIf
Else
If ($iUBound + 1) < $iLine Then Return SetError(1, 0, 0)
EndIf
$aArray[$iLine - 1] = ($bOverWrite ? $sText : $sText & @CRLF & $aArray[$iLine - 1])
Local $sData = ""
For $i = 0 To $iUBound
$sData &= $aArray[$i] & @CRLF
Next
$sData = StringTrimRight($sData, StringLen(@CRLF))
Local $hFileOpen = FileOpen($sFilePath, FileGetEncoding($sFilePath) + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, 0)
FileWrite($hFileOpen, $sData)
FileClose($hFileOpen)
Return 1
EndFunc
Func _PathFull($sRelativePath, $sBasePath = @WorkingDir)
If Not $sRelativePath Or $sRelativePath = "." Then Return $sBasePath
Local $sFullPath = StringReplace($sRelativePath, "/", "\")
Local Const $sFullPathConst = $sFullPath
Local $sPath
Local $bRootOnly = StringLeft($sFullPath, 1) = "\" And StringMid($sFullPath, 2, 1) <> "\"
If $sBasePath = Default Then $sBasePath = @WorkingDir
For $i = 1 To 2
$sPath = StringLeft($sFullPath, 2)
If $sPath = "\\" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
Local $nServerLen = StringInStr($sFullPath, "\") - 1
$sPath = "\\" & StringLeft($sFullPath, $nServerLen)
$sFullPath = StringTrimLeft($sFullPath, $nServerLen)
ExitLoop
ElseIf StringRight($sPath, 1) = ":" Then
$sFullPath = StringTrimLeft($sFullPath, 2)
ExitLoop
Else
$sFullPath = $sBasePath & "\" & $sFullPath
EndIf
Next
If StringLeft($sFullPath, 1) <> "\" Then
If StringLeft($sFullPathConst, 2) = StringLeft($sBasePath, 2) Then
$sFullPath = $sBasePath & "\" & $sFullPath
Else
$sFullPath = "\" & $sFullPath
EndIf
EndIf
Local $aTemp = StringSplit($sFullPath, "\")
Local $aPathParts[$aTemp[0]], $j = 0
For $i = 2 To $aTemp[0]
If $aTemp[$i] = ".." Then
If $j Then $j -= 1
ElseIf Not ($aTemp[$i] = "" And $i <> $aTemp[0]) And $aTemp[$i] <> "." Then
$aPathParts[$j] = $aTemp[$i]
$j += 1
EndIf
Next
$sFullPath = $sPath
If Not $bRootOnly Then
For $i = 0 To $j - 1
$sFullPath &= "\" & $aPathParts[$i]
Next
Else
$sFullPath &= $sFullPathConst
If StringInStr($sFullPath, "..") Then $sFullPath = _PathFull($sFullPath)
EndIf
Do
$sFullPath = StringReplace($sFullPath, ".\", "\")
Until @extended = 0
Return $sFullPath
EndFunc
Func _PathGetRelative($sFrom, $sTo)
If StringRight($sFrom, 1) <> "\" Then $sFrom &= "\"
If StringRight($sTo, 1) <> "\" Then $sTo &= "\"
If $sFrom = $sTo Then Return SetError(1, 0, StringTrimRight($sTo, 1))
Local $asFrom = StringSplit($sFrom, "\")
Local $asTo = StringSplit($sTo, "\")
If $asFrom[1] <> $asTo[1] Then Return SetError(2, 0, StringTrimRight($sTo, 1))
Local $i = 2
Local $iDiff = 1
While 1
If $asFrom[$i] <> $asTo[$i] Then
$iDiff = $i
ExitLoop
EndIf
$i += 1
WEnd
$i = 1
Local $sRelPath = ""
For $j = 1 To $asTo[0]
If $i >= $iDiff Then
$sRelPath &= "\" & $asTo[$i]
EndIf
$i += 1
Next
$sRelPath = StringTrimLeft($sRelPath, 1)
$i = 1
For $j = 1 To $asFrom[0]
If $i > $iDiff Then
$sRelPath = "..\" & $sRelPath
EndIf
$i += 1
Next
If StringRight($sRelPath, 1) == "\" Then $sRelPath = StringTrimRight($sRelPath, 1)
Return $sRelPath
EndFunc
Func _PathMake($sDrive, $sDir, $sFileName, $sExtension)
If StringLen($sDrive) Then
If Not (StringLeft($sDrive, 2) = "\\") Then $sDrive = StringLeft($sDrive, 1) & ":"
EndIf
If StringLen($sDir) Then
If Not (StringRight($sDir, 1) = "\") And Not (StringRight($sDir, 1) = "/") Then $sDir = $sDir & "\"
Else
$sDir = "\"
EndIf
If StringLen($sDir) Then
If Not (StringLeft($sDir, 1) = "\") And Not (StringLeft($sDir, 1) = "/") Then $sDir = "\" & $sDir
EndIf
If StringLen($sExtension) Then
If Not (StringLeft($sExtension, 1) = ".") Then $sExtension = "." & $sExtension
EndIf
Return $sDrive & $sDir & $sFileName & $sExtension
EndFunc
Func _PathSplit($sFilePath, ByRef $sDrive, ByRef $sDir, ByRef $sFileName, ByRef $sExtension)
Local $aArray = StringRegExp($sFilePath, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $STR_REGEXPARRAYMATCH)
If @error Then
ReDim $aArray[5]
$aArray[$PATH_ORIGINAL] = $sFilePath
EndIf
$sDrive = $aArray[$PATH_DRIVE]
If StringLeft($aArray[$PATH_DIRECTORY], 1) == "/" Then
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\/")
Else
$sDir = StringRegExpReplace($aArray[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\\")
EndIf
$aArray[$PATH_DIRECTORY] = $sDir
$sFileName = $aArray[$PATH_FILENAME]
$sExtension = $aArray[$PATH_EXTENSION]
Return $aArray
EndFunc
Func _ReplaceStringInFile($sFilePath, $sSearchString, $sReplaceString, $iCaseSensitive = 0, $iOccurance = 1)
If StringInStr(FileGetAttrib($sFilePath), "R") Then Return SetError(1, 0, -1)
Local $hFileOpen = FileOpen($sFilePath, $FO_READ)
If $hFileOpen = -1 Then Return SetError(2, 0, -1)
Local $sFileRead = FileRead($hFileOpen)
FileClose($hFileOpen)
If $iCaseSensitive = Default Then $iCaseSensitive = 0
If $iOccurance = Default Then $iOccurance = 1
$sFileRead = StringReplace($sFileRead, $sSearchString, $sReplaceString, 1 - $iOccurance, $iCaseSensitive)
Local $iReturn = @extended
If $iReturn Then
Local $iFileEncoding = FileGetEncoding($sFilePath)
$hFileOpen = FileOpen($sFilePath, $iFileEncoding + $FO_OVERWRITE)
If $hFileOpen = -1 Then Return SetError(3, 0, -1)
FileWrite($hFileOpen, $sFileRead)
FileClose($hFileOpen)
EndIf
Return $iReturn
EndFunc
Func _TempFile($sDirectoryName = @TempDir, $sFilePrefix = "~", $sFileExtension = ".tmp", $iRandomLength = 7)
If $iRandomLength = Default Or $iRandomLength <= 0 Then $iRandomLength = 7
If $sDirectoryName = Default Or (Not FileExists($sDirectoryName)) Then $sDirectoryName = @TempDir
If $sFileExtension = Default Then $sFileExtension = ".tmp"
If $sFilePrefix = Default Then $sFilePrefix = "~"
If Not FileExists($sDirectoryName) Then $sDirectoryName = @ScriptDir
$sDirectoryName = StringRegExpReplace($sDirectoryName, "[\\/]+$", "")
$sFileExtension = StringRegExpReplace($sFileExtension, "^\.+", "")
$sFilePrefix = StringRegExpReplace($sFilePrefix, '[\\/:*?"<>|]', "")
Local $sTempName = ""
Do
$sTempName = ""
While StringLen($sTempName) < $iRandomLength
$sTempName &= Chr(Random(97, 122, 1))
WEnd
$sTempName = $sDirectoryName & "\" & $sFilePrefix & $sTempName & "." & $sFileExtension
Until Not FileExists($sTempName)
Return $sTempName
EndFunc
Global Const $INET_LOCALCACHE = 0
Global Const $INET_FORCERELOAD = 1
Global Const $INET_IGNORESSL = 2
Global Const $INET_ASCIITRANSFER = 4
Global Const $INET_BINARYTRANSFER = 8
Global Const $INET_FORCEBYPASS = 16
Global Const $INET_DOWNLOADWAIT = 0
Global Const $INET_DOWNLOADBACKGROUND = 1
Global Const $INET_DOWNLOADREAD = 0
Global Const $INET_DOWNLOADSIZE = 1
Global Const $INET_DOWNLOADCOMPLETE = 2
Global Const $INET_DOWNLOADSUCCESS = 3
Global Const $INET_DOWNLOADERROR = 4
Global Const $INET_DOWNLOADEXTENDED = 5
#Region Copyright
#EndRegion Copyright
#Region Many thanks to:
#EndRegion Many thanks to:
#ignorefunc _HtmlTableGetWriteToArray
#Region Global Constants
Global Enum  $_WD_OPTION_None = 0,  $_WD_OPTION_Visible = 1,  $_WD_OPTION_Enabled = 2,  $_WD_OPTION_Element = 4,  $_WD_OPTION_NoMatch = 8
Global Enum  $_WD_OPTION_Standard,  $_WD_OPTION_Advanced
#EndRegion Global Constants
Func _WD_NewTab($sSession, $bSwitch = Default, $iTimeout = Default, $sURL = Default, $sFeatures = Default)
Local Const $sFuncName = "_WD_NewTab"
Local $sTabHandle = '', $sLastTabHandle, $hWaitTimer, $iTabIndex, $aTemp
If $bSwitch = Default Then $bSwitch = True
If $iTimeout = Default Then $iTimeout = $_WD_DefaultTimeout
If $sURL = Default Then $sURL = ''
If $sFeatures = Default Then $sFeatures = ''
Local $sCurrentTabHandle = _WD_Window($sSession, 'window')
If $sFeatures = '' Then
$sTabHandle = _WD_Window($sSession, 'new', '{"type":"tab"}')
If @error = $_WD_ERROR_Success Then
_WD_Window($sSession, 'Switch', '{"handle":"' & $sTabHandle & '"}')
If $sURL Then _WD_Navigate($sSession, $sURL)
If Not $bSwitch Then _WD_Window($sSession, 'Switch', '{"handle":"' & $sCurrentTabHandle & '"}')
EndIf
Else
Local $aHandles = _WD_Window($sSession, 'handles')
If @error <> $_WD_ERROR_Success Or Not IsArray($aHandles) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), 0, $sTabHandle)
EndIf
Local $iTabCount = UBound($aHandles)
$sLastTabHandle = $aHandles[$iTabCount - 1]
If $sCurrentTabHandle Then
$iTabIndex = _ArraySearch($aHandles, $sCurrentTabHandle)
If @error Then
$sCurrentTabHandle = $sLastTabHandle
$iTabIndex = $iTabCount - 1
EndIf
Else
_WD_Window($sSession, 'Switch', '{"handle":"' & $sLastTabHandle & '"}')
$sCurrentTabHandle = $sLastTabHandle
$iTabIndex = $iTabCount - 1
EndIf
_WD_ExecuteScript($sSession, "window.open(arguments[0], '', arguments[1])", '"' & $sURL & '","' & $sFeatures & '"')
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), 0, $sTabHandle)
EndIf
$hWaitTimer = TimerInit()
While 1
$aTemp = _WD_Window($sSession, 'handles')
If UBound($aTemp) > $iTabCount Then
$sTabHandle = $aTemp[$iTabIndex + 1]
ExitLoop
EndIf
If TimerDiff($hWaitTimer) > $iTimeout Then Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Timeout), 0, $sTabHandle)
__WD_Sleep(10)
WEnd
If $bSwitch Then
_WD_Window($sSession, 'Switch', '{"handle":"' & $sTabHandle & '"}')
Else
_WD_Window($sSession, 'Switch', '{"handle":"' & $sCurrentTabHandle & '"}')
EndIf
EndIf
Return SetError($_WD_ERROR_Success, 0, $sTabHandle)
EndFunc
Func _WD_Attach($sSession, $sString, $sMode = Default)
Local Const $sFuncName = "_WD_Attach"
Local $sTabHandle = '', $bFound = False, $sCurrentTab = '', $aHandles
If $sMode = Default Then $sMode = 'title'
$aHandles = _WD_Window($sSession, 'handles')
If @error = $_WD_ERROR_Success Then
$sCurrentTab = _WD_Window($sSession, 'window')
For $sHandle In $aHandles
_WD_Window($sSession, 'Switch', '{"handle":"' & $sHandle & '"}')
Switch $sMode
Case "title", "url"
If StringInStr(_WD_Action($sSession, $sMode), $sString) > 0 Then
$bFound = True
$sTabHandle = $sHandle
ExitLoop
EndIf
Case 'html'
If StringInStr(_WD_GetSource($sSession), $sString) > 0 Then
$bFound = True
$sTabHandle = $sHandle
ExitLoop
EndIf
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Title|URL|HTML) $sMode=>" & $sMode), 0, $sTabHandle)
EndSwitch
Next
If Not $bFound Then
If $sCurrentTab <> '' Then
_WD_Window($sSession, 'Switch', '{"handle":"' & $sCurrentTab & '"}')
EndIf
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_NoMatch), 0, $sTabHandle)
EndIf
Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_GeneralError), 0, $sTabHandle)
EndIf
Return SetError($_WD_ERROR_Success, 0, $sTabHandle)
EndFunc
Func _WD_LinkClickByText($sSession, $sText, $bPartial = Default)
Local Const $sFuncName = "_WD_LinkClickByText"
If $bPartial = Default Then $bPartial = True
Local $sElement = _WD_FindElement($sSession, ($bPartial) ? $_WD_LOCATOR_ByPartialLinkText : $_WD_LOCATOR_ByLinkText, $sText)
Local $iErr = @error
If $iErr = $_WD_ERROR_Success Then
_WD_ElementAction($sSession, $sElement, 'click')
$iErr = @error
If $iErr <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), $_WD_HTTPRESULT)
EndIf
Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_NoMatch), $_WD_HTTPRESULT)
EndIf
Return SetError($_WD_ERROR_Success)
EndFunc
Func _WD_WaitElement($sSession, $sStrategy, $sSelector, $iDelay = Default, $iTimeout = Default, $iOptions = Default)
Local Const $sFuncName = "_WD_WaitElement"
Local $iErr, $sElement, $bIsVisible = True, $bIsEnabled = True
If $iDelay = Default Then $iDelay = 0
If $iTimeout = Default Then $iTimeout = $_WD_DefaultTimeout
If $iOptions = Default Then $iOptions = $_WD_OPTION_None
Local $bVisible = BitAND($iOptions, $_WD_OPTION_Visible)
Local $bEnabled = BitAND($iOptions, $_WD_OPTION_Enabled)
Local $bCheckNoMatch = BitAND($iOptions, $_WD_OPTION_NoMatch)
If $bCheckNoMatch And $iOptions <> $_WD_OPTION_NoMatch Then
$iErr = $_WD_ERROR_InvalidArgue
Else
__WD_Sleep($iDelay)
If @error Then
$iErr = $_WD_ERROR_UserAbort
Else
Local $hWaitTimer = TimerInit()
While 1
$sElement = _WD_FindElement($sSession, $sStrategy, $sSelector)
$iErr = @error
If $iErr = $_WD_ERROR_NoMatch And $bCheckNoMatch Then
$iErr = $_WD_ERROR_Success
ExitLoop
ElseIf $iErr = $_WD_ERROR_Success Then
If $bVisible Then
$bIsVisible = _WD_ElementAction($sSession, $sElement, 'displayed')
If @error Then
$bIsVisible = False
EndIf
EndIf
If $bEnabled Then
$bIsEnabled = _WD_ElementAction($sSession, $sElement, 'enabled')
If @error Then
$bIsEnabled = False
EndIf
EndIf
If $bIsVisible And $bIsEnabled Then
ExitLoop
Else
$sElement = ''
EndIf
EndIf
If (TimerDiff($hWaitTimer) > $iTimeout) Then
$iErr = $_WD_ERROR_Timeout
ExitLoop
EndIf
__WD_Sleep(1000)
If @error Then
$iErr = $_WD_ERROR_UserAbort
ExitLoop
EndIf
WEnd
EndIf
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sElement)
EndFunc
Func _WD_GetMouseElement($sSession)
Local Const $sFuncName = "_WD_GetMouseElement"
Local $sResponse, $oJSON, $sElement
Local $sScript = "return Array.from(document.querySelectorAll(':hover')).pop()"
$sResponse = _WD_ExecuteScript($sSession, $sScript, '')
$oJSON = Json_Decode($sResponse)
$sElement = Json_Get($oJSON, "[value][" & $_WD_ELEMENT_ID & "]")
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sElement & @CRLF)
__WD_ConsoleWrite($sFuncName & ': ' & IsObj($sElement) & @CRLF)
EndIf
Return SetError($_WD_ERROR_Success, 0, $sElement)
EndFunc
Func _WD_GetElementFromPoint($sSession, $iX, $iY)
Local $sResponse, $sElement, $oJSON
Local $sScript = "return document.elementFromPoint(arguments[0], arguments[1]);"
Local $sParams = $iX & ", " & $iY
$sResponse = _WD_ExecuteScript($sSession, $sScript, $sParams)
$oJSON = Json_Decode($sResponse)
$sElement = Json_Get($oJSON, "[value][" & $_WD_ELEMENT_ID & "]")
Return SetError($_WD_ERROR_Success, 0, $sElement)
EndFunc
Func _WD_LastHTTPResult()
Return $_WD_HTTPRESULT
EndFunc
Func _WD_GetFrameCount($sSession)
Local Const $sFuncName = "_WD_GetFrameCount"
Local $sResponse, $oJSON, $iValue
$sResponse = _WD_ExecuteScript($sSession, "return window.frames.length")
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), "")
EndIf
$oJSON = Json_Decode($sResponse)
$iValue = Json_Get($oJSON, "[value]")
Return SetError($_WD_ERROR_Success, 0, Number($iValue))
EndFunc
Func _WD_IsWindowTop($sSession)
Local Const $sFuncName = "_WD_IsWindowTop"
Local $sResponse, $oJSON
Local $blnResult
$sResponse = _WD_ExecuteScript($sSession, "return window.top == window.self")
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), "")
EndIf
$oJSON = Json_Decode($sResponse)
$blnResult = Json_Get($oJSON, "[value]")
Return SetError($_WD_ERROR_Success, 0, $blnResult)
EndFunc
Func _WD_FrameEnter($sSession, $vIdentifier)
Local Const $sFuncName = "_WD_FrameEnter"
Local $sOption
Local $sResponse, $oJSON
Local $sValue
If (IsKeyword($vIdentifier) = $KEYWORD_NULL) Then
$sOption = '{"id":null}'
ElseIf IsInt($vIdentifier) Then
$sOption = '{"id":' & $vIdentifier & '}'
Else
$sOption = '{"id":{"' & $_WD_ELEMENT_ID & '":"' & $vIdentifier & '"}}'
EndIf
$sResponse = _WD_Window($sSession, "frame", $sOption)
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), "")
EndIf
$oJSON = Json_Decode($sResponse)
$sValue = Json_Get($oJSON, "[value]")
If $sValue <> Null Then
$sValue = Json_Get($oJSON, "[value][error]")
Else
$sValue = True
EndIf
Return SetError($_WD_ERROR_Success, 0, $sValue)
EndFunc
Func _WD_FrameLeave($sSession)
Local Const $sFuncName = "_WD_FrameLeave"
Local $sOption
Local $sResponse, $oJSON, $asJSON
Local $sValue
$sOption = '{}'
$sResponse = _WD_Window($sSession, "parent", $sOption)
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), "")
EndIf
$oJSON = Json_Decode($sResponse)
$sValue = Json_Get($oJSON, "[value]")
If $sValue <> Null Then
If Json_IsObject($sValue) = True Then
$asJSON = Json_ObjGetKeys($sValue)
If UBound($asJSON) = 0 Then
$sValue = True
Else
$sValue = $asJSON[0] & ":" & Json_Get($oJSON, "[value][" & $asJSON[0] & "]")
EndIf
EndIf
Else
$sValue = True
EndIf
Return SetError($_WD_ERROR_Success, 0, $sValue)
EndFunc
Func _WD_HighlightElement($sSession, $sElement, $iMethod = Default)
Local Const $aMethod[] = ["border: 0px",  "border: 2px dotted red",  "background: #FFFF66; border-radius: 5px; padding-left: 3px;",  "border:2px dotted  red;background: #FFFF66; border-radius: 5px; padding-left: 3px;"]
If $iMethod = Default Then $iMethod = 1
If $iMethod < 0 Or $iMethod > 3 Then $iMethod = 1
Local $sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}'
Local $sResponse = _WD_ExecuteScript($sSession, "arguments[0].style='" & $aMethod[$iMethod] & "'; return true;", $sJsonElement)
Local $oJSON = Json_Decode($sResponse)
Local $sResult = Json_Get($oJSON, "[value]")
Return ($sResult = "true" ? SetError(0, 0, $sResult) : SetError(1, 0, False))
EndFunc
Func _WD_HighlightElements($sSession, $aElements, $iMethod = Default)
Local $iHighlightedElements = 0
If $iMethod = Default Then $iMethod = 1
For $i = 0 To UBound($aElements) - 1
$iHighlightedElements += (_WD_HighlightElement($sSession, $aElements[$i], $iMethod) = True ? 1 : 0)
Next
Return ($iHighlightedElements > 0 ? SetError(0, $iHighlightedElements, True) : SetError(1, 0, False))
EndFunc
Func _WD_LoadWait($sSession, $iDelay = Default, $iTimeout = Default, $sElement = Default)
Local Const $sFuncName = "_WD_LoadWait"
Local $iErr, $sResponse, $oJSON, $sReadyState
If $iDelay = Default Then $iDelay = 0
If $iTimeout = Default Then $iTimeout = $_WD_DefaultTimeout
If $sElement = Default Then $sElement = ""
If $iDelay Then __WD_Sleep($iDelay)
If @error Then
$iErr = $_WD_ERROR_UserAbort
Else
Local $hLoadWaitTimer = TimerInit()
While True
If $sElement <> '' Then
_WD_ElementAction($sSession, $sElement, 'name')
If $_WD_HTTPRESULT = $HTTP_STATUS_NOT_FOUND Then $sElement = ''
Else
$sResponse = _WD_ExecuteScript($sSession, 'return document.readyState', '')
$iErr = @error
If $iErr Then
ExitLoop
EndIf
$oJSON = Json_Decode($sResponse)
$sReadyState = Json_Get($oJSON, "[value]")
If $sReadyState = 'complete' Then ExitLoop
EndIf
If (TimerDiff($hLoadWaitTimer) > $iTimeout) Then
$iErr = $_WD_ERROR_Timeout
ExitLoop
EndIf
__WD_Sleep(100)
If @error Then
$iErr = $_WD_ERROR_UserAbort
ExitLoop
EndIf
WEnd
EndIf
If $iErr Then
Return SetError(__WD_Error($sFuncName, $iErr, ""), 0, 0)
EndIf
Return SetError($_WD_ERROR_Success, 0, 1)
EndFunc
Func _WD_Screenshot($sSession, $sElement = Default, $nOutputType = Default)
Local Const $sFuncName = "_WD_Screenshot"
Local $sResponse, $sResult, $iErr
If $sElement = Default Then $sElement = ""
If $nOutputType = Default Then $nOutputType = 1
If $sElement = '' Then
$sResponse = _WD_Window($sSession, 'Screenshot')
$iErr = @error
Else
$sResponse = _WD_ElementAction($sSession, $sElement, 'Screenshot')
$iErr = @error
EndIf
If $iErr = $_WD_ERROR_Success Then
Switch $nOutputType
Case 1
$sResult = BinaryToString(__WD_Base64Decode($sResponse))
Case 2
$sResult = __WD_Base64Decode($sResponse)
Case 3
$sResult = $sResponse
EndSwitch
Else
$sResult = ''
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sResult)
EndFunc
Func _WD_PrintToPDF($sSession, $sOptions = Default)
Local Const $sFuncName = "_WD_PrintToPDF"
Local $sResponse, $sResult, $iErr
If $sOptions = Default Then $sOptions = $_WD_EmptyDict
$sResponse = _WD_Window($sSession, 'print', $sOptions)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sResult = __WD_Base64Decode($sResponse)
Else
$sResult = ''
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sResult)
EndFunc
Func _WD_jQuerify($sSession, $sjQueryFile = Default, $iTimeout = Default)
Local Const $sFuncName = "_WD_jQuerify"
If $sjQueryFile = Default Then
$sjQueryFile = ""
Else
$sjQueryFile = '"' & StringReplace($sjQueryFile, "\", "/") & '"'
EndIf
If $iTimeout = Default Then $iTimeout = $_WD_DefaultTimeout
Local $jQueryLoader =  "(function(jqueryUrl, callback) {" &  "    if (typeof jqueryUrl != 'string') {" &  "        jqueryUrl = 'https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js';" &  "    }" &  "    if (typeof jQuery == 'undefined') {" &  "        var script = document.createElement('script');" &  "        var head = document.getElementsByTagName('head')[0];" &  "        var done = false;" &  "        script.onload = script.onreadystatechange = (function() {" &  "            if (!done && (!this.readyState || this.readyState == 'loaded' " &  "                    || this.readyState == 'complete')) {" &  "                done = true;" &  "                script.onload = script.onreadystatechange = null;" &  "                head.removeChild(script);" &  "                callback();" &  "            }" &  "        });" &  "        script.src = jqueryUrl;" &  "        head.appendChild(script);" &  "    }" &  "    else {" &  "        jQuery.noConflict();" &  "        callback();" &  "    }" &  "})(arguments[0], arguments[arguments.length - 1]);"
_WD_ExecuteScript($sSession, $jQueryLoader, $sjQueryFile, True)
If @error = $_WD_ERROR_Success Then
Local $hWaitTimer = TimerInit()
Do
If TimerDiff($hWaitTimer) > $iTimeout Then
SetError($_WD_ERROR_Timeout)
ExitLoop
EndIf
__WD_Sleep(250)
_WD_ExecuteScript($sSession, "jQuery")
Until @error = $_WD_ERROR_Success
EndIf
Local $iErr = @error
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $iErr & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr))
EndFunc
Func _WD_ElementOptionSelect($sSession, $sStrategy, $sSelector, $sStartElement = Default)
If $sStartElement = Default Then $sStartElement = ""
Local $sElement = _WD_FindElement($sSession, $sStrategy, $sSelector, $sStartElement)
If @error = $_WD_ERROR_Success Then
_WD_ElementAction($sSession, $sElement, 'click')
EndIf
Return SetError(@error, @extended)
EndFunc
Func _WD_ElementSelectAction($sSession, $sSelectElement, $sCommand)
Local Const $sFuncName = "_WD_ElementSelectAction"
Local $sNodeName, $sJsonElement, $sResponse, $oJSON, $vResult
Local $sText, $aOptions
$sNodeName = _WD_ElementAction($sSession, $sSelectElement, 'property', 'nodeName')
Local $iErr = @error
If $iErr = $_WD_ERROR_Success And $sNodeName = 'select' Then
Switch $sCommand
Case 'value'
$sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sSelectElement & '"}'
$sResponse = _WD_ExecuteScript($sSession, "return arguments[0].value", $sJsonElement)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$oJSON = Json_Decode($sResponse)
$vResult = Json_Get($oJSON, "[value]")
EndIf
Case 'options'
$aOptions = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, "./option", $sSelectElement, True)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sText = ""
For $sElement In $aOptions
$sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}'
$sResponse = _WD_ExecuteScript($sSession, "return arguments[0].value + '|' + arguments[0].label", $sJsonElement)
$iErr = @error
If $iErr = $_WD_ERROR_Success Then
$oJSON = Json_Decode($sResponse)
$sText &= (($sText <> "") ? @CRLF : "") & Json_Get($oJSON, "[value]")
EndIf
Next
Local $aOut[0][2]
_ArrayAdd($aOut, $sText, 0, Default, Default, 1)
$vResult = $aOut
EndIf
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Value|Options) $sCommand=>" & $sCommand), 0, "")
EndSwitch
Else
$iErr = $_WD_ERROR_InvalidArgue
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & ((IsArray($vResult)) ? "(array)" : $vResult) & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), $_WD_HTTPRESULT, $vResult)
EndFunc
Func _WD_ConsoleVisible($bVisible = Default)
Local $sFile = __WD_StripPath($_WD_DRIVER)
Local $pid, $pid2, $hWnd = 0, $aWinList
If $bVisible = Default Then $bVisible = False
$pid = ProcessExists($sFile)
If $pid Then
$aWinList = WinList("[CLASS:ConsoleWindowClass]")
For $i = 1 To $aWinList[0][0]
$pid2 = WinGetProcess($aWinList[$i][1])
If $pid2 = $pid Then
$hWnd = $aWinList[$i][1]
ExitLoop
EndIf
Next
If $hWnd <> 0 Then
WinSetState($hWnd, "", $bVisible ? @SW_SHOW : @SW_HIDE)
EndIf
EndIf
EndFunc
Func _WD_GetShadowRoot($sSession, $sStrategy, $sSelector, $sStartElement = Default)
Local Const $sFuncName = "_WD_GetShadowRoot"
Local $sResponse, $sResult, $oJSON
If $sStartElement = Default Then $sStartElement = ""
Local $sElement = _WD_FindElement($sSession, $sStrategy, $sSelector, $sStartElement)
Local $iErr = @error
If $iErr = $_WD_ERROR_Success Then
$sResponse = _WD_ElementAction($sSession, $sElement, 'shadow')
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value][" & $_WD_ELEMENT_ID & "]")
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResult & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_SelectFiles($sSession, $sStrategy, $sSelector, $sFilename)
Local Const $sFuncName = "_WD_SelectFiles"
Local $sResponse, $sResult, $sJsonElement, $oJSON, $sSavedEscape
Local $sElement = _WD_FindElement($sSession, $sStrategy, $sSelector)
Local $iErr = @error
If $iErr = $_WD_ERROR_Success Then
If $sFilename <> "" Then
$sSavedEscape = $_WD_ESCAPE_CHARS
$sFilename = StringReplace(__WD_EscapeString($sFilename), @LF, "\n")
$_WD_ESCAPE_CHARS = ""
$sResponse = _WD_ElementAction($sSession, $sElement, 'value', $sFilename)
$iErr = @error
$_WD_ESCAPE_CHARS = $sSavedEscape
Else
$sResponse = _WD_ElementAction($sSession, $sElement, 'clear')
$iErr = @error
EndIf
If $iErr = $_WD_ERROR_Success Then
$sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}'
$sResponse = _WD_ExecuteScript($sSession, "return arguments[0].files.length", $sJsonElement)
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
Else
$sResult = "0"
EndIf
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $sResult & " file(s) selected" & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), $_WD_HTTPRESULT, $sResult)
EndFunc
Func _WD_IsLatestRelease()
Local Const $sFuncName = "_WD_IsLatestRelease"
Local Const $sGitURL = "https://github.com/Danp2/WebDriver/releases/latest"
Local $bResult = Null
Local $iErr = $_WD_ERROR_Success
Local $sResult = InetRead($sGitURL)
If @error Then $iErr = $_WD_ERROR_GeneralError
If $iErr = $_WD_ERROR_Success Then
Local $aLatestWDVersion = StringRegExp(BinaryToString($sResult), '<a href="/Danp2/WebDriver/releases/tag/(.*)">', $STR_REGEXPARRAYMATCH)
If Not @error Then
Local $sLatestWDVersion = $aLatestWDVersion[0]
$bResult = ($__WDVERSION == $sLatestWDVersion)
EndIf
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $bResult & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), $_WD_HTTPRESULT, $bResult)
EndFunc
Func _WD_UpdateDriver($sBrowser, $sInstallDir = Default, $bFlag64 = Default, $bForce = Default)
Local Const $sFuncName = "_WD_UpdateDriver"
Local $iErr = $_WD_ERROR_Success, $sDriverEXE, $sBrowserVersion, $bResult = False
Local $sDriverVersion, $sVersionShort, $sDriverLatest, $sURLNewDriver
Local $sReturned, $sTempFile, $hFile, $oShell, $FilesInZip, $sResult, $iStartPos, $iConversion
If $sInstallDir = Default Then $sInstallDir = @ScriptDir
If $bFlag64 = Default Then $bFlag64 = False
If $bForce = Default Then $bForce = False
If (Not FileExists($sInstallDir)) And (Not DirCreate($sInstallDir)) Then $iErr = $_WD_ERROR_InvalidValue
Local $WDDebugSave = $_WD_DEBUG
$_WD_DEBUG = $_WD_DEBUG_None
Switch $sBrowser
Case 'chrome'
$sDriverEXE = "chromedriver.exe"
Case 'firefox'
$sDriverEXE = "geckodriver.exe"
Case 'msedge'
$sDriverEXE = "msedgedriver.exe"
Case Else
$iErr = $_WD_ERROR_InvalidValue
EndSwitch
If $iErr = $_WD_ERROR_Success Then
$sBrowserVersion = _WD_GetBrowserVersion($sBrowser)
If @error Then $iErr = @error
$sDriverVersion = _WD_GetWebDriverVersion($sInstallDir, $sDriverEXE)
If @error Then $iErr = @error
Switch $sBrowser
Case 'chrome'
$sVersionShort = StringLeft($sBrowserVersion, StringInStr($sBrowserVersion, ".", 0, -1) - 1)
$sDriverLatest = BinaryToString(InetRead('https://chromedriver.storage.googleapis.com/LATEST_RELEASE_' & $sVersionShort))
$sURLNewDriver = "https://chromedriver.storage.googleapis.com/" & $sDriverLatest & "/chromedriver_win32.zip"
Case 'firefox'
$sResult = BinaryToString(InetRead("https://github.com/mozilla/geckodriver/releases/latest"))
If @error = $_WD_ERROR_Success Then
$sDriverLatest = StringRegExp($sResult, 'href="\/mozilla\/geckodriver\/releases\/tag\/(.*?)"', 1)[0]
$sURLNewDriver = "https://github.com/mozilla/geckodriver/releases/download/" & $sDriverLatest & "/geckodriver-" & $sDriverLatest
$sURLNewDriver &= ($bFlag64) ? "-win64.zip" : "-win32.zip"
ConsoleWrite("Firefox download:" & $sURLNewDriver&@CRLF)
Else
$iErr = $_WD_ERROR_GeneralError
EndIf
Case 'msedge'
$sVersionShort = StringLeft($sBrowserVersion, StringInStr($sBrowserVersion, ".") - 1)
$sDriverLatest = InetRead('https://msedgedriver.azureedge.net/LATEST_RELEASE_' & $sVersionShort)
If @error = $_WD_ERROR_Success Then
Select
Case BinaryMid($sDriverLatest, 1, 4) = '0x0000FEFF'
$iStartPos = 5
$iConversion = $SB_UTF16LE
Case BinaryMid($sDriverLatest, 1, 4) = '0xFFFE0000'
$iStartPos = 5
$iConversion = $SB_UTF16LE
Case BinaryMid($sDriverLatest, 1, 2) = '0xFEFF'
$iStartPos = 3
$iConversion = $SB_UTF16BE
Case BinaryMid($sDriverLatest, 1, 2) = '0xFFFE'
$iStartPos = 3
$iConversion = $SB_UTF16LE
Case BinaryMid($sDriverLatest, 1, 3) = '0xEFBBBF'
$iStartPos = 4
$iConversion = $SB_UTF8
Case Else
$iStartPos = 1
$iConversion = $SB_ANSI
EndSelect
$sDriverLatest = StringStripWS(BinaryToString(BinaryMid($sDriverLatest, $iStartPos), $iConversion), $STR_STRIPTRAILING)
$sURLNewDriver = "https://msedgedriver.azureedge.net/" & $sDriverLatest & "/edgedriver_"
$sURLNewDriver &= ($bFlag64) ? "win64.zip" : "win32.zip"
Else
$iErr = $_WD_ERROR_GeneralError
EndIf
EndSwitch
If ($iErr = $_WD_ERROR_Success And $sDriverLatest > $sDriverVersion) Or $bForce Then
$sReturned = InetRead($sURLNewDriver)
$sTempFile = _TempFile($sInstallDir, "webdriver_", ".zip")
$hFile = FileOpen($sTempFile, 18)
FileWrite($hFile, $sReturned)
FileClose($hFile)
__WD_CloseDriver($sDriverEXE)
FileDelete($sInstallDir & "\" & $sDriverEXE)
Local $oErr = ObjEvent("AutoIt.Error", __WD_ErrHnd)
#forceref $oErr
$oShell = ObjCreate("Shell.Application")
If @error Then
$iErr = $_WD_ERROR_GeneralError
Else
$FilesInZip = $oShell.NameSpace($sTempFile).items
If @error Then
$iErr = $_WD_ERROR_GeneralError
Else
$oShell.NameSpace($sInstallDir).CopyHere($FilesInZip, 20)
If @error Then
$iErr = $_WD_ERROR_GeneralError
Else
$iErr = $_WD_ERROR_Success
$bResult = True
EndIf
EndIf
EndIf
FileDelete($sTempFile)
EndIf
EndIf
$_WD_DEBUG = $WDDebugSave
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $iErr & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $bResult)
EndFunc
Func _WD_GetBrowserVersion($sBrowser)
Local Const $sFuncName = "_WD_GetBrowserVersion"
Local Const $cRegKey = 'HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\'
Local $sEXE, $sBrowserVersion = ''
Local $iErr = $_WD_ERROR_Success
Switch $sBrowser
Case 'chrome'
$sEXE = "chrome.exe"
Case 'firefox'
$sEXE = "firefox.exe"
Case 'msedge'
$sEXE = "msedge.exe"
Case Else
$iErr = $_WD_ERROR_InvalidValue
EndSwitch
If $iErr = $_WD_ERROR_Success Then
Local $sPath = RegRead($cRegKey & $sEXE, "")
If @error Then
$iErr = $_WD_ERROR_NotFound
Else
$sBrowserVersion = FileGetVersion($sPath)
EndIf
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sBrowserVersion)
EndFunc
Func _WD_GetWebDriverVersion($sInstallDir, $sDriverEXE)
Local Const $sFuncName = "_WD_GetWebDriverVersion"
Local $sDriverVersion = "None"
Local $iErr = $_WD_ERROR_Success
$sInstallDir = StringRegExpReplace($sInstallDir, '(?i)(\\)\Z', '') & '\'
If Not FileExists($sInstallDir & $sDriverEXE) Then
$iErr = $_WD_ERROR_NotFound
Else
Local $sCmd = $sInstallDir & $sDriverEXE & " --version"
Local $iPID = Run($sCmd, $sInstallDir, @SW_HIDE, $STDOUT_CHILD)
If @error Then $iErr = $_WD_ERROR_GeneralError
If $iPID Then
ProcessWaitClose($iPID)
Local $sOutput = StdoutRead($iPID)
$sDriverVersion = StringRegExp($sOutput, "\s+([^\s]+)", 1)[0]
$iErr = $_WD_ERROR_Success
EndIf
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sDriverVersion)
EndFunc
Func _WD_DownloadFile($sURL, $sDest, $iOptions = Default)
Local Const $sFuncName = "_WD_DownloadFile"
Local $bResult = False
Local $iErr = $_WD_ERROR_Success
If $iOptions = Default Then $iOptions = $INET_FORCERELOAD + $INET_IGNORESSL + $INET_BINARYTRANSFER
Local $sData = InetRead($sURL, $iOptions)
If @error Then $iErr = $_WD_ERROR_GeneralError
If $iErr = $_WD_ERROR_Success Then
Local $hFile = FileOpen($sDest, 18)
If $hFile <> -1 Then
FileWrite($hFile, $sData)
FileClose($hFile)
$bResult = True
Else
$iErr = $_WD_ERROR_GeneralError
EndIf
Else
$iErr = $_WD_ERROR_NotFound
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $iErr & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $bResult)
EndFunc
Func _WD_SetTimeouts($sSession, $iPageLoad = Default, $iScript = Default, $iImplicitWait = Default)
Local Const $sFuncName = "_WD_SetTimeouts"
Local $sTimeouts = '', $sResult = '', $bIsNull
If $iPageLoad <> Default Then
If Not IsInt($iPageLoad) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $iPageLoad), 0, 0)
EndIf
$sTimeouts &= '"pageLoad":' & $iPageLoad
EndIf
If $iScript <> Default Then
$bIsNull = (IsKeyword($iScript) = $KEYWORD_NULL)
If Not IsInt($iScript) And Not $bIsNull Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $iScript), 0, 0)
EndIf
If StringLen($sTimeouts) Then $sTimeouts &= ", "
$sTimeouts &= '"script":'
$sTimeouts &= ($bIsNull) ? "null" : $iScript
EndIf
If $iImplicitWait <> Default Then
If Not IsInt($iImplicitWait) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $vValue: " & $iImplicitWait), 0, 0)
EndIf
If StringLen($sTimeouts) Then $sTimeouts &= ", "
$sTimeouts &= '"implicit":' & $iImplicitWait
EndIf
If StringLen($sTimeouts) Then
$sTimeouts = "{" & $sTimeouts & "}"
$sResult = _WD_Timeouts($sSession, $sTimeouts)
Local $iErr = @error
If $iErr = $_WD_ERROR_Success And $iPageLoad <> Default Then
$_WD_HTTPTimeOuts[3] = $iPageLoad + 1000
EndIf
Else
$iErr = $_WD_ERROR_InvalidArgue
$sResult = 0
EndIf
If $_WD_DEBUG = $_WD_DEBUG_Info Then
__WD_ConsoleWrite($sFuncName & ': ' & $iErr & @CRLF)
EndIf
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sResult)
EndFunc
Func _WD_GetElementById($sSession, $sID)
Local Const $sFuncName = "_WD_GetElementById"
Local $sXpath = '//*[@id="' & $sID & '"]'
Local $sElement = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sXpath)
Local $iErr = @error
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sElement)
EndFunc
Func _WD_GetElementByName($sSession, $sName)
Local Const $sFuncName = "_WD_GetElementByName"
Local $sXpath = '//*[@name="' & $sName & '"]'
Local $sElement = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sXpath)
Local $iErr = @error
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sElement)
EndFunc
Func _WD_SetElementValue($sSession, $sElement, $sValue, $iStyle = Default)
Local Const $sFuncName = "_WD_SetElementValue"
Local $sResult, $iErr, $sScript, $sJsonElement
If $iStyle = Default Then $iStyle = $_WD_OPTION_Standard
If $iStyle < $_WD_OPTION_Standard Or $iStyle > $_WD_OPTION_Advanced Then $iStyle = $_WD_OPTION_Standard
Switch $iStyle
Case $_WD_OPTION_Standard
$sResult = _WD_ElementAction($sSession, $sElement, 'value', $sValue)
$iErr = @error
Case $_WD_OPTION_Advanced
$sScript = "Object.getOwnPropertyDescriptor(arguments[0].__proto__, 'value').set.call(arguments[0], arguments[1]);arguments[0].dispatchEvent(new Event('input', { bubbles: true }));"
$sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}'
$sResult = _WD_ExecuteScript($sSession, $sScript, $sJsonElement & ',"' & $sValue & '"')
$iErr = @error
EndSwitch
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sResult)
EndFunc
Func _WD_ElementActionEx($sSession, $sElement, $sCommand, $iXOffset = Default, $iYOffset = Default, $iButton = Default, $iHoldDelay = Default, $sModifier = Default)
Local Const $sFuncName = "_WD_ElementActionEx"
Local $sAction, $sJavascript, $iErr, $sResult, $sJsonElement, $sResponse, $oJSON, $iActionType = 1
If $iXOffset = Default Then $iXOffset = 0
If $iYOffset = Default Then $iYOffset = 0
If $iButton = Default Then $iButton = 0
If $iHoldDelay = Default Then $iHoldDelay = 1000
If $sModifier = Default Then $sModifier = "\uE008"
If Not IsInt($iXOffset) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $iXOffset: " & $iXOffset), 0, "")
EndIf
If Not IsInt($iButton) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $iButton: " & $iButton), 0, "")
EndIf
If Not IsInt($iYOffset) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $iYOffset: " & $iYOffset), 0, "")
EndIf
If Not IsInt($iHoldDelay) Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(int) $iHoldDelay: " & $iHoldDelay), 0, "")
EndIf
Local $sPreAction = '', $sPostAction = '', $sPostHoverAction = ''
Switch $sCommand
Case 'hover'
Case 'doubleclick'
$sPostHoverAction = ',{"button":' & $iButton & ',"type":"pointerDown"},{"button":' & $iButton & ',"type":"pointerUp"},{"button":' & $iButton & ',"type":"pointerDown"},{"button":' & $iButton & ',"type":"pointerUp"}'
Case 'rightclick'
$sPostHoverAction = ',{"button":2,"type":"pointerDown"},{"button":2,"type":"pointerUp"}'
Case 'clickandhold'
$sPostHoverAction = ',{"button":' & $iButton & ',"type":"pointerDown"},{"type": "pause", "duration": ' & $iHoldDelay & '},{"button":' & $iButton & ',"type":"pointerUp"}'
Case 'hide'
$iActionType = 2
$sJavascript = "arguments[0].style='display: none'; return true;"
Case 'show'
$iActionType = 2
$sJavascript = "arguments[0].style='display: normal'; return true;"
Case 'childcount'
$iActionType = 2
$sJavascript = "return arguments[0].children.length;"
Case 'modifierclick'
$sPreAction = '{"type": "key", "id": "keyboard_1", "actions": [{"type": "keyDown", "value": "' & $sModifier & '"}]},'
$sPostHoverAction = ',{"button":' & $iButton & ',"type":"pointerDown"}, {"button":' & $iButton & ',"type":"pointerUp"}'
$sPostAction = ',{"type": "key", "id": "keyboard_2", "actions": [{"type": "keyUp", "value": "' & $sModifier & '"}]}'
Case Else
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_InvalidDataType, "(Hover|RightClick|DoubleClick|ClickAndHold|Hide|Show|ChildCount|ModifierClick) $sCommand=>" & $sCommand), 0, "")
EndSwitch
Switch $iActionType
Case 1
$sAction = '{"actions":['
If $sPreAction Then
$sAction &= $sPreAction
EndIf
$sAction &= '{"id":"hover","type":"pointer","parameters":{"pointerType":"mouse"},"actions":[{"duration":100,'
$sAction &= '"x":' & $iXOffset & ',"y":' & $iYOffset & ',"type":"pointerMove","origin":{"ELEMENT":"'
$sAction &= $sElement & '","' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}}'
If $sPostHoverAction Then
$sAction &= $sPostHoverAction
EndIf
$sAction &= "]}"
If $sPostAction Then
$sAction &= $sPostAction
EndIf
$sAction &= "]}"
$sResult = _WD_Action($sSession, 'actions', $sAction)
$iErr = @error
Case 2
$sJsonElement = '{"' & $_WD_ELEMENT_ID & '":"' & $sElement & '"}'
$sResponse = _WD_ExecuteScript($sSession, $sJavascript, $sJsonElement)
$iErr = @error
$oJSON = Json_Decode($sResponse)
$sResult = Json_Get($oJSON, "[value]")
EndSwitch
Return SetError(__WD_Error($sFuncName, $iErr), 0, $sResult)
EndFunc
Func _WD_GetTable($sSession, $sBaseElement)
Local Const $sFuncName = "_WD_GetTable"
Local $aElements, $iLines, $iColumns, $iRow, $iColumn
Local $sElement, $sHTML
Call("_HtmlTableGetWriteToArray", "")
If @error = 0xDEAD And @extended = 0xBEEF Then
$aElements = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sBaseElement & "/tbody/tr", "", True)
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
$iLines = UBound($aElements)
$aElements = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sBaseElement & "/tbody/tr[1]/td", "", True)
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
$iColumns = UBound($aElements)
Local $aTable[$iLines][$iColumns]
$aElements = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sBaseElement & "/tbody/tr/td", "", True)
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
For $i = 0 To UBound($aElements) - 1
$iRow = Int($i / $iColumns)
$iColumn = Mod($i, $iColumns)
$aTable[$iRow][$iColumn] = _WD_ElementAction($sSession, $aElements[$i], "Text")
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
Next
Else
$sElement = _WD_FindElement($sSession, $_WD_LOCATOR_ByXPath, $sBaseElement)
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
$sHTML = _WD_ElementAction($sSession, $sElement, "Property", "outerHTML")
If @error <> $_WD_ERROR_Success Then Return SetError(__WD_Error($sFuncName, @error, "HTTP status = " & $_WD_HTTPRESULT), $_WD_HTTPRESULT, "")
$aTable = _HtmlTableGetWriteToArray($sHTML, 1, False, $_WD_IFILTER)
EndIf
Return $aTable
EndFunc
Func _WD_IsFullScreen($sSession)
Local Const $sFuncName = "_WD_IsFullScreen"
Local $sResponse = _WD_ExecuteScript($sSession, 'return screen.width == window.innerWidth and screen.height == window.innerHeight;')
If @error <> $_WD_ERROR_Success Then
Return SetError(__WD_Error($sFuncName, $_WD_ERROR_Exception), 0, $sResponse)
EndIf
Local $oJSON = Json_Decode($sResponse)
Local $bResult = Json_Get($oJSON, "[value]")
Return SetError($_WD_ERROR_Success, 0, $bResult)
EndFunc
Func __WD_Base64Decode($input_string)
Local $struct = DllStructCreate("int")
Local $a_Call = DllCall("Crypt32.dll", "int", "CryptStringToBinary",  "str", $input_string,  "int", 0,  "int", 1,  "ptr", 0,  "ptr", DllStructGetPtr($struct, 1),  "ptr", 0,  "ptr", 0)
If @error Or Not $a_Call[0] Then
Return SetError(1, 0, "")
EndIf
Local $a = DllStructCreate("byte[" & DllStructGetData($struct, 1) & "]")
$a_Call = DllCall("Crypt32.dll", "int", "CryptStringToBinary",  "str", $input_string,  "int", 0,  "int", 1,  "ptr", DllStructGetPtr($a),  "ptr", DllStructGetPtr($struct, 1),  "ptr", 0,  "ptr", 0)
If @error Or Not $a_Call[0] Then
Return SetError(2, 0, "")
EndIf
Return DllStructGetData($a, 1)
EndFunc
Func __WD_ErrHnd()
EndFunc
Func InitialSettingsForm()
Global $stashFilePath
Local $Initial_Settings, $tab, $stashPath, $btnBrowse, $btnOK
$Initial_Settings = GUICreate("Initial Settings",1326,809,-1,-1,-1,-1)
GUISetIcon("helper2.ico")
$tab = GUICtrlCreatetab(41,70,1232,661,-1,-1)
GuiCtrlSetState(-1,2048)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlCreateTabItem("  Start  ")
GUICtrlCreateLabel("Welcome to my little GUI helper for Stash!",191,158,908,62,-1,-1)
GUICtrlSetFont(-1,20,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateLabel("StashApp is a great program to manage your porn collection. This little helper will make it easier to run in Windows."&@crlf&"Please start it by tell me where 'stash-win.exe' is.",167,244,937,111,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
$stashPath = GUICtrlCreateInput("",280,391,610,41,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetState(-1,BitOr($GUI_SHOW,$GUI_ENABLE))
GUICtrlSetFont(-1,10,400,0,"Palatino Linotype")
$btnBrowse = GUICtrlCreateButton("Browse",910,391,170,41,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlCreateLabel("If you don't have it yet, you can download it here.",283,470,615,49,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
$btnWebsite = GUICtrlCreateButton("Website",910,470,170,41,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlCreateTabItem(" Choose Browser ")
GUICtrlCreateLabel("Now choose your favorite browser to launch StashApp.",361,150,616,104,-1,-1)
GUICtrlSetFont(-1,16,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
$chooseFirefox = GUICtrlCreateRadio("Firefox",201,286,157,48,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
$chooseChrome = GUICtrlCreateRadio("Chrome",201,348,157,48,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
$chooseEdge = GUICtrlCreateRadio("MS Edge",201,415,157,48,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
$browserDetails = GUICtrlCreateLabel("",451,300,656,163,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateLabel("",406,270,741,235,$SS_GRAYFRAME,-1)
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateTabItem("  Launch!  ")
GUICtrlCreateLabel("Thank you ! Now it's all ready to launch StashApp.",331,160,547,109,-1,-1)
GUICtrlSetFont(-1,16,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateLabel("Note: If this is the first time you run StashApp, it will ask you a question about where to store the config file. Since this is windows, you should choose -> 'In the current working directory.'"&@crlf&""&@crlf&"*** After you finish the wizard, you should click on 'Tasks' then 'Scan' to get your files recognized by Stash."&@crlf&"No movies? No Studio and Performers? No problem. This program will help you along the way.",201,290,895,307,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateTabItem("")
$btnNext = GUICtrlCreateButton("Next",960,630,211,57,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Palatino Linotype")
GUICtrlSetState(-1,BitOr($GUI_SHOW,$GUI_DISABLE))
_GUICtrlTab_SetCurFocus($tab,0)
GUISetState(@SW_SHOW, $Initial_Settings)
Local $bSettingDone = False, $iSecond = @SEC
Local $bPathReady = False , $bBrowserReady = False, $sBrowser
While Not $bSettingDone
Sleep(10)
$nMsg = GUIGetMsg()
Switch $nMsg
Case $btnBrowse
Local $sFile = FileOpenDialog("Open the Stash-Win.exe:",  @DocumentsCommonDir, "(Stash-Win.exe)", $FD_FILEMUSTEXIST )
If Not @error Then
GUICtrlSetData($stashPath, $sFile)
EndIf
Case $btnNext
Switch _GUICtrlTab_GetCurFocus($tab)
Case 0
_GUICtrlTab_SetCurFocus($tab, 1)
Case 1
_GUICtrlTab_SetCurFocus($tab, 2)
Case 2
If $bPathReady And $bBrowserReady Then
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "StashFilePath", "REG_SZ", $stashFilePath)
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "Browser", "REG_SZ", $sBrowser)
$bSettingDone = True
MsgBox(64,"Very Good !",  "Thank you! Now stash will run and this helper will reside in the notification tray area, where the clock and other small icons are.",0)
ExitLoop
EndIf
EndSwitch
Case $btnWebsite
ShellExecute("https://github.com/stashapp/stash/releases")
Case $GUI_EVENT_CLOSE
Exit
EndSwitch
If $iSecond <> @SEC Then
$iSecond = @SEC
Switch _GUICtrlTab_GetCurFocus($tab)
Case 0
GUICtrlSetData($btnNext, "Next")
$stashFilePath = GUICtrlRead($stashPath)
If StringLower(StringRight($stashFilePath, 13)) = "stash-win.exe"  And FileExists($stashFilePath) Then
GUICtrlSetState($btnNext, $GUI_ENABLE)
$bPathReady = True
Else
GUICtrlSetState($btnNext, $GUI_DISABLE)
$bPathReady = False
EndIf
Case 1
GUICtrlSetData($btnNext, "Next")
Select
Case GUICtrlRead($chooseFirefox) = $GUI_CHECKED
GUICtrlSetData($browserDetails, "When launch StashApp with Firefox, you will see a robot icon and address bar turns red, indicating the browser is under my program's control. Other than that, it's all fine.")
$sBrowser = "Firefox"
Case GUICtrlRead($chooseChrome) = $GUI_CHECKED
GUICtrlSetData($browserDetails, "It works perfectly. You won't see red address bar or anything." )
$sBrowser = "Chrome"
Case GUICtrlRead($chooseEdge) = $GUI_CHECKED
GUICtrlSetData($browserDetails,"It works well, but you probably hate Microsoft so..." )
$sBrowser = "Edge"
Case Else
GUICtrlSetData($browserDetails, "Choose one of the browser on the left to see its note here.")
$sBrowser = ""
$bBrowserReady = False
EndSelect
If  $sBrowser <> "" Then
$bBrowserReady = True
GUICtrlSetState($btnNext, $GUI_ENABLE)
EndIf
Case 2
GUICtrlSetData($btnNext, "Launch !")
If $bPathReady And $bBrowserReady Then
GUICtrlSetState($btnNext, $GUI_ENABLE)
Else
GUICtrlSetState($btnNext, $GUI_DISABLE)
EndIf
EndSwitch
EndIf
Wend
GUIDelete($Initial_Settings)
EndFunc
Global Const $ACS_CENTER = 1
Global Const $ACS_TRANSPARENT = 2
Global Const $ACS_AUTOPLAY = 4
Global Const $ACS_TIMER = 8
Global Const $ACS_NONTRANSPARENT = 16
Global Const $GUI_SS_DEFAULT_AVI = $ACS_TRANSPARENT
Global Const $__AVICONSTANT_WM_USER = 0x400
Global Const $ACM_OPENA = $__AVICONSTANT_WM_USER + 100
Global Const $ACM_PLAY = $__AVICONSTANT_WM_USER + 101
Global Const $ACM_STOP = $__AVICONSTANT_WM_USER + 102
Global Const $ACM_ISPLAYING = $__AVICONSTANT_WM_USER + 104
Global Const $ACM_OPENW = $__AVICONSTANT_WM_USER + 103
Global Const $ACN_START = 0x00000001
Global Const $ACN_STOP = 0x00000002
Global Const $CB_ERR = -1
Global Const $CB_ERRATTRIBUTE = -3
Global Const $CB_ERRREQUIRED = -4
Global Const $CB_ERRSPACE = -2
Global Const $CB_OKAY = 0
Global Const $STATE_SYSTEM_INVISIBLE = 0x8000
Global Const $STATE_SYSTEM_PRESSED = 0x8
Global Const $CBS_AUTOHSCROLL = 0x40
Global Const $CBS_DISABLENOSCROLL = 0x800
Global Const $CBS_DROPDOWN = 0x2
Global Const $CBS_DROPDOWNLIST = 0x3
Global Const $CBS_HASSTRINGS = 0x200
Global Const $CBS_LOWERCASE = 0x4000
Global Const $CBS_NOINTEGRALHEIGHT = 0x400
Global Const $CBS_OEMCONVERT = 0x80
Global Const $CBS_OWNERDRAWFIXED = 0x10
Global Const $CBS_OWNERDRAWVARIABLE = 0x20
Global Const $CBS_SIMPLE = 0x1
Global Const $CBS_SORT = 0x100
Global Const $CBS_UPPERCASE = 0x2000
Global Const $CBM_FIRST = 0x1700
Global Const $CB_ADDSTRING = 0x143
Global Const $CB_DELETESTRING = 0x144
Global Const $CB_DIR = 0x145
Global Const $CB_FINDSTRING = 0x14C
Global Const $CB_FINDSTRINGEXACT = 0x158
Global Const $CB_GETCOMBOBOXINFO = 0x164
Global Const $CB_GETCOUNT = 0x146
Global Const $CB_GETCUEBANNER = ($CBM_FIRST + 4)
Global Const $CB_GETCURSEL = 0x147
Global Const $CB_GETDROPPEDCONTROLRECT = 0x152
Global Const $CB_GETDROPPEDSTATE = 0x157
Global Const $CB_GETDROPPEDWIDTH = 0X15f
Global Const $CB_GETEDITSEL = 0x140
Global Const $CB_GETEXTENDEDUI = 0x156
Global Const $CB_GETHORIZONTALEXTENT = 0x15d
Global Const $CB_GETITEMDATA = 0x150
Global Const $CB_GETITEMHEIGHT = 0x154
Global Const $CB_GETLBTEXT = 0x148
Global Const $CB_GETLBTEXTLEN = 0x149
Global Const $CB_GETLOCALE = 0x15A
Global Const $CB_GETMINVISIBLE = 0x1702
Global Const $CB_GETTOPINDEX = 0x15b
Global Const $CB_INITSTORAGE = 0x161
Global Const $CB_LIMITTEXT = 0x141
Global Const $CB_RESETCONTENT = 0x14B
Global Const $CB_INSERTSTRING = 0x14A
Global Const $CB_SELECTSTRING = 0x14D
Global Const $CB_SETCUEBANNER = ($CBM_FIRST + 3)
Global Const $CB_SETCURSEL = 0x14E
Global Const $CB_SETDROPPEDWIDTH = 0x160
Global Const $CB_SETEDITSEL = 0x142
Global Const $CB_SETEXTENDEDUI = 0x155
Global Const $CB_SETHORIZONTALEXTENT = 0x15e
Global Const $CB_SETITEMDATA = 0x151
Global Const $CB_SETITEMHEIGHT = 0x153
Global Const $CB_SETLOCALE = 0x159
Global Const $CB_SETMINVISIBLE = 0x1701
Global Const $CB_SETTOPINDEX = 0x15c
Global Const $CB_SHOWDROPDOWN = 0x14F
Global Const $CBN_CLOSEUP = 8
Global Const $CBN_DBLCLK = 2
Global Const $CBN_DROPDOWN = 7
Global Const $CBN_EDITCHANGE = 5
Global Const $CBN_EDITUPDATE = 6
Global Const $CBN_ERRSPACE = (-1)
Global Const $CBN_KILLFOCUS = 4
Global Const $CBN_SELCHANGE = 1
Global Const $CBN_SELENDCANCEL = 10
Global Const $CBN_SELENDOK = 9
Global Const $CBN_SETFOCUS = 3
Global Const $CBES_EX_CASESENSITIVE = 0x10
Global Const $CBES_EX_NOEDITIMAGE = 0x1
Global Const $CBES_EX_NOEDITIMAGEINDENT = 0x2
Global Const $CBES_EX_NOSIZELIMIT = 0x8
Global Const $__COMBOBOXCONSTANT_WM_USER = 0X400
Global Const $CBEM_DELETEITEM = $CB_DELETESTRING
Global Const $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 6)
Global Const $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 7)
Global Const $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
Global Const $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 3)
Global Const $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 4)
Global Const $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 13)
Global Const $CBEM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 10)
Global Const $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 1)
Global Const $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 11)
Global Const $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 8)
Global Const $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 14)
Global Const $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 2)
Global Const $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 5)
Global Const $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 12)
Global Const $CBEM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $CBEM_SETWINDOWTHEME = 0x2000 + 11
Global Const $CBEN_FIRST = (-800)
Global Const $CBEN_LAST = (-830)
Global Const $CBEN_BEGINEDIT = ($CBEN_FIRST - 4)
Global Const $CBEN_DELETEITEM = ($CBEN_FIRST - 2)
Global Const $CBEN_DRAGBEGINA = ($CBEN_FIRST - 8)
Global Const $CBEN_DRAGBEGINW = ($CBEN_FIRST - 9)
Global Const $CBEN_ENDEDITA = ($CBEN_FIRST - 5)
Global Const $CBEN_ENDEDITW = ($CBEN_FIRST - 6)
Global Const $CBEN_GETDISPINFO = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOA = ($CBEN_FIRST - 0)
Global Const $CBEN_GETDISPINFOW = ($CBEN_FIRST - 7)
Global Const $CBEN_INSERTITEM = ($CBEN_FIRST - 1)
Global Const $CBEIF_DI_SETITEM = 0x10000000
Global Const $CBEIF_IMAGE = 0x2
Global Const $CBEIF_INDENT = 0x10
Global Const $CBEIF_LPARAM = 0x20
Global Const $CBEIF_OVERLAY = 0x8
Global Const $CBEIF_SELECTEDIMAGE = 0x4
Global Const $CBEIF_TEXT = 0x1
Global Const $GUI_SS_DEFAULT_COMBO = 0x00200042
Global Const $DTS_SHORTDATEFORMAT = 0
Global Const $DTS_UPDOWN = 1
Global Const $DTS_SHOWNONE = 2
Global Const $DTS_LONGDATEFORMAT = 4
Global Const $DTS_TIMEFORMAT = 9
Global Const $DTS_RIGHTALIGN = 32
Global Const $DTS_SHORTDATECENTURYFORMAT = 0x0000000C
Global Const $DTS_APPCANPARSE = 0x00000010
Global Const $DMW_LONGNAME = 0
Global Const $DMW_SHORTNAME = 1
Global Const $DMW_LOCALE_LONGNAME = 2
Global Const $DMW_LOCALE_SHORTNAME = 3
Global Const $GDT_ERROR = -1
Global Const $GDT_VALID = 0
Global Const $GDT_NONE = 1
Global Const $GDTR_MIN = 0x0001
Global Const $GDTR_MAX = 0x0002
Global Const $MCHT_NOWHERE = 0x00000000
Global Const $MCHT_TITLE = 0x00010000
Global Const $MCHT_CALENDAR = 0x00020000
Global Const $MCHT_TODAYLINK = 0x00030000
Global Const $MCHT_NEXT = 0x01000000
Global Const $MCHT_PREV = 0x02000000
Global Const $MCHT_TITLEBK = 0x00010000
Global Const $MCHT_TITLEMONTH = 0x00010001
Global Const $MCHT_TITLEYEAR = 0x00010002
Global Const $MCHT_TITLEBTNNEXT = 0x01010003
Global Const $MCHT_TITLEBTNPREV = 0x02010003
Global Const $MCHT_CALENDARBK = 0x00020000
Global Const $MCHT_CALENDARDATE = 0x00020001
Global Const $MCHT_CALENDARDAY = 0x00020002
Global Const $MCHT_CALENDARWEEKNUM = 0x00020003
Global Const $MCHT_CALENDARDATENEXT = 0x01020000
Global Const $MCHT_CALENDARDATEPREV = 0x02020000
Global Const $MCS_DAYSTATE = 0x0001
Global Const $MCS_MULTISELECT = 0x0002
Global Const $MCS_WEEKNUMBERS = 0x0004
Global Const $MCS_NOTODAYCIRCLE = 0x0008
Global Const $MCS_NOTODAY = 0x0010
Global Const $MCS_NOTRAILINGDATES = 0x0040
Global Const $MCS_SHORTDAYSOFWEEK = 0x0080
Global Const $MCS_NOSELCHANGEONNAV = 0x0100
Global Const $MCM_FIRST = 0x1000
Global Const $MCM_GETCALENDARBORDER = ($MCM_FIRST + 31)
Global Const $MCM_GETCALENDARCOUNT = ($MCM_FIRST + 23)
Global Const $MCM_GETCALENDARGRIDINFO = ($MCM_FIRST + 24)
Global Const $MCM_GETCALID = ($MCM_FIRST + 27)
Global Const $MCM_GETCOLOR = ($MCM_FIRST + 11)
Global Const $MCM_GETCURRENTVIEW = ($MCM_FIRST + 22)
Global Const $MCM_GETCURSEL = ($MCM_FIRST + 1)
Global Const $MCM_GETFIRSTDAYOFWEEK = ($MCM_FIRST + 16)
Global Const $MCM_GETMAXSELCOUNT = ($MCM_FIRST + 3)
Global Const $MCM_GETMAXTODAYWIDTH = ($MCM_FIRST + 21)
Global Const $MCM_GETMINREQRECT = ($MCM_FIRST + 9)
Global Const $MCM_GETMONTHDELTA = ($MCM_FIRST + 19)
Global Const $MCM_GETMONTHRANGE = ($MCM_FIRST + 7)
Global Const $MCM_GETRANGE = ($MCM_FIRST + 17)
Global Const $MCM_GETSELRANGE = ($MCM_FIRST + 5)
Global Const $MCM_GETTODAY = ($MCM_FIRST + 13)
Global Const $MCM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $MCM_HITTEST = ($MCM_FIRST + 14)
Global Const $MCM_SETCALENDARBORDER = ($MCM_FIRST + 30)
Global Const $MCM_SETCALID = ($MCM_FIRST + 28)
Global Const $MCM_SETCOLOR = ($MCM_FIRST + 10)
Global Const $MCM_SETCURRENTVIEW = ($MCM_FIRST + 32)
Global Const $MCM_SETCURSEL = ($MCM_FIRST + 2)
Global Const $MCM_SETDAYSTATE = ($MCM_FIRST + 8)
Global Const $MCM_SETFIRSTDAYOFWEEK = ($MCM_FIRST + 15)
Global Const $MCM_SETMAXSELCOUNT = ($MCM_FIRST + 4)
Global Const $MCM_SETMONTHDELTA = ($MCM_FIRST + 20)
Global Const $MCM_SETRANGE = ($MCM_FIRST + 18)
Global Const $MCM_SETSELRANGE = ($MCM_FIRST + 6)
Global Const $MCM_SETTODAY = ($MCM_FIRST + 12)
Global Const $MCM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $MCM_SIZERECTTOMIN = ($MCM_FIRST + 29)
Global Const $MCN_FIRST = -746
Global Const $MCN_SELCHANGE = ($MCN_FIRST - 3)
Global Const $MCN_GETDAYSTATE = ($MCN_FIRST - 1)
Global Const $MCN_SELECT = ($MCN_FIRST)
Global Const $MCN_VIEWCHANGE = ($MCN_FIRST - 4)
Global Const $MCSC_BACKGROUND = 0
Global Const $MCSC_MONTHBK = 4
Global Const $MCSC_TEXT = 1
Global Const $MCSC_TITLEBK = 2
Global Const $MCSC_TITLETEXT = 3
Global Const $MCSC_TRAILINGTEXT = 5
Global Const $DTM_FIRST = 0x1000
Global Const $DTM_GETSYSTEMTIME = $DTM_FIRST + 1
Global Const $DTM_SETSYSTEMTIME = $DTM_FIRST + 2
Global Const $DTM_GETRANGE = $DTM_FIRST + 3
Global Const $DTM_SETRANGE = $DTM_FIRST + 4
Global Const $DTM_SETFORMAT = $DTM_FIRST + 5
Global Const $DTM_SETMCCOLOR = $DTM_FIRST + 6
Global Const $DTM_GETMCCOLOR = $DTM_FIRST + 7
Global Const $DTM_GETMONTHCAL = $DTM_FIRST + 8
Global Const $DTM_SETMCFONT = $DTM_FIRST + 9
Global Const $DTM_GETMCFONT = $DTM_FIRST + 10
Global Const $DTM_SETFORMATW = $DTM_FIRST + 50
Global Const $DTN_FIRST = -740
Global Const $DTN_FIRST2 = -753
Global Const $DTN_DATETIMECHANGE = $DTN_FIRST2 - 6
Global Const $DTN_USERSTRING = $DTN_FIRST2 - 5
Global Const $DTN_WMKEYDOWN = $DTN_FIRST2 - 4
Global Const $DTN_FORMAT = $DTN_FIRST2 - 3
Global Const $DTN_FORMATQUERY = $DTN_FIRST2 - 2
Global Const $DTN_DROPDOWN = $DTN_FIRST2 - 1
Global Const $DTN_CLOSEUP = $DTN_FIRST2 - 0
Global Const $DTN_USERSTRINGW = $DTN_FIRST - 5
Global Const $DTN_WMKEYDOWNW = $DTN_FIRST - 4
Global Const $DTN_FORMATW = $DTN_FIRST - 3
Global Const $DTN_FORMATQUERYW = $DTN_FIRST - 2
Global Const $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
Global Const $GUI_SS_DEFAULT_MONTHCAL = 0
Global Const $LBS_NOTIFY = 0x00000001
Global Const $LBS_SORT = 0x00000002
Global Const $LBS_NOREDRAW = 0x00000004
Global Const $LBS_MULTIPLESEL = 0x00000008
Global Const $LBS_OWNERDRAWFIXED = 0x00000010
Global Const $LBS_OWNERDRAWVARIABLE = 0x00000020
Global Const $LBS_HASSTRINGS = 0x00000040
Global Const $LBS_USETABSTOPS = 0x00000080
Global Const $LBS_NOINTEGRALHEIGHT = 0x00000100
Global Const $LBS_MULTICOLUMN = 0x00000200
Global Const $LBS_WANTKEYBOARDINPUT = 0x00000400
Global Const $LBS_EXTENDEDSEL = 0x00000800
Global Const $LBS_DISABLENOSCROLL = 0x00001000
Global Const $LBS_NODATA = 0x00002000
Global Const $LBS_NOSEL = 0x00004000
Global Const $LBS_COMBOBOX = 0x00008000
Global Const $LBS_STANDARD = 0x00000003
Global Const $GUI_SS_DEFAULT_LIST = 0x00a00003
Global Const $LB_ERR = -1
Global Const $LB_ERRATTRIBUTE = -3
Global Const $LB_ERRREQUIRED = -4
Global Const $LB_ERRSPACE = -2
Global Const $LB_ADDSTRING = 0x0180
Global Const $LB_INSERTSTRING = 0x0181
Global Const $LB_DELETESTRING = 0x0182
Global Const $LB_SELITEMRANGEEX = 0x0183
Global Const $LB_RESETCONTENT = 0x0184
Global Const $LB_SETSEL = 0x0185
Global Const $LB_SETCURSEL = 0x0186
Global Const $LB_GETSEL = 0x0187
Global Const $LB_GETCURSEL = 0x0188
Global Const $LB_GETTEXT = 0x0189
Global Const $LB_GETTEXTLEN = 0x018A
Global Const $LB_GETCOUNT = 0x018B
Global Const $LB_SELECTSTRING = 0x018C
Global Const $LB_DIR = 0x018D
Global Const $LB_GETTOPINDEX = 0x018E
Global Const $LB_FINDSTRING = 0x018F
Global Const $LB_GETSELCOUNT = 0x0190
Global Const $LB_GETSELITEMS = 0x0191
Global Const $LB_SETTABSTOPS = 0x0192
Global Const $LB_GETHORIZONTALEXTENT = 0x0193
Global Const $LB_SETHORIZONTALEXTENT = 0x0194
Global Const $LB_SETCOLUMNWIDTH = 0x0195
Global Const $LB_ADDFILE = 0x0196
Global Const $LB_SETTOPINDEX = 0x0197
Global Const $LB_GETITEMRECT = 0x0198
Global Const $LB_GETITEMDATA = 0x0199
Global Const $LB_SETITEMDATA = 0x019A
Global Const $LB_SELITEMRANGE = 0x019B
Global Const $LB_SETANCHORINDEX = 0x019C
Global Const $LB_GETANCHORINDEX = 0x019D
Global Const $LB_SETCARETINDEX = 0x019E
Global Const $LB_GETCARETINDEX = 0x019F
Global Const $LB_SETITEMHEIGHT = 0x01A0
Global Const $LB_GETITEMHEIGHT = 0x01A1
Global Const $LB_FINDSTRINGEXACT = 0x01A2
Global Const $LB_SETLOCALE = 0x01A5
Global Const $LB_GETLOCALE = 0x01A6
Global Const $LB_SETCOUNT = 0x01A7
Global Const $LB_INITSTORAGE = 0x01A8
Global Const $LB_ITEMFROMPOINT = 0x01A9
Global Const $LB_MULTIPLEADDSTRING = 0x01B1
Global Const $LB_GETLISTBOXINFO = 0x01B2
Global Const $LBN_ERRSPACE = 0xFFFFFFFE
Global Const $LBN_SELCHANGE = 0x00000001
Global Const $LBN_DBLCLK = 0x00000002
Global Const $LBN_SELCANCEL = 0x00000003
Global Const $LBN_SETFOCUS = 0x00000004
Global Const $LBN_KILLFOCUS = 0x00000005
Global Const $LVGS_NORMAL = 0x00000000
Global Const $LVGS_COLLAPSED = 0x00000001
Global Const $LVGS_HIDDEN = 0x00000002
Global Const $LVGS_NOHEADER = 0x00000004
Global Const $LVGS_COLLAPSIBLE = 0x00000008
Global Const $LVGS_FOCUSED = 0x00000010
Global Const $LVGS_SELECTED = 0x00000020
Global Const $LVGS_SUBSETED = 0x00000040
Global Const $LVGS_SUBSETLINKFOCUSED = 0x00000080
Global Const $LVGGR_GROUP = 0
Global Const $LVGGR_HEADER = 1
Global Const $LVGGR_LABEL = 2
Global Const $LVGGR_SUBSETLINK = 3
Global Const $LV_ERR = -1
Global Const $LVBKIF_SOURCE_NONE = 0x00000000
Global Const $LVBKIF_SOURCE_HBITMAP = 0x00000001
Global Const $LVBKIF_SOURCE_URL = 0x00000002
Global Const $LVBKIF_SOURCE_MASK = 0x00000003
Global Const $LVBKIF_STYLE_NORMAL = 0x00000000
Global Const $LVBKIF_STYLE_TILE = 0x00000010
Global Const $LVBKIF_STYLE_MASK = 0x00000010
Global Const $LVBKIF_FLAG_TILEOFFSET = 0x00000100
Global Const $LVBKIF_TYPE_WATERMARK = 0x10000000
Global Const $LV_VIEW_DETAILS = 0x0001
Global Const $LV_VIEW_ICON = 0x0000
Global Const $LV_VIEW_LIST = 0x0003
Global Const $LV_VIEW_SMALLICON = 0x0002
Global Const $LV_VIEW_TILE = 0x0004
Global Const $LVA_ALIGNLEFT = 0x0001
Global Const $LVA_ALIGNTOP = 0x0002
Global Const $LVA_DEFAULT = 0x0000
Global Const $LVA_SNAPTOGRID = 0x0005
Global Const $LVCDI_ITEM = 0x00000000
Global Const $LVCDI_GROUP = 0x00000001
Global Const $LVCF_ALLDATA = 0X0000003F
Global Const $LVCF_FMT = 0x0001
Global Const $LVCF_IMAGE = 0x0010
Global Const $LVCFMT_JUSTIFYMASK = 0x0003
Global Const $LVCF_TEXT = 0x0004
Global Const $LVCF_WIDTH = 0x0002
Global Const $LVCFMT_BITMAP_ON_RIGHT = 0x1000
Global Const $LVCFMT_CENTER = 0x0002
Global Const $LVCFMT_COL_HAS_IMAGES = 0x8000
Global Const $LVCFMT_IMAGE = 0x0800
Global Const $LVCFMT_LEFT = 0x0000
Global Const $LVCFMT_RIGHT = 0x0001
Global Const $LVCFMT_LINE_BREAK = 0x100000
Global Const $LVCFMT_FILL = 0x200000
Global Const $LVCFMT_WRAP = 0x400000
Global Const $LVCFMT_NO_TITLE = 0x800000
Global Const $LVCFMT_TILE_PLACEMENTMASK = BitOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
Global Const $LVFI_NEARESTXY = 0x0040
Global Const $LVFI_PARAM = 0x0001
Global Const $LVFI_PARTIAL = 0x0008
Global Const $LVFI_STRING = 0x0002
Global Const $LVFI_SUBSTRING = 0x0004
Global Const $LVFI_WRAP = 0x0020
Global Const $LVGA_FOOTER_LEFT = 0x00000008
Global Const $LVGA_FOOTER_CENTER = 0x00000010
Global Const $LVGA_FOOTER_RIGHT = 0x00000020
Global Const $LVGA_HEADER_LEFT = 0x00000001
Global Const $LVGA_HEADER_CENTER = 0x00000002
Global Const $LVGA_HEADER_RIGHT = 0x00000004
Global Const $LVGF_ALIGN = 0x00000008
Global Const $LVGF_DESCRIPTIONTOP = 0x00000400
Global Const $LVGF_DESCRIPTIONBOTTOM = 0x00000800
Global Const $LVGF_EXTENDEDIMAGE = 0x00002000
Global Const $LVGF_FOOTER = 0x00000002
Global Const $LVGF_GROUPID = 0x00000010
Global Const $LVGF_HEADER = 0x00000001
Global Const $LVGF_ITEMS = 0x00004000
Global Const $LVGF_NONE = 0x00000000
Global Const $LVGF_STATE = 0x00000004
Global Const $LVGF_SUBSET = 0x00008000
Global Const $LVGF_SUBSETITEMS = 0x00010000
Global Const $LVGF_SUBTITLE = 0x00000100
Global Const $LVGF_TASK = 0x00000200
Global Const $LVGF_TITLEIMAGE = 0x00001000
Global Const $LVHT_ABOVE = 0x00000008
Global Const $LVHT_BELOW = 0x00000010
Global Const $LVHT_NOWHERE = 0x00000001
Global Const $LVHT_ONITEMICON = 0x00000002
Global Const $LVHT_ONITEMLABEL = 0x00000004
Global Const $LVHT_ONITEMSTATEICON = 0x00000008
Global Const $LVHT_TOLEFT = 0x00000040
Global Const $LVHT_TORIGHT = 0x00000020
Global Const $LVHT_ONITEM = BitOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
Global Const $LVHT_EX_GROUP_HEADER = 0x10000000
Global Const $LVHT_EX_GROUP_FOOTER = 0x20000000
Global Const $LVHT_EX_GROUP_COLLAPSE = 0x40000000
Global Const $LVHT_EX_GROUP_BACKGROUND = 0x80000000
Global Const $LVHT_EX_GROUP_STATEICON = 0x01000000
Global Const $LVHT_EX_GROUP_SUBSETLINK = 0x02000000
Global Const $LVHT_EX_GROUP = BitOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
Global Const $LVHT_EX_ONCONTENTS = 0x04000000
Global Const $LVHT_EX_FOOTER = 0x08000000
Global Const $LVIF_COLFMT = 0x00010000
Global Const $LVIF_COLUMNS = 0x00000200
Global Const $LVIF_GROUPID = 0x00000100
Global Const $LVIF_IMAGE = 0x00000002
Global Const $LVIF_INDENT = 0x00000010
Global Const $LVIF_NORECOMPUTE = 0x00000800
Global Const $LVIF_PARAM = 0x00000004
Global Const $LVIF_STATE = 0x00000008
Global Const $LVIF_TEXT = 0x00000001
Global Const $LVIM_AFTER = 0x00000001
Global Const $LVIR_BOUNDS = 0
Global Const $LVIR_ICON = 1
Global Const $LVIR_LABEL = 2
Global Const $LVIR_SELECTBOUNDS = 3
Global Const $LVIS_CUT = 0x0004
Global Const $LVIS_DROPHILITED = 0x0008
Global Const $LVIS_FOCUSED = 0x0001
Global Const $LVIS_OVERLAYMASK = 0x0F00
Global Const $LVIS_SELECTED = 0x0002
Global Const $LVIS_STATEIMAGEMASK = 0xF000
Global Const $LVS_ALIGNLEFT = 0x0800
Global Const $LVS_ALIGNMASK = 0x0c00
Global Const $LVS_ALIGNTOP = 0x0000
Global Const $LVS_AUTOARRANGE = 0x0100
Global Const $LVS_DEFAULT = 0x0000000D
Global Const $LVS_EDITLABELS = 0x0200
Global Const $LVS_ICON = 0x0000
Global Const $LVS_LIST = 0x0003
Global Const $LVS_NOCOLUMNHEADER = 0x4000
Global Const $LVS_NOLABELWRAP = 0x0080
Global Const $LVS_NOSCROLL = 0x2000
Global Const $LVS_NOSORTHEADER = 0x8000
Global Const $LVS_OWNERDATA = 0x1000
Global Const $LVS_OWNERDRAWFIXED = 0x0400
Global Const $LVS_REPORT = 0x0001
Global Const $LVS_SHAREIMAGELISTS = 0x0040
Global Const $LVS_SHOWSELALWAYS = 0x0008
Global Const $LVS_SINGLESEL = 0x0004
Global Const $LVS_SMALLICON = 0x0002
Global Const $LVS_SORTASCENDING = 0x0010
Global Const $LVS_SORTDESCENDING = 0x0020
Global Const $LVS_TYPEMASK = 0x0003
Global Const $LVS_TYPESTYLEMASK = 0xfc00
Global Const $LVS_EX_AUTOAUTOARRANGE = 0x01000000
Global Const $LVS_EX_AUTOCHECKSELECT = 0x08000000
Global Const $LVS_EX_AUTOSIZECOLUMNS = 0x10000000
Global Const $LVS_EX_BORDERSELECT = 0x00008000
Global Const $LVS_EX_CHECKBOXES = 0x00000004
Global Const $LVS_EX_COLUMNOVERFLOW = 0x80000000
Global Const $LVS_EX_COLUMNSNAPPOINTS = 0x40000000
Global Const $LVS_EX_DOUBLEBUFFER = 0x00010000
Global Const $LVS_EX_FLATSB = 0x00000100
Global Const $LVS_EX_FULLROWSELECT = 0x00000020
Global Const $LVS_EX_GRIDLINES = 0x00000001
Global Const $LVS_EX_HEADERDRAGDROP = 0x00000010
Global Const $LVS_EX_HEADERINALLVIEWS = 0x02000000
Global Const $LVS_EX_HIDELABELS = 0x20000
Global Const $LVS_EX_INFOTIP = 0x00000400
Global Const $LVS_EX_JUSTIFYCOLUMNS = 0x00200000
Global Const $LVS_EX_LABELTIP = 0x00004000
Global Const $LVS_EX_MULTIWORKAREAS = 0x00002000
Global Const $LVS_EX_ONECLICKACTIVATE = 0x00000040
Global Const $LVS_EX_REGIONAL = 0x00000200
Global Const $LVS_EX_SIMPLESELECT = 0x00100000
Global Const $LVS_EX_SNAPTOGRID = 0x00080000
Global Const $LVS_EX_SUBITEMIMAGES = 0x00000002
Global Const $LVS_EX_TRACKSELECT = 0x00000008
Global Const $LVS_EX_TRANSPARENTBKGND = 0x00400000
Global Const $LVS_EX_TRANSPARENTSHADOWTEXT = 0x00800000
Global Const $LVS_EX_TWOCLICKACTIVATE = 0x00000080
Global Const $LVS_EX_UNDERLINECOLD = 0x00001000
Global Const $LVS_EX_UNDERLINEHOT = 0x00000800
Global Const $GUI_SS_DEFAULT_LISTVIEW = BitOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
Global Const $LVM_FIRST = 0x1000
Global Const $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 64)
Global Const $LVM_ARRANGE = ($LVM_FIRST + 22)
Global Const $LVM_CANCELEDITLABEL = ($LVM_FIRST + 179)
Global Const $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 33)
Global Const $LVM_DELETEALLITEMS = ($LVM_FIRST + 9)
Global Const $LVM_DELETECOLUMN = ($LVM_FIRST + 28)
Global Const $LVM_DELETEITEM = ($LVM_FIRST + 8)
Global Const $LVM_EDITLABELA = ($LVM_FIRST + 23)
Global Const $LVM_EDITLABELW = ($LVM_FIRST + 118)
Global Const $LVM_EDITLABEL = $LVM_EDITLABELA
Global Const $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 157)
Global Const $LVM_ENSUREVISIBLE = ($LVM_FIRST + 19)
Global Const $LVM_FINDITEM = ($LVM_FIRST + 13)
Global Const $LVM_GETBKCOLOR = ($LVM_FIRST + 0)
Global Const $LVM_GETBKIMAGEA = ($LVM_FIRST + 69)
Global Const $LVM_GETBKIMAGEW = ($LVM_FIRST + 139)
Global Const $LVM_GETCALLBACKMASK = ($LVM_FIRST + 10)
Global Const $LVM_GETCOLUMNA = ($LVM_FIRST + 25)
Global Const $LVM_GETCOLUMNW = ($LVM_FIRST + 95)
Global Const $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 59)
Global Const $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 29)
Global Const $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 40)
Global Const $LVM_GETEDITCONTROL = ($LVM_FIRST + 24)
Global Const $LVM_GETEMPTYTEXT = ($LVM_FIRST + 204)
Global Const $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 55)
Global Const $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 93)
Global Const $LVM_GETFOOTERINFO = ($LVM_FIRST + 206)
Global Const $LVM_GETFOOTERITEM = ($LVM_FIRST + 208)
Global Const $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 207)
Global Const $LVM_GETFOOTERRECT = ($LVM_FIRST + 205)
Global Const $LVM_GETGROUPCOUNT = ($LVM_FIRST + 152)
Global Const $LVM_GETGROUPINFO = ($LVM_FIRST + 149)
Global Const $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 153)
Global Const $LVM_GETGROUPMETRICS = ($LVM_FIRST + 156)
Global Const $LVM_GETGROUPRECT = ($LVM_FIRST + 98)
Global Const $LVM_GETGROUPSTATE = ($LVM_FIRST + 92)
Global Const $LVM_GETHEADER = ($LVM_FIRST + 31)
Global Const $LVM_GETHOTCURSOR = ($LVM_FIRST + 63)
Global Const $LVM_GETHOTITEM = ($LVM_FIRST + 61)
Global Const $LVM_GETHOVERTIME = ($LVM_FIRST + 72)
Global Const $LVM_GETIMAGELIST = ($LVM_FIRST + 2)
Global Const $LVM_GETINSERTMARK = ($LVM_FIRST + 167)
Global Const $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 171)
Global Const $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 169)
Global Const $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 52)
Global Const $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 117)
Global Const $LVM_GETITEMA = ($LVM_FIRST + 5)
Global Const $LVM_GETITEMW = ($LVM_FIRST + 75)
Global Const $LVM_GETITEMCOUNT = ($LVM_FIRST + 4)
Global Const $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 209)
Global Const $LVM_GETITEMPOSITION = ($LVM_FIRST + 16)
Global Const $LVM_GETITEMRECT = ($LVM_FIRST + 14)
Global Const $LVM_GETITEMSPACING = ($LVM_FIRST + 51)
Global Const $LVM_GETITEMSTATE = ($LVM_FIRST + 44)
Global Const $LVM_GETITEMTEXTA = ($LVM_FIRST + 45)
Global Const $LVM_GETITEMTEXTW = ($LVM_FIRST + 115)
Global Const $LVM_GETNEXTITEM = ($LVM_FIRST + 12)
Global Const $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 211)
Global Const $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 73)
Global Const $LVM_GETORIGIN = ($LVM_FIRST + 41)
Global Const $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 176)
Global Const $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 174)
Global Const $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 50)
Global Const $LVM_GETSELECTIONMARK = ($LVM_FIRST + 66)
Global Const $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 17)
Global Const $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 87)
Global Const $LVM_GETSUBITEMRECT = ($LVM_FIRST + 56)
Global Const $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 37)
Global Const $LVM_GETTEXTCOLOR = ($LVM_FIRST + 35)
Global Const $LVM_GETTILEINFO = ($LVM_FIRST + 165)
Global Const $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 163)
Global Const $LVM_GETTOOLTIPS = ($LVM_FIRST + 78)
Global Const $LVM_GETTOPINDEX = ($LVM_FIRST + 39)
Global Const $LVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $LVM_GETVIEW = ($LVM_FIRST + 143)
Global Const $LVM_GETVIEWRECT = ($LVM_FIRST + 34)
Global Const $LVM_GETWORKAREAS = ($LVM_FIRST + 70)
Global Const $LVM_HASGROUP = ($LVM_FIRST + 161)
Global Const $LVM_HITTEST = ($LVM_FIRST + 18)
Global Const $LVM_INSERTCOLUMNA = ($LVM_FIRST + 27)
Global Const $LVM_INSERTCOLUMNW = ($LVM_FIRST + 97)
Global Const $LVM_INSERTGROUP = ($LVM_FIRST + 145)
Global Const $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 159)
Global Const $LVM_INSERTITEMA = ($LVM_FIRST + 7)
Global Const $LVM_INSERTITEMW = ($LVM_FIRST + 77)
Global Const $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 168)
Global Const $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 175)
Global Const $LVM_ISITEMVISIBLE = ($LVM_FIRST + 182)
Global Const $LVM_MAPIDTOINDEX = ($LVM_FIRST + 181)
Global Const $LVM_MAPINDEXTOID = ($LVM_FIRST + 180)
Global Const $LVM_MOVEGROUP = ($LVM_FIRST + 151)
Global Const $LVM_REDRAWITEMS = ($LVM_FIRST + 21)
Global Const $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 160)
Global Const $LVM_REMOVEGROUP = ($LVM_FIRST + 150)
Global Const $LVM_SCROLL = ($LVM_FIRST + 20)
Global Const $LVM_SETBKCOLOR = ($LVM_FIRST + 1)
Global Const $LVM_SETBKIMAGEA = ($LVM_FIRST + 68)
Global Const $LVM_SETBKIMAGEW = ($LVM_FIRST + 138)
Global Const $LVM_SETCALLBACKMASK = ($LVM_FIRST + 11)
Global Const $LVM_SETCOLUMNA = ($LVM_FIRST + 26)
Global Const $LVM_SETCOLUMNW = ($LVM_FIRST + 96)
Global Const $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 58)
Global Const $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 30)
Global Const $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 54)
Global Const $LVM_SETGROUPINFO = ($LVM_FIRST + 147)
Global Const $LVM_SETGROUPMETRICS = ($LVM_FIRST + 155)
Global Const $LVM_SETHOTCURSOR = ($LVM_FIRST + 62)
Global Const $LVM_SETHOTITEM = ($LVM_FIRST + 60)
Global Const $LVM_SETHOVERTIME = ($LVM_FIRST + 71)
Global Const $LVM_SETICONSPACING = ($LVM_FIRST + 53)
Global Const $LVM_SETIMAGELIST = ($LVM_FIRST + 3)
Global Const $LVM_SETINFOTIP = ($LVM_FIRST + 173)
Global Const $LVM_SETINSERTMARK = ($LVM_FIRST + 166)
Global Const $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 170)
Global Const $LVM_SETITEMA = ($LVM_FIRST + 6)
Global Const $LVM_SETITEMW = ($LVM_FIRST + 76)
Global Const $LVM_SETITEMCOUNT = ($LVM_FIRST + 47)
Global Const $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 210)
Global Const $LVM_SETITEMPOSITION = ($LVM_FIRST + 15)
Global Const $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 49)
Global Const $LVM_SETITEMSTATE = ($LVM_FIRST + 43)
Global Const $LVM_SETITEMTEXTA = ($LVM_FIRST + 46)
Global Const $LVM_SETITEMTEXTW = ($LVM_FIRST + 116)
Global Const $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 177)
Global Const $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 140)
Global Const $LVM_SETSELECTIONMARK = ($LVM_FIRST + 67)
Global Const $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 38)
Global Const $LVM_SETTEXTCOLOR = ($LVM_FIRST + 36)
Global Const $LVM_SETTILEINFO = ($LVM_FIRST + 164)
Global Const $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 162)
Global Const $LVM_SETTILEWIDTH = ($LVM_FIRST + 141)
Global Const $LVM_SETTOOLTIPS = ($LVM_FIRST + 74)
Global Const $LVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $LVM_SETVIEW = ($LVM_FIRST + 142)
Global Const $LVM_SETWORKAREAS = ($LVM_FIRST + 65)
Global Const $LVM_SORTGROUPS = ($LVM_FIRST + 158)
Global Const $LVM_SORTITEMS = ($LVM_FIRST + 48)
Global Const $LVM_SORTITEMSEX = ($LVM_FIRST + 81)
Global Const $LVM_SUBITEMHITTEST = ($LVM_FIRST + 57)
Global Const $LVM_UPDATE = ($LVM_FIRST + 42)
Global Const $LVN_FIRST = -100
Global Const $LVN_LAST = -199
Global Const $LVN_BEGINDRAG = ($LVN_FIRST - 9)
Global Const $LVN_BEGINLABELEDITA = ($LVN_FIRST - 5)
Global Const $LVN_BEGINLABELEDITW = ($LVN_FIRST - 75)
Global Const $LVN_BEGINRDRAG = ($LVN_FIRST - 11)
Global Const $LVN_BEGINSCROLL = ($LVN_FIRST - 80)
Global Const $LVN_COLUMNCLICK = ($LVN_FIRST - 8)
Global Const $LVN_COLUMNDROPDOWN = ($LVN_FIRST - 64)
Global Const $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST - 66)
Global Const $LVN_DELETEALLITEMS = ($LVN_FIRST - 4)
Global Const $LVN_DELETEITEM = ($LVN_FIRST - 3)
Global Const $LVN_ENDLABELEDITA = ($LVN_FIRST - 6)
Global Const $LVN_ENDLABELEDITW = ($LVN_FIRST - 76)
Global Const $LVN_ENDSCROLL = ($LVN_FIRST - 81)
Global Const $LVN_GETDISPINFOA = ($LVN_FIRST - 50)
Global Const $LVN_GETDISPINFOW = ($LVN_FIRST - 77)
Global Const $LVN_GETDISPINFO = $LVN_GETDISPINFOA
Global Const $LVN_GETEMPTYMARKUP = ($LVN_FIRST - 87)
Global Const $LVN_GETINFOTIPA = ($LVN_FIRST - 57)
Global Const $LVN_GETINFOTIPW = ($LVN_FIRST - 58)
Global Const $LVN_HOTTRACK = ($LVN_FIRST - 21)
Global Const $LVN_INCREMENTALSEARCHA = ($LVN_FIRST - 62)
Global Const $LVN_INCREMENTALSEARCHW = ($LVN_FIRST - 63)
Global Const $LVN_INSERTITEM = ($LVN_FIRST - 2)
Global Const $LVN_ITEMACTIVATE = ($LVN_FIRST - 14)
Global Const $LVN_ITEMCHANGED = ($LVN_FIRST - 1)
Global Const $LVN_ITEMCHANGING = ($LVN_FIRST - 0)
Global Const $LVN_KEYDOWN = ($LVN_FIRST - 55)
Global Const $LVN_LINKCLICK = ($LVN_FIRST - 84)
Global Const $LVN_MARQUEEBEGIN = ($LVN_FIRST - 56)
Global Const $LVN_ODCACHEHINT = ($LVN_FIRST - 13)
Global Const $LVN_ODFINDITEMA = ($LVN_FIRST - 52)
Global Const $LVN_ODFINDITEMW = ($LVN_FIRST - 79)
Global Const $LVN_ODFINDITEM = $LVN_ODFINDITEMA
Global Const $LVN_ODSTATECHANGED = ($LVN_FIRST - 15)
Global Const $LVN_SETDISPINFOA = ($LVN_FIRST - 51)
Global Const $LVN_SETDISPINFOW = ($LVN_FIRST - 78)
Global Const $LVNI_ABOVE = 0x0100
Global Const $LVNI_BELOW = 0x0200
Global Const $LVNI_TOLEFT = 0x0400
Global Const $LVNI_TORIGHT = 0x0800
Global Const $LVNI_ALL = 0x0000
Global Const $LVNI_CUT = 0x0004
Global Const $LVNI_DROPHILITED = 0x0008
Global Const $LVNI_FOCUSED = 0x0001
Global Const $LVNI_SELECTED = 0x0002
Global Const $LVSCW_AUTOSIZE = -1
Global Const $LVSCW_AUTOSIZE_USEHEADER = -2
Global Const $LVSICF_NOINVALIDATEALL = 0x00000001
Global Const $LVSICF_NOSCROLL = 0x00000002
Global Const $LVSIL_NORMAL = 0
Global Const $LVSIL_SMALL = 1
Global Const $LVSIL_STATE = 2
Global Const $LVFN_DIR_LEFT = 0
Global Const $LVFN_DIR_RIGHT = 1
Global Const $LVFN_DIR_UP = 2
Global Const $LVFN_DIR_DOWN = 3
Global Const $LVFN_DIR_START = 4
Global Const $LVFN_DIR_MEND = 5
Global Const $LVFN_DIR_PRIOR = 6
Global Const $LVFN_DIR_NEXT = 7
Global Const $PBS_MARQUEE = 0x00000008
Global Const $PBS_SMOOTH = 1
Global Const $PBS_SMOOTHREVERSE = 0x10
Global Const $PBS_VERTICAL = 4
Global Const $GUI_SS_DEFAULT_PROGRESS = 0
Global Const $__PROGRESSBARCONSTANT_WM_USER = 0X400
Global Const $PBM_DELTAPOS = $__PROGRESSBARCONSTANT_WM_USER + 3
Global Const $PBM_GETBARCOLOR = 0x040F
Global Const $PBM_GETBKCOLOR = 0x040E
Global Const $PBM_GETPOS = $__PROGRESSBARCONSTANT_WM_USER + 8
Global Const $PBM_GETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 7
Global Const $PBM_GETSTATE = 0x0411
Global Const $PBM_GETSTEP = 0x040D
Global Const $PBM_SETBARCOLOR = $__PROGRESSBARCONSTANT_WM_USER + 9
Global Const $PBM_SETBKCOLOR = 0x2000 + 1
Global Const $PBM_SETMARQUEE = $__PROGRESSBARCONSTANT_WM_USER + 10
Global Const $PBM_SETPOS = $__PROGRESSBARCONSTANT_WM_USER + 2
Global Const $PBM_SETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 1
Global Const $PBM_SETRANGE32 = $__PROGRESSBARCONSTANT_WM_USER + 6
Global Const $PBM_SETSTATE = 0x0410
Global Const $PBM_SETSTEP = $__PROGRESSBARCONSTANT_WM_USER + 4
Global Const $PBM_STEPIT = $__PROGRESSBARCONSTANT_WM_USER + 5
Global Const $__RICHEDITCONSTANT_WM_USER = 0x400
Global Const $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 91
Global Const $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 50
Global Const $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 85
Global Const $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 51
Global Const $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
Global Const $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 53
Global Const $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 54
Global Const $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 55
Global Const $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 56
Global Const $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 79
Global Const $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 124
Global Const $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 123
Global Const $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 76
Global Const $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 57
Global Const $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 92
Global Const $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 201
Global Const $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 58
Global Const $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 205
Global Const $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 59
Global Const $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 105
Global Const $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 122
Global Const $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 127
Global Const $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 107
Global Const $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 121
Global Const $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 78
Global Const $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 61
Global Const $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 101
Global Const $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 87
Global Const $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 221
Global Const $EM_GETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 265
Global Const $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 62
Global Const $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
Global Const $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
Global Const $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 90
Global Const $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 75
Global Const $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 203
Global Const $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 86
Global Const $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 80
Global Const $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 103
Global Const $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 224
Global Const $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
Global Const $EM_INSERTTABLE = $__RICHEDITCONSTANT_WM_USER + 232
Global Const $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 64
Global Const $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 125
Global Const $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 84
Global Const $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 65
Global Const $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 66
Global Const $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 200
Global Const $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 67
Global Const $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
Global Const $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 204
Global Const $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 69
Global Const $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 223
Global Const $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 104
Global Const $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 126
Global Const $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 106
Global Const $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 120
Global Const $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 70
Global Const $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 77
Global Const $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 93
Global Const $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 71
Global Const $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 100
Global Const $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
Global Const $EM_SETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 307
Global Const $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 72
Global Const $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
Global Const $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 89
Global Const $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 202
Global Const $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 82
Global Const $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 81
Global Const $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 102
Global Const $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 225
Global Const $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 96
Global Const $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 88
Global Const $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
Global Const $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 74
Global Const $EN_ALIGNLTR = 0X710
Global Const $EN_ALIGNRTL = 0X711
Global Const $EN_CORRECTTEXT = 0X705
Global Const $EN_DRAGDROPDONE = 0X70c
Global Const $EN_DROPFILES = 0X703
Global Const $EN_IMECHANGE = 0X707
Global Const $EN_LINK = 0X70b
Global Const $EN_MSGFILTER = 0X700
Global Const $EN_OBJECTPOSITIONS = 0X70a
Global Const $EN_OLEOPFAILED = 0X709
Global Const $EN_PROTECTED = 0X704
Global Const $EN_REQUESTRESIZE = 0X701
Global Const $EN_SAVECLIPBOARD = 0X708
Global Const $EN_SELCHANGE = 0X702
Global Const $EN_STOPNOUNDO = 0X706
Global Const $ENM_CHANGE = 0x1
Global Const $ENM_CORRECTTEXT = 0x400000
Global Const $ENM_DRAGDROPDONE = 0x10
Global Const $ENM_DROPFILES = 0x100000
Global Const $ENM_IMECHANGE = 0x800000
Global Const $ENM_KEYEVENTS = 0x10000
Global Const $ENM_LINK = 0x4000000
Global Const $ENM_MOUSEEVENTS = 0x20000
Global Const $ENM_OBJECTPOSITIONS = 0x2000000
Global Const $ENM_PROTECTED = 0x200000
Global Const $ENM_REQUESTRESIZE = 0x40000
Global Const $ENM_SCROLL = 0x4
Global Const $ENM_SCROLLEVENTS = 0x8
Global Const $ENM_SELCHANGE = 0x80000
Global Const $ENM_UPDATE = 0x2
Global Const $BOM_DEFPARADIR = 0x1
Global Const $BOM_PLAINTEXT = 0x2
Global Const $BOM_NEUTRALOVERRIDE = 0x4
Global Const $BOM_CONTEXTREADING = 0x8
Global Const $BOM_CONTEXTALIGNMENT = 0x10
Global Const $BOM_LEGACYBIDICLASS = 0x0040
Global Const $BOE_RTLDIR = 0x1
Global Const $BOE_PLAINTEXT = 0x2
Global Const $BOE_NEUTRALOVERRIDE = 0x4
Global Const $BOE_CONTEXTREADING = 0x8
Global Const $BOE_CONTEXTALIGNMENT = 0x10
Global Const $BOE_LEGACYBIDICLASS = 0x0040
Global Const $ST_DEFAULT = 0
Global Const $ST_KEEPUNDO = 1
Global Const $ST_SELECTION = 2
Global Const $GT_DEFAULT = 0
Global Const $GT_SELECTION = 2
Global Const $GT_USECRLF = 1
Global Const $GTL_CLOSE = 4
Global Const $GTL_DEFAULT = 0
Global Const $GTL_NUMBYTES = 16
Global Const $GTL_NUMCHARS = 8
Global Const $GTL_PRECISE = 2
Global Const $GTL_USECRLF = 1
Global Const $CFU_UNDERLINENONE = 0
Global Const $CFU_UNDERLINE = 1
Global Const $CFU_UNDERLINEWORD = 2
Global Const $CFU_UNDERLINEDOUBLE = 3
Global Const $CFU_UNDERLINEDOTTED = 4
Global Const $CP_ACP = 0
Global Const $CP_UNICODE = 1200
Global Const $CFE_SUBSCRIPT = 0x00010000
Global Const $CFE_SUPERSCRIPT = 0x00020000
Global Const $CFM_ALLCAPS = 0x80
Global Const $CFM_ANIMATION = 0x40000
Global Const $CFM_BACKCOLOR = 0x4000000
Global Const $CFM_BOLD = 0x1
Global Const $CFM_CHARSET = 0x8000000
Global Const $CFM_COLOR = 0x40000000
Global Const $CFM_DISABLED = 0x2000
Global Const $CFM_EMBOSS = 0x800
Global Const $CFM_FACE = 0x20000000
Global Const $CFM_HIDDEN = 0x100
Global Const $CFM_IMPRINT = 0x1000
Global Const $CFM_ITALIC = 0x2
Global Const $CFM_KERNING = 0x100000
Global Const $CFM_LCID = 0x2000000
Global Const $CFM_LINK = 0x20
Global Const $CFM_OFFSET = 0x10000000
Global Const $CFM_OUTLINE = 0x200
Global Const $CFM_PROTECTED = 0x10
Global Const $CFM_REVAUTHOR = 0x8000
Global Const $CFM_REVISED = 0x4000
Global Const $CFM_SHADOW = 0x400
Global Const $CFM_SIZE = 0x80000000
Global Const $CFM_SMALLCAPS = 0x40
Global Const $CFM_SPACING = 0x200000
Global Const $CFM_STRIKEOUT = 0x8
Global Const $CFM_STYLE = 0x80000
Global Const $CFM_SUBSCRIPT = BitOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
Global Const $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
Global Const $CFM_UNDERLINE = 0x4
Global Const $CFM_UNDERLINETYPE = 0x800000
Global Const $CFM_WEIGHT = 0x400000
Global Const $CFE_ALLCAPS = $CFM_ALLCAPS
Global Const $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
Global Const $CFE_AUTOCOLOR = $CFM_COLOR
Global Const $CFE_BOLD = $CFM_BOLD
Global Const $CFE_DISABLED = $CFM_DISABLED
Global Const $CFE_EMBOSS = $CFM_EMBOSS
Global Const $CFE_HIDDEN = $CFM_HIDDEN
Global Const $CFE_IMPRINT = $CFM_IMPRINT
Global Const $CFE_ITALIC = $CFM_ITALIC
Global Const $CFE_LINK = $CFM_LINK
Global Const $CFE_OUTLINE = $CFM_OUTLINE
Global Const $CFE_PROTECTED = $CFM_PROTECTED
Global Const $CFE_REVISED = $CFM_REVISED
Global Const $CFE_SHADOW = $CFM_SHADOW
Global Const $CFE_SMALLCAPS = $CFM_SMALLCAPS
Global Const $CFE_STRIKEOUT = $CFM_STRIKEOUT
Global Const $CFE_UNDERLINE = $CFM_UNDERLINE
Global Const $FR_MATCHALEFHAMZA = 0x80000000
Global Const $FR_MATCHDIAC = 0x20000000
Global Const $FR_MATCHKASHIDA = 0x40000000
Global Const $SCF_DEFAULT = 0x0
Global Const $SCF_SELECTION = 0x1
Global Const $SCF_WORD = 0x2
Global Const $SCF_ALL = 0x4
Global Const $SCF_USEUIRULES = 0x8
Global Const $SCF_ASSOCIATEFONT = 0x10
Global Const $SCF_NOKBUPDATE = 0x20
Global Const $LF_FACESIZE = 32
Global Const $MAX_TAB_STOPS = 32
Global Const $PFA_LEFT = 0x1
Global Const $PFA_RIGHT = 0x2
Global Const $PFA_CENTER = 0x3
Global Const $PFA_JUSTIFY = 4
Global Const $PFA_FULL_INTERWORD = 4
Global Const $PFE_TABLE = 0x4000
Global Const $PFM_NUMBERING = 0x20
Global Const $PFM_ALIGNMENT = 0x8
Global Const $PFM_SPACEBEFORE = 0x40
Global Const $PFM_NUMBERINGSTYLE = 0x2000
Global Const $PFM_NUMBERINGSTART = 0x8000
Global Const $PFM_BORDER = 0x800
Global Const $PFM_RIGHTINDENT = 0x2
Global Const $PFM_STARTINDENT = 0x1
Global Const $PFM_OFFSET = 0x4
Global Const $PFM_LINESPACING = 0x100
Global Const $PFM_SPACEAFTER = 0x80
Global Const $PFM_NUMBERINGTAB = 0x4000
Global Const $PFM_TABLE = 0x40000000
Global Const $PFM_TABSTOPS = 0x10
Global Const $PFN_BULLET = 0x1
Global Const $PFM_RTLPARA = 0x10000
Global Const $PFM_KEEP = 0x20000
Global Const $PFM_KEEPNEXT = 0x40000
Global Const $PFM_PAGEBREAKBEFORE = 0x80000
Global Const $PFM_NOLINENUMBER = 0x100000
Global Const $PFM_NOWIDOWCONTROL = 0x200000
Global Const $PFM_DONOTHYPHEN = 0x400000
Global Const $PFM_SIDEBYSIDE = 0x800000
Global Const $PFE_RTLPARA = 0x00000001
Global Const $PFE_KEEP = 0x00000002
Global Const $PFE_KEEPNEXT = 0x00000004
Global Const $PFE_PAGEBREAKBEFORE = 0x00000008
Global Const $PFE_NOLINENUMBER = 0x00000010
Global Const $PFE_NOWIDOWCONTROL = 0x00000020
Global Const $PFE_DONOTHYPHEN = 0x00000040
Global Const $PFE_SIDEBYSIDE = 0x00000080
Global Const $PFM_SHADING = 0x1000
Global Const $WB_CLASSIFY = 3
Global Const $WB_ISDELIMITER = 2
Global Const $WB_LEFT = 0
Global Const $WB_LEFTBREAK = 6
Global Const $WB_MOVEWORDLEFT = 4
Global Const $WB_MOVEWORDNEXT = 5
Global Const $WB_MOVEWORDPREV = 4
Global Const $WB_MOVEWORDRIGHT = 5
Global Const $WB_NEXTBREAK = 7
Global Const $WB_PREVBREAK = 6
Global Const $WB_RIGHT = 1
Global Const $WB_RIGHTBREAK = 7
Global Const $WBF_ISWHITE = 0x10
Global Const $WBF_BREAKLINE = 0x20
Global Const $WBF_BREAKAFTER = 0x40
Global Const $SF_TEXT = 0x1
Global Const $SF_RTF = 0x2
Global Const $SF_RTFNOOBJS = 0x3
Global Const $SF_TEXTIZED = 0x4
Global Const $SF_UNICODE = 0x0010
Global Const $SF_USECODEPAGE = 0x20
Global Const $SFF_PLAINRTF = 0x4000
Global Const $SFF_SELECTION = 0x8000
Global Const $TBCD_CHANNEL = 0x3
Global Const $TBCD_THUMB = 0x2
Global Const $TBCD_TICS = 0x1
Global Const $__SLIDERCONSTANT_WM_USER = 0x400
Global Const $TBM_CLEARSEL = $__SLIDERCONSTANT_WM_USER + 19
Global Const $TBM_CLEARTICS = $__SLIDERCONSTANT_WM_USER + 9
Global Const $TBM_GETBUDDY = $__SLIDERCONSTANT_WM_USER + 33
Global Const $TBM_GETCHANNELRECT = $__SLIDERCONSTANT_WM_USER + 26
Global Const $TBM_GETLINESIZE = $__SLIDERCONSTANT_WM_USER + 24
Global Const $TBM_GETNUMTICS = $__SLIDERCONSTANT_WM_USER + 16
Global Const $TBM_GETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 22
Global Const $TBM_GETPOS = $__SLIDERCONSTANT_WM_USER
Global Const $TBM_GETPTICS = $__SLIDERCONSTANT_WM_USER + 14
Global Const $TBM_GETSELEND = $__SLIDERCONSTANT_WM_USER + 18
Global Const $TBM_GETSELSTART = $__SLIDERCONSTANT_WM_USER + 17
Global Const $TBM_GETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 2
Global Const $TBM_GETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 1
Global Const $TBM_GETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 28
Global Const $TBM_GETTHUMBRECT = $__SLIDERCONSTANT_WM_USER + 25
Global Const $TBM_GETTIC = $__SLIDERCONSTANT_WM_USER + 3
Global Const $TBM_GETTICPOS = $__SLIDERCONSTANT_WM_USER + 15
Global Const $TBM_GETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 30
Global Const $TBM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TBM_SETBUDDY = $__SLIDERCONSTANT_WM_USER + 32
Global Const $TBM_SETLINESIZE = $__SLIDERCONSTANT_WM_USER + 23
Global Const $TBM_SETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 21
Global Const $TBM_SETPOS = $__SLIDERCONSTANT_WM_USER + 5
Global Const $TBM_SETRANGE = $__SLIDERCONSTANT_WM_USER + 6
Global Const $TBM_SETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 8
Global Const $TBM_SETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 7
Global Const $TBM_SETSEL = $__SLIDERCONSTANT_WM_USER + 10
Global Const $TBM_SETSELEND = $__SLIDERCONSTANT_WM_USER + 12
Global Const $TBM_SETSELSTART = $__SLIDERCONSTANT_WM_USER + 11
Global Const $TBM_SETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 27
Global Const $TBM_SETTIC = $__SLIDERCONSTANT_WM_USER + 4
Global Const $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
Global Const $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
Global Const $TBM_SETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 29
Global Const $TBM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TBTS_BOTTOM = 2
Global Const $TBTS_LEFT = 1
Global Const $TBTS_RIGHT = 3
Global Const $TBTS_TOP = 0
Global Const $TBS_AUTOTICKS = 0x0001
Global Const $TBS_BOTH = 0x0008
Global Const $TBS_BOTTOM = 0x0000
Global Const $TBS_DOWNISLEFT = 0x0400
Global Const $TBS_ENABLESELRANGE = 0x20
Global Const $TBS_FIXEDLENGTH = 0x40
Global Const $TBS_HORZ = 0x0000
Global Const $TBS_LEFT = 0x0004
Global Const $TBS_NOTHUMB = 0x0080
Global Const $TBS_NOTICKS = 0x0010
Global Const $TBS_REVERSED = 0x200
Global Const $TBS_RIGHT = 0x0000
Global Const $TBS_TOP = 0x0004
Global Const $TBS_TOOLTIPS = 0x100
Global Const $TBS_VERT = 0x0002
Global Const $GUI_SS_DEFAULT_SLIDER = $TBS_AUTOTICKS
Global Const $TVS_HASBUTTONS = 0x00000001
Global Const $TVS_HASLINES = 0x00000002
Global Const $TVS_LINESATROOT = 0x00000004
Global Const $TVS_EDITLABELS = 0x00000008
Global Const $TVS_DISABLEDRAGDROP = 0x00000010
Global Const $TVS_SHOWSELALWAYS = 0x00000020
Global Const $TVS_RTLREADING = 0x00000040
Global Const $TVS_NOTOOLTIPS = 0x00000080
Global Const $TVS_CHECKBOXES = 0x00000100
Global Const $TVS_TRACKSELECT = 0x00000200
Global Const $TVS_SINGLEEXPAND = 0x00000400
Global Const $TVS_INFOTIP = 0x00000800
Global Const $TVS_FULLROWSELECT = 0x00001000
Global Const $TVS_NOSCROLL = 0x00002000
Global Const $TVS_NONEVENHEIGHT = 0x00004000
Global Const $TVS_NOHSCROLL = 0x00008000
Global Const $TVS_DEFAULT = 0x00000037
Global Const $GUI_SS_DEFAULT_TREEVIEW = BitOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS)
Global Const $TVE_COLLAPSE = 0x0001
Global Const $TVE_EXPAND = 0x0002
Global Const $TVE_TOGGLE = 0x0003
Global Const $TVE_EXPANDPARTIAL = 0x4000
Global Const $TVE_COLLAPSERESET = 0x8000
Global Const $TVGN_ROOT = 0x00000000
Global Const $TVGN_NEXT = 0x00000001
Global Const $TVGN_PREVIOUS = 0x00000002
Global Const $TVGN_PARENT = 0x00000003
Global Const $TVGN_CHILD = 0x00000004
Global Const $TVGN_FIRSTVISIBLE = 0x00000005
Global Const $TVGN_NEXTVISIBLE = 0x00000006
Global Const $TVGN_PREVIOUSVISIBLE = 0x00000007
Global Const $TVGN_DROPHILITE = 0x00000008
Global Const $TVGN_CARET = 0x00000009
Global Const $TVGN_LASTVISIBLE = 0x0000000A
Global Const $TVHT_NOWHERE = 0x00000001
Global Const $TVHT_ONITEMICON = 0x00000002
Global Const $TVHT_ONITEMLABEL = 0x00000004
Global Const $TVHT_ONITEMINDENT = 0x00000008
Global Const $TVHT_ONITEMBUTTON = 0x00000010
Global Const $TVHT_ONITEMRIGHT = 0x00000020
Global Const $TVHT_ONITEMSTATEICON = 0x00000040
Global Const $TVHT_ONITEM = 0x00000046
Global Const $TVHT_ABOVE = 0x00000100
Global Const $TVHT_BELOW = 0x00000200
Global Const $TVHT_TORIGHT = 0x00000400
Global Const $TVHT_TOLEFT = 0x00000800
Global Const $TVI_ROOT = 0xFFFF0000
Global Const $TVI_FIRST = 0xFFFF0001
Global Const $TVI_LAST = 0xFFFF0002
Global Const $TVI_SORT = 0xFFFF0003
Global Const $TVIF_TEXT = 0x00000001
Global Const $TVIF_IMAGE = 0x00000002
Global Const $TVIF_PARAM = 0x00000004
Global Const $TVIF_STATE = 0x00000008
Global Const $TVIF_HANDLE = 0x00000010
Global Const $TVIF_SELECTEDIMAGE = 0x00000020
Global Const $TVIF_CHILDREN = 0x00000040
Global Const $TVIF_INTEGRAL = 0x00000080
Global Const $TVIF_EXPANDEDIMAGE = 0x00000100
Global Const $TVIF_STATEEX = 0x00000200
Global Const $TVIF_DI_SETITEM = 0x00001000
Global Const $TVSIL_NORMAL = 0
Global Const $TVSIL_STATE = 2
Global Const $TVC_BYKEYBOARD = 0x2
Global Const $TVC_BYMOUSE = 0x1
Global Const $TVC_UNKNOWN = 0x0
Global Const $TVIS_FOCUSED = 0x00000001
Global Const $TVIS_SELECTED = 0x00000002
Global Const $TVIS_CUT = 0x00000004
Global Const $TVIS_DROPHILITED = 0x00000008
Global Const $TVIS_BOLD = 0x00000010
Global Const $TVIS_EXPANDED = 0x00000020
Global Const $TVIS_EXPANDEDONCE = 0x00000040
Global Const $TVIS_EXPANDPARTIAL = 0x00000080
Global Const $TVIS_OVERLAYMASK = 0x00000F00
Global Const $TVIS_STATEIMAGEMASK = 0x0000F000
Global Const $TVIS_USERMASK = 0x0000F000
Global Const $TVIS_UNCHECKED = 4096
Global Const $TVIS_CHECKED = 8192
Global Const $TVNA_ADD = 1
Global Const $TVNA_ADDFIRST = 2
Global Const $TVNA_ADDCHILD = 3
Global Const $TVNA_ADDCHILDFIRST = 4
Global Const $TVNA_INSERT = 5
Global Const $TVTA_ADDFIRST = 1
Global Const $TVTA_ADD = 2
Global Const $TVTA_INSERT = 3
Global Const $TV_FIRST = 0x1100
Global Const $TVM_INSERTITEMA = $TV_FIRST + 0
Global Const $TVM_DELETEITEM = $TV_FIRST + 1
Global Const $TVM_EXPAND = $TV_FIRST + 2
Global Const $TVM_GETITEMRECT = $TV_FIRST + 4
Global Const $TVM_GETCOUNT = $TV_FIRST + 5
Global Const $TVM_GETINDENT = $TV_FIRST + 6
Global Const $TVM_SETINDENT = $TV_FIRST + 7
Global Const $TVM_GETIMAGELIST = $TV_FIRST + 8
Global Const $TVM_SETIMAGELIST = $TV_FIRST + 9
Global Const $TVM_GETNEXTITEM = $TV_FIRST + 10
Global Const $TVM_SELECTITEM = $TV_FIRST + 11
Global Const $TVM_GETITEMA = $TV_FIRST + 12
Global Const $TVM_SETITEMA = $TV_FIRST + 13
Global Const $TVM_EDITLABELA = $TV_FIRST + 14
Global Const $TVM_GETEDITCONTROL = $TV_FIRST + 15
Global Const $TVM_GETVISIBLECOUNT = $TV_FIRST + 16
Global Const $TVM_HITTEST = $TV_FIRST + 17
Global Const $TVM_CREATEDRAGIMAGE = $TV_FIRST + 18
Global Const $TVM_SORTCHILDREN = $TV_FIRST + 19
Global Const $TVM_ENSUREVISIBLE = $TV_FIRST + 20
Global Const $TVM_SORTCHILDRENCB = $TV_FIRST + 21
Global Const $TVM_ENDEDITLABELNOW = $TV_FIRST + 22
Global Const $TVM_GETISEARCHSTRINGA = $TV_FIRST + 23
Global Const $TVM_SETTOOLTIPS = $TV_FIRST + 24
Global Const $TVM_GETTOOLTIPS = $TV_FIRST + 25
Global Const $TVM_SETINSERTMARK = $TV_FIRST + 26
Global Const $TVM_SETITEMHEIGHT = $TV_FIRST + 27
Global Const $TVM_GETITEMHEIGHT = $TV_FIRST + 28
Global Const $TVM_SETBKCOLOR = $TV_FIRST + 29
Global Const $TVM_SETTEXTCOLOR = $TV_FIRST + 30
Global Const $TVM_GETBKCOLOR = $TV_FIRST + 31
Global Const $TVM_GETTEXTCOLOR = $TV_FIRST + 32
Global Const $TVM_SETSCROLLTIME = $TV_FIRST + 33
Global Const $TVM_GETSCROLLTIME = $TV_FIRST + 34
Global Const $TVM_SETINSERTMARKCOLOR = $TV_FIRST + 37
Global Const $TVM_GETINSERTMARKCOLOR = $TV_FIRST + 38
Global Const $TVM_GETITEMSTATE = $TV_FIRST + 39
Global Const $TVM_SETLINECOLOR = $TV_FIRST + 40
Global Const $TVM_GETLINECOLOR = $TV_FIRST + 41
Global Const $TVM_MAPACCIDTOHTREEITEM = $TV_FIRST + 42
Global Const $TVM_MAPHTREEITEMTOACCID = $TV_FIRST + 43
Global Const $TVM_INSERTITEMW = $TV_FIRST + 50
Global Const $TVM_GETITEMW = $TV_FIRST + 62
Global Const $TVM_SETITEMW = $TV_FIRST + 63
Global Const $TVM_GETISEARCHSTRINGW = $TV_FIRST + 64
Global Const $TVM_EDITLABELW = $TV_FIRST + 65
Global Const $TVM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $TVM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $TVN_FIRST = -400
Global Const $TVN_SELCHANGINGA = $TVN_FIRST - 1
Global Const $TVN_SELCHANGEDA = $TVN_FIRST - 2
Global Const $TVN_GETDISPINFOA = $TVN_FIRST - 3
Global Const $TVN_SETDISPINFOA = $TVN_FIRST - 4
Global Const $TVN_ITEMEXPANDINGA = $TVN_FIRST - 5
Global Const $TVN_ITEMEXPANDEDA = $TVN_FIRST - 6
Global Const $TVN_BEGINDRAGA = $TVN_FIRST - 7
Global Const $TVN_BEGINRDRAGA = $TVN_FIRST - 8
Global Const $TVN_DELETEITEMA = $TVN_FIRST - 9
Global Const $TVN_BEGINLABELEDITA = $TVN_FIRST - 10
Global Const $TVN_ENDLABELEDITA = $TVN_FIRST - 11
Global Const $TVN_KEYDOWN = $TVN_FIRST - 12
Global Const $TVN_GETINFOTIPA = $TVN_FIRST - 13
Global Const $TVN_GETINFOTIPW = $TVN_FIRST - 14
Global Const $TVN_SINGLEEXPAND = $TVN_FIRST - 15
Global Const $TVN_ITEMCHANGINGA = $TVN_FIRST - 16
Global Const $TVN_ITEMCHANGINGW = $TVN_FIRST - 17
Global Const $TVN_ITEMCHANGEDA = $TVN_FIRST - 18
Global Const $TVN_ITEMCHANGEDW = $TVN_FIRST - 19
Global Const $TVN_SELCHANGINGW = $TVN_FIRST - 50
Global Const $TVN_SELCHANGEDW = $TVN_FIRST - 51
Global Const $TVN_GETDISPINFOW = $TVN_FIRST - 52
Global Const $TVN_SETDISPINFOW = $TVN_FIRST - 53
Global Const $TVN_ITEMEXPANDINGW = $TVN_FIRST - 54
Global Const $TVN_ITEMEXPANDEDW = $TVN_FIRST - 55
Global Const $TVN_BEGINDRAGW = $TVN_FIRST - 56
Global Const $TVN_BEGINRDRAGW = $TVN_FIRST - 57
Global Const $TVN_DELETEITEMW = $TVN_FIRST - 58
Global Const $TVN_BEGINLABELEDITW = $TVN_FIRST - 59
Global Const $TVN_ENDLABELEDITW = $TVN_FIRST - 60
Global Const $UDS_WRAP = 0x0001
Global Const $UDS_SETBUDDYINT = 0x0002
Global Const $UDS_ALIGNRIGHT = 0x0004
Global Const $UDS_ALIGNLEFT = 0x0008
Global Const $UDS_ARROWKEYS = 0x0020
Global Const $UDS_HORZ = 0x0040
Global Const $UDS_NOTHOUSANDS = 0x0080
Global Const $GUI_SS_DEFAULT_UPDOWN = $UDS_ALIGNLEFT
Global Const $Debug = 1
Global Const $ModuleName = "TrayMenuEx.au3"
Func _LoadImage($imagePathName, $imageType)
If $Debug AND Not FileExists($imagePathName) Then ConsoleWrite($ModuleName &  " ERROR: _LoadImage($imagePathName:=" &  $imagePathName & ", $imageType:="& $imageType &  ") File does not exist" & @LF)
Local $hRet = DllCall("user32.dll", "hwnd", "LoadImage", "hwnd", 0,  "str", $imagePathName,  "int", $imageType,  "int", 0,  "int", 0,  "int", BitOR($LR_LOADFROMFILE, $LR_LOADMAP3DCOLORS))
if $Debug AND $hRet[0] = 0 Then ConsoleWrite($ModuleName &  " ERROR: _LoadImage($imagePathName:=" &  $imagePathName & ", $imageType:="& $imageType &  ") Did not return img handel." & @LF)
$hRet = $hRet[0]
Return $hRet
EndFunc
Func _TrayMenuAddIcon(ByRef $hIcon, $TrayMenuNr, $ParentMenu = 0, $IndexType = 0x00000400 )
dim $pIcoInfo, $hBmp
If _IconGetInfo($hIcon, $pIcoInfo) <> 0 Then
$hBmp = DllStructGetData($pIcoInfo,5)
_TrayMenuAddImage($hBmp, $TrayMenuNr, $ParentMenu, $IndexType)
$pIcoInfo = 0
Else
If $Debug Then ConsoleWrite($ModuleName & " ERROR: In _TrayMenuAddIcon($hIcon:=" & $hIcon &  ", $TrayMenuNr:=" & $TrayMenuNr  & ") Call to _GetIconInfo Trying to use $hIcon as bmp handel" &  @LF)
_TrayMenuAddImage($hIcon, $TrayMenuNr, $ParentMenu, $IndexType)
EndIf
EndFunc
Func _TrayMenuAddImage( ByRef $hBmp, $MenuIndex, $ParentMenu = 0, $IndexType = 0x00000400 )
if $Debug Then ConsoleWrite("_TrayMenuAddIcon( $hBmp:=" & $hBmp & ", $MenuIndex:=" &  $MenuIndex & ", $ParentMenu:=" & $ParentMenu & ", $IndexType:=" & $IndexType &" )" & @LF)
local $ret = DllCall("user32.dll", "int", "SetMenuItemBitmaps", "hwnd", TrayItemGetHandle($ParentMenu),  "int",  $MenuIndex,  "int",  $IndexType,  "hwnd", $hBmp,  "hwnd", $hBmp)
EndFunc
Func _IconExtractFromFile($szIconFile, $iconID)
Local $hIcon = DllStructCreate("int")
Local $result = DllCall("shell32.dll", "hwnd", "ExtractIconEx", "str", $szIconFile, "int", $iconID, "hwnd", 0, "ptr", DllStructGetPtr($hIcon), "int", 1)
$ret = DllStructGetData($hIcon,1)
Return $ret
EndFunc
Func _IconDestroy(ByRef $hIcon)
if IsArray($hIcon) Then
local $i
For $i = 0 to UBound($hIcon) - 1
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetPtr($hIcon[$i]))
Next
else
DllCall("user32.dll", "int", "DestroyIcon", "hwnd", DllStructGetPtr($hIcon))
EndIf
EndFunc
Func _IconGetInfo( ByRef $hIcon, ByRef $structICONINFO)
local $def = "int; dword; dword; ptr; ptr"
$structICONINFO = DllStructCreate($def)
Local $ret = DllCall("user32.dll", "long", "GetIconInfo","ptr", $hIcon, "ptr", DllStructGetPtr($structICONINFO))
if $Debug AND @error <> 0 then ConsoleWrite( $ModuleName & "_IconGetInfo: @ERROR:=" & @error & @CRLF &  "@ERROR:=1 > unable to use the DLL file: user32.dll" & @CRLF &  "@ERROR:=2 > unknown return type"  & @CRLF &  "@ERROR:=3 > function: GetIconInfo not found in user32.dll" & @LF)
return $ret[0]
EndFunc
Func _GetMenuItemID($hMenu, $itemRelativePos)
local $ret = dllcall("", "int", "GetMenuItemID","hwnd", $hMenu, "int", $itemRelativePos)
Return $ret[0]
EndFunc
Global $g_sDTC_Mon_Long_In, $g_sDTC_Mon_Short_In, $g_sDTC_Day_Long_In, $g_sDTC_Day_Short_In
Global $g_sDTC_Mon_Long_Out, $g_sDTC_Mon_Short_Out, $g_sDTC_Day_Long_Out, $g_sDTC_Day_Short_Out
Func _Date_Time_Convert($sIn_Date, $sIn_Mask, $sOut_Mask, $i19_20 = Default)
#region
Local $iCaret_Date = 1, $iCaret_Mask = 1, $sCurr_Char, $iLen, $sCurr_Date
Local $aMask[8][5] = [["y", 0, 1, 0, 1],  ["M", 1, 1, 1, 1],  ["d", 1, 1, 1, 1],  ["H", 0, 1, 0, 0],  ["h", 1, 1, 0, 0],  ["m", 1, 1, 0, 0],  ["s", 1, 1, 0, 0],  ["T", 1, 1, 0, 0]]
Local $aDTC_Data[UBound($aMask)][5]
Local $aMon_Long_In[13] = [12, "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
Local $aMon_Long_Out = $aMon_Long_In
Local $aMon_Short_In[13] = [12, "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
Local $aMon_Short_Out = $aMon_Short_In
Local $aDay_Long_In[8] = [7, "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
Local $aDay_Long_Out = $aDay_Long_In
Local $aDay_Short_In[8] = [7, "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
Local $aDay_Short_Out = $aDay_Short_In
If $g_sDTC_Mon_Long_In Then
$aMon_Long_In = __DTC_Create_Array($g_sDTC_Mon_Long_In)
EndIf
If $g_sDTC_Mon_Short_In Then
$aMon_Short_In = __DTC_Create_Array($g_sDTC_Mon_Short_In, $aMon_Long_In)
EndIf
If $g_sDTC_Day_Long_In Then
$aDay_Long_In = __DTC_Create_Array($g_sDTC_Day_Long_In)
EndIf
If $g_sDTC_Day_Short_In Then
$aDay_Short_In = __DTC_Create_Array($g_sDTC_Day_Short_In, $aDay_Long_In)
EndIf
If $g_sDTC_Mon_Long_Out Then
$aMon_Long_Out = __DTC_Create_Array($g_sDTC_Mon_Long_Out)
EndIf
If $g_sDTC_Mon_Short_Out Then
$aMon_Short_Out = __DTC_Create_Array($g_sDTC_Mon_Short_Out, $aMon_Long_Out)
EndIf
If $g_sDTC_Day_Long_Out Then
$aDay_Long_Out = __DTC_Create_Array($g_sDTC_Day_Long_Out)
EndIf
If $g_sDTC_Day_Short_Out Then
$aDay_Short_Out = __DTC_Create_Array($g_sDTC_Day_Short_Out, $aDay_Long_Out)
EndIf
Switch $i19_20
Case Default
$i19_20 = 50
Case 0 To 99
$i19_20 = Int($i19_20)
Case Else
Return SetError(3, 0, "")
EndSwitch
#endregion
#region
For $iCaret_Mask = 1 To StringLen($sIn_Mask)
$sCurr_Char = StringMid($sIn_Mask, $iCaret_Mask, 1)
$iLen = 0
For $i = 0 To UBound($aMask) - 1
If $sCurr_Char == $aMask[$i][0] Then
While 1
$iLen += 1
If StringMid($sIn_Mask, $iCaret_Mask + $iLen, 1) <> $sCurr_Char Then ExitLoop
WEnd
If Not $aMask[$i][$iLen] Then
Return SetError(4, 1, "")
EndIf
Switch $iLen
Case 1
Switch $sCurr_Char
Case "M", "d", "h", "m", "s"
If StringRegExp(StringMid($sIn_Date, $iCaret_Date + 1, 1), "[0-9]") Then
$sCurr_Date = Number(StringMid($sIn_Date, $iCaret_Date, 2))
$iCaret_Date += 1
Else
$sCurr_Date = Number(StringMid($sIn_Date, $iCaret_Date, 1))
EndIf
Case "T"
$sCurr_Date = StringMid($sIn_Date, $iCaret_Date, 1)
Case "H"
ConsoleWrite("Hit" & @CRLF)
EndSwitch
Case 2
$sCurr_Date = StringMid($sIn_Date, $iCaret_Date, 2)
$iCaret_Date += 1
$iCaret_Mask += 1
Case 3
Switch $sCurr_Char
Case "M"
$sCurr_Date = __DTC_Match_Array($aMon_Short_In, $sIn_Date, $iCaret_Date)
$iCaret_Date += @extended
$iLen = 1
Case "d"
$sCurr_Date = __DTC_Match_Array($aDay_Short_In, $sIn_Date, $iCaret_Date)
$iCaret_Date += @extended
$iLen = 0
EndSwitch
$iCaret_Mask += 2
Case 4
Switch $sCurr_Char
Case "y"
$sCurr_Date = StringMid($sIn_Date, $iCaret_Date, 4)
$iCaret_Date += 3
Case "M"
$sCurr_Date = __DTC_Match_Array($aMon_Long_In, $sIn_Date, $iCaret_Date)
$iCaret_Date += @extended
$iLen = 1
Case "d"
$sCurr_Date = __DTC_Match_Array($aDay_Long_In, $sIn_Date, $iCaret_Date)
$iCaret_Date += @extended
$iLen = 0
EndSwitch
$iCaret_Mask += 3
EndSwitch
$aDTC_Data[$i][$iLen] = $sCurr_Date
ExitLoop
EndIf
Next
$iCaret_Date += 1
Next
#endregion
#region
If $aDTC_Data[0][2] And $aDTC_Data[0][4] Then
Return SetError(1, 0, "")
ElseIf $aDTC_Data[0][4] Then
$aDTC_Data[0][2] = StringRight($aDTC_Data[0][4], 2)
ElseIf $aDTC_Data[0][2] Then
If $aDTC_Data[0][2] > $i19_20 Then
$aDTC_Data[0][4] = "19" & $aDTC_Data[0][2]
Else
$aDTC_Data[0][4] = "20" & $aDTC_Data[0][2]
EndIf
Else
$aDTC_Data[0][2] = "--"
$aDTC_Data[0][4] = "----"
EndIf
If ($aDTC_Data[0][4] < 1000 Or $aDTC_Data[0][4] > 2999) And $aDTC_Data[0][4] <> "----" Then
Return SetError(2, 0, "")
EndIf
If $aDTC_Data[1][1] And $aDTC_Data[1][2] Then
Return SetError(1, 1, "")
EndIf
If $aDTC_Data[1][1] Then
If ($aDTC_Data[1][1] < 1 Or $aDTC_Data[1][1] > 12) Then
Return SetError(2, 1, "")
EndIf
$aDTC_Data[1][2] = StringFormat("%02i", $aDTC_Data[1][1])
$aDTC_Data[1][3] = $aMon_Short_Out[$aDTC_Data[1][1]]
$aDTC_Data[1][4] = $aMon_Long_Out[$aDTC_Data[1][1]]
ElseIf $aDTC_Data[1][2] Then
If ($aDTC_Data[1][2] < 1 Or $aDTC_Data[1][2] > 12) Then
Return SetError(2, 1, "")
EndIf
$aDTC_Data[1][1] = Int($aDTC_Data[1][2])
$aDTC_Data[1][3] = $aMon_Short_Out[$aDTC_Data[1][1]]
$aDTC_Data[1][4] = $aMon_Long_Out[$aDTC_Data[1][1]]
Else
$aDTC_Data[1][1] = "-"
$aDTC_Data[1][2] = "--"
$aDTC_Data[1][3] = "---"
$aDTC_Data[1][4] = "---"
EndIf
If $aDTC_Data[2][1] And $aDTC_Data[2][2] Then
Return SetError(1, 2, "")
EndIf
If $aDTC_Data[2][1] Then
$aDTC_Data[2][2] = StringFormat("%02i", $aDTC_Data[2][1])
ElseIf $aDTC_Data[2][2] Then
$aDTC_Data[2][1] = Int($aDTC_Data[2][2])
Else
$aDTC_Data[2][1] = "-"
$aDTC_Data[2][2] = "--"
EndIf
Local $aDayLimit[13] = [0, 32, 29, 32, 31, 32, 31, 32, 32, 31, 32, 31, 32]
If (Mod($aDTC_Data[0][4], 4) = 0 And Mod($aDTC_Data[0][4], 100) <> 0) Or Mod($aDTC_Data[0][4], 400) = 0 Then
$aDayLimit[2] = 30
EndIf
If $aDTC_Data[2][2] > 0 And $aDTC_Data[2][2] < $aDayLimit[$aDTC_Data[1][1]] Then
Local $i_aFactor = Int((14 - $aDTC_Data[1][2]) / 12)
Local $i_yFactor = $aDTC_Data[0][4] - $i_aFactor
Local $i_mFactor = $aDTC_Data[1][2] + (12 * $i_aFactor) - 2
$aDTC_Data[2][0] = 1 + Mod($aDTC_Data[2][2] + $i_yFactor + Int($i_yFactor / 4) - Int($i_yFactor / 100) +  Int($i_yFactor / 400) + Int((31 * $i_mFactor) / 12), 7)
Else
If $aDTC_Data[2][2] <> "--" Then
Return SetError(2, 2, "")
EndIf
EndIf
$aDTC_Data[2][3] = $aDay_Short_Out[$aDTC_Data[2][0]]
$aDTC_Data[2][4] = $aDay_Long_Out[$aDTC_Data[2][0]]
$aDTC_Data[7][1] = StringUpper($aDTC_Data[7][1])
$aDTC_Data[7][2] = StringUpper($aDTC_Data[7][2])
If $aDTC_Data[7][1] And $aDTC_Data[7][2] Then
Return SetError(1, 7, "")
EndIf
If $aDTC_Data[7][1] Then
$aDTC_Data[7][2] = $aDTC_Data[7][1] & "M"
ElseIf $aDTC_Data[7][2] Then
$aDTC_Data[7][1] = StringLeft($aDTC_Data[7][2], 1)
EndIf
If $aDTC_Data[3][2] Then
$aDTC_Data[4][1] = "12"
$aDTC_Data[4][2] = "12"
$aDTC_Data[7][1] = "A"
$aDTC_Data[7][2] = "AM"
Switch $aDTC_Data[3][2]
Case 0
Case 1 To 11
$aDTC_Data[4][1] = Int($aDTC_Data[3][2])
$aDTC_Data[4][2] = $aDTC_Data[3][2]
Case 12
$aDTC_Data[7][1] = "P"
$aDTC_Data[7][2] = "PM"
Case Else
$aDTC_Data[4][1] = Int($aDTC_Data[3][2] - 12)
$aDTC_Data[4][2] = StringFormat("%02i", $aDTC_Data[3][2] - 12)
$aDTC_Data[7][1] = "P"
$aDTC_Data[7][2] = "PM"
EndSwitch
Else
If $aDTC_Data[4][1] And $aDTC_Data[4][2] Then
Return SetError(1, 4, "")
EndIf
If ($aDTC_Data[4][1] Or $aDTC_Data[4][2]) And $aDTC_Data[7][1] & $aDTC_Data[7][2] = "" Then
Return SetError(1, 8, "")
EndIf
If $aDTC_Data[4][1] & $aDTC_Data[4][2] = "" Then
$aDTC_Data[4][1] = "*"
$aDTC_Data[4][2] = "**"
ElseIf $aDTC_Data[4][1] Then
$aDTC_Data[4][2] = StringFormat("%02i", $aDTC_Data[4][1])
ElseIf $aDTC_Data[4][2] Then
$aDTC_Data[4][1] = Int($aDTC_Data[4][2])
EndIf
If $aDTC_Data[7][1] = "P" Then
Switch $aDTC_Data[4][1]
Case 12
$aDTC_Data[3][2] = "12"
Case Else
$aDTC_Data[3][2] = StringFormat("%02i", $aDTC_Data[4][1] + 12)
EndSwitch
Else
Switch $aDTC_Data[4][1]
Case 12
$aDTC_Data[3][2] = "00"
Case Else
$aDTC_Data[3][2] = StringFormat("%02i", $aDTC_Data[4][1])
EndSwitch
EndIf
EndIf
If $aDTC_Data[3][2] < 0 Or $aDTC_Data[3][2] > 23 Then
Return SetError(2, 3, "")
EndIf
If $aDTC_Data[5][1] And $aDTC_Data[5][2] Then
Return SetError(1, 5, "")
EndIf
If $aDTC_Data[5][1] & $aDTC_Data[5][2] = "" Then
$aDTC_Data[5][1] = "*"
$aDTC_Data[5][2] = "**"
ElseIf $aDTC_Data[5][1] Then
$aDTC_Data[5][2] = StringFormat("%02i", $aDTC_Data[5][1])
ElseIf $aDTC_Data[5][2] Then
$aDTC_Data[5][1] = Int($aDTC_Data[5][2])
EndIf
If $aDTC_Data[5][1] < 0 Or $aDTC_Data[5][1] > 59 Then
Return SetError(2, 4, "")
EndIf
If $aDTC_Data[6][1] And $aDTC_Data[6][2] Then
Return SetError(1, 6, "")
EndIf
If $aDTC_Data[6][1] & $aDTC_Data[6][2] = "" Then
$aDTC_Data[6][1] = "*"
$aDTC_Data[6][2] = "**"
ElseIf $aDTC_Data[6][1] Then
$aDTC_Data[6][2] = StringFormat("%02i", $aDTC_Data[6][1])
ElseIf $aDTC_Data[6][2] Then
$aDTC_Data[6][1] = Int($aDTC_Data[6][2])
EndIf
If $aDTC_Data[6][1] < 0 Or $aDTC_Data[6][1] > 59 Then
Return SetError(2, 5, "")
EndIf
#endregion
#region
Local $sOut_Date = ""
$iCaret_Mask = 1
For $iCaret_Mask = 1 To StringLen($sOut_Mask)
$sCurr_Char = StringMid($sOut_Mask, $iCaret_Mask, 1)
$iLen = 0
For $i = 0 To UBound($aMask) - 1
If $sCurr_Char == $aMask[$i][0] Then
While 1
$iLen += 1
If StringMid($sOut_Mask, $iCaret_Mask + $iLen, 1) <> $sCurr_Char Then ExitLoop
WEnd
If Not $aMask[$i][$iLen] Then
Return SetError(4, 2, "")
EndIf
$sOut_Date &= $aDTC_Data[$i][$iLen]
$iCaret_Mask += $iLen - 1
ExitLoop
EndIf
Next
If $iLen = 0 Then
$sOut_Date &= $sCurr_Char
EndIf
Next
Return $sOut_Date
#endregion
EndFunc
Func _Date_Time_Convert_Set($sType = "", $sData = "")
Switch $sType
Case "MLI", "MIL", "LMI", "LIM", "ILM", "IML"
StringReplace($sData, ",", ",")
If @extended <> 11 Then
Return SetError(1, 1, 0)
EndIf
$g_sDTC_Mon_Long_In = $sData
Case "MSI", "MIS", "SMI", "SIM", "ISM", "IMS"
If Not IsInt($sData) Then
StringReplace($sData, ",", ",")
If @extended <> 11 Then
Return SetError(1, 2, 0)
EndIf
EndIf
$g_sDTC_Mon_Short_In = $sData
Case "DLI", "DIL", "LDI", "LID", "ILD", "IDL"
StringReplace($sData, ",", ",")
If @extended <> 6 Then
Return SetError(1, 3, 0)
EndIf
$g_sDTC_Day_Long_In = $sData
Case "DSI", "DIS", "SDI", "SID", "ISD", "IDS"
If Not IsInt($sData) Then
StringReplace($sData, ",", ",")
If @extended <> 6 Then
Return SetError(1, 4, 0)
EndIf
EndIf
$g_sDTC_Day_Long_In = $sData
Case "MLO", "MOL", "LMO", "LOM", "OLM", "OML"
StringReplace($sData, ",", ",")
If @extended <> 11 Then
Return SetError(1, 5, 0)
EndIf
$g_sDTC_Mon_Long_Out = $sData
Case "MSO", "MOS", "SMO", "SOM", "OSM", "OMS"
If Not IsInt($sData) Then
StringReplace($sData, ",", ",")
If @extended <> 11 Then
Return SetError(1, 6, 0)
EndIf
EndIf
$g_sDTC_Mon_Short_Out = $sData
Case "DLO", "DOL", "LDO", "LOD", "OLD", "ODL"
StringReplace($sData, ",", ",")
If @extended <> 6 Then
Return SetError(1, 7, 0)
EndIf
$g_sDTC_Day_Long_Out = $sData
Case "DSO", "DOS", "SDO", "SOD", "OSD", "ODS"
If Not IsInt($sData) Then
StringReplace($sData, ",", ",")
If @extended <> 6 Then
Return SetError(1, 8, 0)
EndIf
EndIf
$g_sDTC_Day_Short_Out = $sData
Case Else
$g_sDTC_Mon_Long_In = ""
$g_sDTC_Mon_Short_In = ""
$g_sDTC_Day_Long_In = ""
$g_sDTC_Day_Short_In = ""
$g_sDTC_Mon_Long_Out = ""
$g_sDTC_Mon_Short_Out = ""
$g_sDTC_Day_Long_Out = ""
$g_sDTC_Day_Short_Out = ""
EndSwitch
Return 1
EndFunc
Func __DTC_Create_Array($sString, $aArray = "")
If IsNumber($sString) Then
Local $iBound = UBound($aArray) - 1
Local $aRet[$iBound + 1] = [$iBound]
For $i = 1 To $iBound
$aRet[$i] = StringLeft($aArray[$i], $sString)
Next
Return $aRet
Else
Return StringSplit($sString, ",")
EndIf
EndFunc
Func __DTC_Match_Array($aArray, $sString, $iIndex)
Local $sItem, $iLen
For $i = 1 To $aArray[0]
$sItem = StringUpper($aArray[$i])
$iLen = StringLen($sItem)
If $sItem == StringUpper(StringMid($sString, $iIndex, $iLen)) Then
Return SetExtended($iLen - 1, $i)
EndIf
Next
Return SetExtended(0, "")
EndFunc
Func _URLEncode($toEncode, $encodeType = 0)
Local $strHex = "", $iDec
Local $aryChar = StringSplit($toEncode, "")
If $encodeType = 1 Then
For $i = 1 To $aryChar[0]
$strHex = $strHex & "%" & Hex(Asc($aryChar[$i]), 2)
Next
Return $strHex
ElseIf $encodeType = 0 Then
For $i = 1 To $aryChar[0]
$iDec = Asc($aryChar[$i])
if $iDec <= 32 Or $iDec = 37 Then
$strHex = $strHex & "%" & Hex($iDec, 2)
Else
$strHex = $strHex & $aryChar[$i]
EndIf
Next
Return $strHex
ElseIf $encodeType = 2 Then
For $i = 1 To $aryChar[0]
If Not StringInStr("$-_.+!*'(),;/?:@=&abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890", $aryChar[$i]) Then
$strHex = $strHex & "%" & Hex(Asc($aryChar[$i]), 2)
Else
$strHex = $strHex & $aryChar[$i]
EndIf
Next
Return $strHex
EndIf
EndFunc
Func _URLDecode($toDecode)
local $strChar = "", $iOne, $iTwo
Local $aryHex = StringSplit($toDecode, "")
For $i = 1 to $aryHex[0]
If $aryHex[$i] = "%" Then
$i = $i + 1
$iOne = $aryHex[$i]
$i = $i + 1
$iTwo = $aryHex[$i]
$strChar = $strChar & Chr(Dec($iOne & $iTwo))
Else
$strChar = $strChar & $aryHex[$i]
EndIf
Next
Return StringReplace($strChar, "+", " ")
EndFunc
opt("MustDeclareVars", 1)
If AlreadyRunning() Then
MsgBox(48,"Stash Helper is still running.","Stash Helper is still running. Maybe it had an error and froze. " & @CRLF & "You can use the 'task manager' to close it." & @CRLF & "I don't recommend running two Stash Helper at the same time.",0)
Exit
EndIf
DllCall("User32.dll","bool","SetProcessDPIAware")
Global Const $currentVersion = "v2.1.6"
Global Enum $ITEM_HANDLE, $ITEM_TITLE, $ITEM_LINK
Global Const $iMaxSubItems = 20
Global $iMediaPlayerPID = 0
Global Enum $LIST_TITLE, $LIST_DURATION, $LIST_FILE
Global $aPlayList[0][3]
TraySetIcon("helper2.ico")
#Region Globals Initialization
Opt("TrayAutoPause", 0)
Global $sProgramFilesDir = ( @OSArch = "X64" ) ? StringReplace(@ProgramFilesDir, " (x86)", "", 1, 2) : @ProgramFilesDir
Global $stashFilePath = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "StashFilePath")
Global $stashPath = stringleft($stashFilePath, StringInStr($stashFilePath, "\", 2, -1))
If @error Or Not FileExists($stashFilePath) Then
InitialSettingsForm()
EndIf
Global $sFileConfig = stringleft( $stashFilePath, stringinstr($stashFilePath, "\", 2, -1) ) & "config.yml"
Global $sNoBrowser = ""
If FileExists($sFileConfig) Then
Local $sConfigContent = FileRead($sFileConfig)
If StringInStr($sConfigContent, "autostart_video:", 2) <> 0 Then
$sNoBrowser = " --nobrowser"
EndIf
EndIf
Global $stashBrowser = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "Browser")
Global $showStashConsole = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "ShowStashConsole")
If @error Then $showStashConsole = 0
Global $showWDConsole = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "ShowWDConsole")
if @error Then $showWDConsole = 0
Global $sDesiredCapabilities, $sSession
Global $stashVersion, $stashURL
Global $sMediaPlayerLocation = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "MediaPlayerLocation")
Global $iSlideShowSeconds = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "SlideShowSeconds")
if @error Then
$iSlideShowSeconds = 10
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "SlideShowSeconds", "REG_DWORD", 10)
EndIf
Local $sIconPath = @ScriptDir & "\images\icons\"
Local $hIcons[20]
For $i = 0 to 19
$hIcons[$i] = _LoadImage($sIconPath & $i & ".bmp", $IMAGE_BITMAP)
Next
Global $mInfo = ObjCreate("Scripting.Dictionary")
If @error Then MsgExit("Error Creating global $minfo object.")
Func ShowSettings()
Local $sBrowser, $bBrowserChanged = False
Local $guiSettings = GUICreate("Settings",800,940,-1,-1,-1,-1)
GUISetIcon("helper2.ico")
TraySetClick(0)
GUICtrlCreateLabel("Boss Coming Key: Ctrl + Enter"&@crlf&"Hit this key combination will immediately close the Stash browser.",100,40,566,96,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
GUICtrlCreateGroup("Preferred Browser",97,136,444,205,$BS_CENTER,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlCreateLabel("Drivers",407,157,83,24,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
Local $radioChooseFirefox = GUICtrlCreateRadio("Firefox",166,187,147,38,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
Local $btnUpdateFirefox = GUICtrlCreateButton("Update",387,195,112,32,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Update this web driver only when Firefox is not under control any more.")
Local $radioChooseChrome = GUICtrlCreateRadio("Chrome",166,237,147,38,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
Local $btnUpdateChrome = GUICtrlCreateButton("Update",387,245,112,32,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Update this web driver only when Chrome is not under control any more.")
Local $radioChooseEdge = GUICtrlCreateRadio("MS Edge",166,287,147,38,$BS_AUTORADIOBUTTON,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
Local $btnUpdateEdge = GUICtrlCreateButton("Update",387,293,112,32,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Update this web driver only when MS Edge is not under control any more.")
GUICtrlCreateLabel("Image Slideshow",407,749,180,30,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
Local $inputSlideShow = GUICtrlCreateInput(string($iSlideShowSeconds),592,747,60,32,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlCreateLabel("seconds",668,747,83,30,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
Switch $stashBrowser
Case "Firefox"
GUICtrlSetState($radioChooseFirefox, $GUI_CHECKED)
Case "Chrome"
GUICtrlSetState($radioChooseChrome, $GUI_CHECKED)
Case "Edge"
GUICtrlSetState($radioChooseEdge, $GUI_CHECKED)
EndSwitch
Local $chkShowStash = GUICtrlCreateCheckbox("Show Stash Console",168,353,258,34,-1,-1)
If $showStashConsole = 1 Then GUICtrlSetState($chkShowStash, $GUI_CHECKED)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Show the stash console when running Stash helper. Can be helpful to trouble-shoot problems.")
Local $chkShowWebDriver = GUICtrlCreateCheckbox("Show Web Driver Console",168,394,304,34,-1,-1)
If $showWDConsole = 1 Then GUICtrlSetState($chkShowWebDriver, $GUI_CHECKED)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Show the web driver console when running Stash helper. Can be helpful to trouble-shoot problems.")
GUICtrlCreateLabel("Stash-win.exe location:",66,436,299,37,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
Local $inputStashWinLocation = GUICtrlCreateInput($stashFilePath,66,487,473,36,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
Local $btnBrowseStash = GUICtrlCreateButton("Browse",566,481,142,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlCreateLabel("Stash URL:",68,531,299,37,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
Local $inputStashURL = GUICtrlCreateInput($stashURL,68,572,473,36,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Default is 'http://localhost:9999/'")
GUICtrlCreateLabel("Alternative player location:",68,630,407,37,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Palatino Linotype")
GUICtrlSetBkColor(-1,"-2")
Local $inputMediaPlayerLocation = GUICtrlCreateInput($sMediaPlayerLocation,68,681,473,36,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Use an alternative media player like VLC, potplayer...etc to player the scene file.")
Local $btnBrowsePlayer = GUICtrlCreateButton("Browse",566,675,142,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Browse for the .exe file for the media player.")
GUICtrlCreateLabel("Player Presets:",68,749,162,30,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
Local $btnPlayerPot = GUICtrlCreateButton("PotPlayer",74,795,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"PotPlayer from potplayer.daum.net")
Local $btnPlayerVLC = GUICtrlCreateButton("VLC",207,795,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"VLC Media Player by VideoLAN")
Local $btnPlayerMPC = GUICtrlCreateButton("MPC",340,795,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Media Player Classic from  mpc-hc.org")
Local $btnPlayerGOM = GUICtrlCreateButton("GOM",74,842,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"GOM Player from player.gomlab.com")
Local $btnPlayerKodi = GUICtrlCreateButton("Kodi",207,842,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"Kodi from XBMC Foundation")
Local $btnPlayerKMP = GUICtrlCreateButton("KMP",340,842,133,40,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetTip(-1,"K-Multimedia Player from Pandora TV.")
Local $chk64Bit = GUICtrlCreateCheckbox("64 Bit",288,749,99,38,-1,-1)
If @OSArch = "X64" Then
GUICtrlSetState(-1,BitOr($GUI_SHOW,$GUI_ENABLE, $GUI_CHECKED))
Else
GUICtrlSetState(-1,BitOr($GUI_SHOW,$GUI_ENABLE))
EndIf
GUICtrlSetFont(-1,10,400,0,"Tahoma")
Local $btnDone = GUICtrlCreateButton("Done",541,819,173,63,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUISetState(@SW_SHOW, $guiSettings)
While True
Sleep(10)
Local $nTrayMsg = TrayGetMsg()
Switch $nTrayMsg
Case $TRAY_EVENT_PRIMARYDOWN, $TRAY_EVENT_SECONDARYDOWN
WinActivate($guiSettings)
EndSwitch
Local $nMsg = GUIGetMsg()
Switch $nMsg
Case $btnBrowseStash
Local $sFile = FileOpenDialog("Open the Stash-Win.exe:",  @DocumentsCommonDir, "(Stash-Win.exe)", $FD_FILEMUSTEXIST )
If Not @error Then
GUICtrlSetData($inputStashWinLocation, $sFile)
EndIf
Case $btnBrowsePlayer
Local $sFile = FileOpenDialog("Open the media player's .exe file:",  $sProgramFilesDir, "Executable File(*.exe)", $FD_FILEMUSTEXIST )
If Not @error Then
GUICtrlSetData($inputMediaPlayerLocation, $sFile)
EndIf
Case $btnDone
$sMediaPlayerLocation = GUICtrlRead($inputMediaPlayerLocation)
If $sMediaPlayerLocation <> "" Then
If Not FileExists($sMediaPlayerLocation) Then
MsgBox(48,"Media Player not exist.","The media player location is not correct.",0)
ExitLoop
EndIf
EndIf
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "MediaPlayerLocation", "REG_SZ", $sMediaPlayerLocation)
$iSlideShowSeconds = Floor(GUICtrlRead($inputSlideShow))
If $iSlideShowSeconds > 0 Then
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper","SlideShowSeconds", "REG_DWORD", $iSlideShowSeconds)
Else
$iSlideShowSeconds = 10
EndIf
Select
Case GUICtrlRead($radioChooseFirefox) = $GUI_CHECKED
$sBrowser = "Firefox"
Case GUICtrlRead($radioChooseChrome) = $GUI_CHECKED
$sBrowser = "Chrome"
Case GUICtrlRead($radioChooseEdge) = $GUI_CHECKED
$sBrowser = "Edge"
EndSelect
If $sBrowser <> $stashBrowser Then $bBrowserChanged = True
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "StashFilePath", "REG_SZ",  GUICtrlRead($inputStashWinLocation))
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "Browser", "REG_SZ", $sBrowser)
Local $iShow = (GUICtrlRead($chkShowStash) = $GUI_CHECKED) ? 1 : 0
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "ShowStashConsole", "REG_DWORD", $iShow)
$iShow = (GUICtrlRead($chkShowWebDriver) = $GUI_CHECKED) ? 1 : 0
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "ShowWDConsole", "REG_DWORD", $iShow)
$stashURL = GUICtrlRead($inputStashURL)
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "StashURL", "REG_SZ", $stashURL)
Local $sMessage =  $bBrowserChanged ? "You need to restart the program for the new settings to take effect, though." : "Settings are in effect now."
MsgBox(64,"Setting saved.", $sMessage,0)
ExitLoop
Case $btnUpdateFirefox
If $stashBrowser = "Firefox" Then
_WD_DeleteSession($sSession)
_WD_Shutdown()
EndIf
Local $b64 = ( @OSArch = "X64" )
Local $bGood = _WD_UPdateDriver ("firefox", @AppDataDir & "\Webdriver" , $b64, True)
If Not $bGood Then
MsgBox(48,"Error Getting Firefox Driver",  "There is an error getting the driver for Firefox. Maybe your Internet is down?"  & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Else
MsgBox(64,"Firefox Updated","Firefox webdriver just updated to the latest version.",0)
EndIf
If $stashBrowser = "Firefox" Then
SetupFirefox()
_WD_Startup()
$sSession = _WD_CreateSession($sDesiredCapabilities)
OpenURL($stashURL)
EndIf
Case $btnUpdateChrome
If $stashBrowser = "Chrome" Then
_WD_DeleteSession($sSession)
_WD_Shutdown()
EndIf
Local $bGood = _WD_UPdateDriver ("chrome", @AppDataDir & "\Webdriver" , Default, True)
If Not $bGood Then
MsgBox(48,"Error Getting Chrome Driver",  "There is an error getting the driver for Chrome. Maybe your Internet is down?"  & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Else
MsgBox(64,"Chrome Updated","Chrome webdriver just updated to the latest version.",0)
EndIf
If $stashBrowser = "Chrome" Then
SetupChrome()
_WD_Startup()
$sSession = _WD_CreateSession($sDesiredCapabilities)
OpenURL($stashURL)
EndIf
Case $btnUpdateEdge
If $stashBrowser = "Edge" Then
_WD_DeleteSession($sSession)
_WD_Shutdown()
EndIf
Local $b64 = ( @OSArch = "X64" )
Local $bGood = _WD_UPdateDriver ("msedge", @AppDataDir & "\Webdriver" , $b64 , True)
If Not $bGood Then
MsgBox(48,"Error Getting ms edge Driver",  "There is an error getting the driver for MS Edge. Maybe your Internet is down?"  & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Else
MsgBox(64,"MS Edge Updated","MS Edge webdriver just updated to the latest version.",0)
EndIf
If $stashBrowser = "Edge" Then
SetupEdge()
_WD_Startup()
$sSession = _WD_CreateSession($sDesiredCapabilities)
OpenURL($stashURL)
EndIf
Case $btnPlayerPot
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\DAUM\PotPlayer\PotPlayerMini64.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\DAUM\PotPlayer\PotPlayerMini64.exe")
EndIf
Case $btnPlayerVLC
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\VideoLAN\VLC\vlc.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\VideoLAN\VLC\vlc.exe")
EndIf
Case $btnPlayerMPC
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\MPC-HC\mplayerc.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\MPC-HC\mplayerc.exe")
EndIf
Case $btnPlayerGOM
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\GRETECH\GOMPlayer\GOM.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\GRETECH\GOMPlayer\GOM.exe")
EndIf
Case $btnPlayerKodi
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\Kodi\Kodi.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\Kodi\Kodi.exe")
EndIf
Case $btnPlayerKMP
If GUICtrlRead($chk64Bit) = $GUI_CHECKED Then
GUICtrlSetData($inputMediaPlayerLocation, $sProgramFilesDir & "\the kmplayer\kmplayer.exe")
Else
GUICtrlSetData($inputMediaPlayerLocation, @ProgramFilesDir & "\the kmplayer\kmplayer.exe")
EndIf
Case $GUI_EVENT_CLOSE
ExitLoop
EndSwitch
Wend
GUIDelete($guiSettings)
TraySetClick(9)
EndFunc
Global Const $HDF_LEFT = 0x00000000
Global Const $HDF_RIGHT = 0x00000001
Global Const $HDF_CENTER = 0x00000002
Global Const $HDF_JUSTIFYMASK = 0x00000003
Global Const $HDF_BITMAP_ON_RIGHT = 0x00001000
Global Const $HDF_BITMAP = 0x00002000
Global Const $HDF_STRING = 0x00004000
Global Const $HDF_OWNERDRAW = 0x00008000
Global Const $HDF_DISPLAYMASK = 0x0000F000
Global Const $HDF_RTLREADING = 0x00000004
Global Const $HDF_SORTDOWN = 0x00000200
Global Const $HDF_IMAGE = 0x00000800
Global Const $HDF_SORTUP = 0x00000400
Global Const $HDF_FLAGMASK = 0x00000E04
Global Const $HDI_WIDTH = 0x00000001
Global Const $HDI_TEXT = 0x00000002
Global Const $HDI_FORMAT = 0x00000004
Global Const $HDI_PARAM = 0x00000008
Global Const $HDI_BITMAP = 0x00000010
Global Const $HDI_IMAGE = 0x00000020
Global Const $HDI_DI_SETITEM = 0x00000040
Global Const $HDI_ORDER = 0x00000080
Global Const $HDI_FILTER = 0x00000100
Global Const $HHT_NOWHERE = 0x00000001
Global Const $HHT_ONHEADER = 0x00000002
Global Const $HHT_ONDIVIDER = 0x00000004
Global Const $HHT_ONDIVOPEN = 0x00000008
Global Const $HHT_ONFILTER = 0x00000010
Global Const $HHT_ONFILTERBUTTON = 0x00000020
Global Const $HHT_ABOVE = 0x00000100
Global Const $HHT_BELOW = 0x00000200
Global Const $HHT_TORIGHT = 0x00000400
Global Const $HHT_TOLEFT = 0x00000800
Global Const $HDM_FIRST = 0x1200
Global Const $HDM_CLEARFILTER = $HDM_FIRST + 24
Global Const $HDM_CREATEDRAGIMAGE = $HDM_FIRST + 16
Global Const $HDM_DELETEITEM = $HDM_FIRST + 2
Global Const $HDM_EDITFILTER = $HDM_FIRST + 23
Global Const $HDM_GETBITMAPMARGIN = $HDM_FIRST + 21
Global Const $HDM_GETFOCUSEDITEM = $HDM_FIRST + 27
Global Const $HDM_GETIMAGELIST = $HDM_FIRST + 9
Global Const $HDM_GETITEMA = $HDM_FIRST + 3
Global Const $HDM_GETITEMW = $HDM_FIRST + 11
Global Const $HDM_GETITEMCOUNT = $HDM_FIRST + 0
Global Const $HDM_GETITEMDROPDOWNRECT = $HDM_FIRST + 25
Global Const $HDM_GETITEMRECT = $HDM_FIRST + 7
Global Const $HDM_GETORDERARRAY = $HDM_FIRST + 17
Global Const $HDM_GETOVERFLOWRECT = $HDM_FIRST + 26
Global Const $HDM_GETUNICODEFORMAT = 0x2000 + 6
Global Const $HDM_HITTEST = $HDM_FIRST + 6
Global Const $HDM_INSERTITEMA = $HDM_FIRST + 1
Global Const $HDM_INSERTITEMW = $HDM_FIRST + 10
Global Const $HDM_LAYOUT = $HDM_FIRST + 5
Global Const $HDM_ORDERTOINDEX = $HDM_FIRST + 15
Global Const $HDM_SETBITMAPMARGIN = $HDM_FIRST + 20
Global Const $HDM_SETFILTERCHANGETIMEOUT = $HDM_FIRST + 22
Global Const $HDM_SETFOCUSEDITEM = $HDM_FIRST + 28
Global Const $HDM_SETHOTDIVIDER = $HDM_FIRST + 19
Global Const $HDM_SETIMAGELIST = $HDM_FIRST + 8
Global Const $HDM_SETITEMA = $HDM_FIRST + 4
Global Const $HDM_SETITEMW = $HDM_FIRST + 12
Global Const $HDM_SETORDERARRAY = $HDM_FIRST + 18
Global Const $HDM_SETUNICODEFORMAT = 0x2000 + 5
Global Const $HDN_FIRST = -300
Global Const $HDN_BEGINDRAG = $HDN_FIRST - 10
Global Const $HDN_BEGINTRACK = $HDN_FIRST - 6
Global Const $HDN_DIVIDERDBLCLICK = $HDN_FIRST - 5
Global Const $HDN_ENDDRAG = $HDN_FIRST - 11
Global Const $HDN_ENDTRACK = $HDN_FIRST - 7
Global Const $HDN_FILTERBTNCLICK = $HDN_FIRST - 13
Global Const $HDN_FILTERCHANGE = $HDN_FIRST - 12
Global Const $HDN_GETDISPINFO = $HDN_FIRST - 9
Global Const $HDN_ITEMCHANGED = $HDN_FIRST - 1
Global Const $HDN_ITEMCHANGING = $HDN_FIRST - 0
Global Const $HDN_ITEMCLICK = $HDN_FIRST - 2
Global Const $HDN_ITEMDBLCLICK = $HDN_FIRST - 3
Global Const $HDN_TRACK = $HDN_FIRST - 8
Global Const $HDN_BEGINTRACKW = $HDN_FIRST - 26
Global Const $HDN_DIVIDERDBLCLICKW = $HDN_FIRST - 25
Global Const $HDN_ENDTRACKW = $HDN_FIRST - 27
Global Const $HDN_GETDISPINFOW = $HDN_FIRST - 29
Global Const $HDN_ITEMCHANGEDW = $HDN_FIRST - 21
Global Const $HDN_ITEMCHANGINGW = $HDN_FIRST - 20
Global Const $HDN_ITEMCLICKW = $HDN_FIRST - 22
Global Const $HDN_ITEMDBLCLICKW = $HDN_FIRST - 23
Global Const $HDN_TRACKW = $HDN_FIRST - 28
Global Const $HDS_BUTTONS = 0x00000002
Global Const $HDS_CHECKBOXES = 0x00000400
Global Const $HDS_DRAGDROP = 0x00000040
Global Const $HDS_FILTERBAR = 0x00000100
Global Const $HDS_FLAT = 0x00000200
Global Const $HDS_FULLDRAG = 0x00000080
Global Const $HDS_HIDDEN = 0x00000008
Global Const $HDS_HORZ = 0x00000000
Global Const $HDS_HOTTRACK = 0x00000004
Global Const $HDS_NOSIZING = 0x0800
Global Const $HDS_OVERFLOW = 0x1000
Global Const $HDS_DEFAULT = 0x00000046
Global $__g_hHDRLastWnd
Global Const $__HEADERCONSTANT_ClassName = "SysHeader32"
Global Const $__HEADERCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__HEADERCONSTANT_SWP_SHOWWINDOW = 0x0040
Global Const $tagHDHITTESTINFO = $tagPOINT & ";uint Flags;int Item"
Global Const $tagHDLAYOUT = "ptr Rect;ptr WindowPos"
Global Const $tagHDTEXTFILTER = "ptr Text;int TextMax"
Func _GUICtrlHeader_AddItem($hWnd, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Return _GUICtrlHeader_InsertItem($hWnd, _GUICtrlHeader_GetItemCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlHeader_ClearFilter($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_ClearFilterAll($hWnd)
Return _SendMessage($hWnd, $HDM_CLEARFILTER, -1) <> 0
EndFunc
Func _GUICtrlHeader_Create($hWnd, $iStyle = 0x00000046)
$iStyle = BitOR($iStyle, $__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE)
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hHeader = _WinAPI_CreateWindowEx(0, $__HEADERCONSTANT_ClassName, "", $iStyle, 0, 0, 0, 0, $hWnd, $nCtrlID)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
Local $tWindowPos = _GUICtrlHeader_Layout($hHeader, $tRECT)
Local $iFlags = BitOR(DllStructGetData($tWindowPos, "Flags"), $__HEADERCONSTANT_SWP_SHOWWINDOW)
_WinAPI_SetWindowPos($hHeader, DllStructGetData($tWindowPos, "InsertAfter"),  DllStructGetData($tWindowPos, "X"), DllStructGetData($tWindowPos, "Y"),  DllStructGetData($tWindowPos, "CX"), DllStructGetData($tWindowPos, "CY"), $iFlags)
_WinAPI_SetFont($hHeader, _WinAPI_GetStockObject($__HEADERCONSTANT_DEFAULT_GUI_FONT))
Return $hHeader
EndFunc
Func _GUICtrlHeader_CreateDragImage($hWnd, $iIndex)
Return Ptr(_SendMessage($hWnd, $HDM_CREATEDRAGIMAGE, $iIndex))
EndFunc
Func _GUICtrlHeader_DeleteItem($hWnd, $iIndex)
Return _SendMessage($hWnd, $HDM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlHeader_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__HEADERCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func _GUICtrlHeader_EditFilter($hWnd, $iIndex, $bDiscard = True)
Return _SendMessage($hWnd, $HDM_EDITFILTER, $iIndex, $bDiscard) <> 0
EndFunc
Func _GUICtrlHeader_GetBitmapMargin($hWnd)
Return _SendMessage($hWnd, $HDM_GETBITMAPMARGIN)
EndFunc
Func _GUICtrlHeader_GetImageList($hWnd)
Return Ptr(_SendMessage($hWnd, $HDM_GETIMAGELIST))
EndFunc
Func _GUICtrlHeader_GetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_GetItemAlign($hWnd, $iIndex)
Switch BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), $HDF_JUSTIFYMASK)
Case $HDF_LEFT
Return 0
Case $HDF_RIGHT
Return 1
Case $HDF_CENTER
Return 2
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlHeader_GetItemBitmap($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_BITMAP)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "hBmp")
EndFunc
Func _GUICtrlHeader_GetItemCount($hWnd)
Return _SendMessage($hWnd, $HDM_GETITEMCOUNT)
EndFunc
Func _GUICtrlHeader_GetItemDisplay($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_BITMAP) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_BITMAP_ON_RIGHT) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_OWNERDRAW) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_STRING) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFlags($hWnd, $iIndex)
Local $iRet = 0
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
If BitAND($iFormat, $HDF_IMAGE) <> 0 Then $iRet = BitOR($iRet, 1)
If BitAND($iFormat, $HDF_RTLREADING) <> 0 Then $iRet = BitOR($iRet, 2)
If BitAND($iFormat, $HDF_SORTDOWN) <> 0 Then $iRet = BitOR($iRet, 4)
If BitAND($iFormat, $HDF_SORTUP) <> 0 Then $iRet = BitOR($iRet, 8)
Return $iRet
EndFunc
Func _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Fmt")
EndFunc
Func _GUICtrlHeader_GetItemImage($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlHeader_GetItemOrder($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Order")
EndFunc
Func _GUICtrlHeader_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlHeader_GetItemRect($hWnd, $iIndex)
Local $aRect[4]
Local $tRECT = _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlHeader_GetItemRectEx($hWnd, $iIndex)
Local $tRECT = DllStructCreate($tagRECT)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT)
_SendMessage($hWnd, $HDM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Return $tRECT
EndFunc
Func _GUICtrlHeader_GetItemText($hWnd, $iIndex)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", 4096)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + DllStructGetSize($tBuffer), $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $HDM_GETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $HDM_GETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, DllStructGetSize($tBuffer))
_MemFree($tMemMap)
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlHeader_GetItemWidth($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
_GUICtrlHeader_GetItem($hWnd, $iIndex, $tItem)
Return DllStructGetData($tItem, "XY")
EndFunc
Func _GUICtrlHeader_GetOrderArray($hWnd)
Local $iItems = _GUICtrlHeader_GetItemCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iItems & "]")
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $HDM_GETORDERARRAY, $iItems, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Local $aBuffer[$iItems + 1]
$aBuffer[0] = $iItems
For $iI = 1 To $iItems
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlHeader_GetUnicodeFormat($hWnd)
Return _SendMessage($hWnd, $HDM_GETUNICODEFORMAT) <> 0
EndFunc
Func _GUICtrlHeader_HitTest($hWnd, $iX, $iY)
Local $tTest = DllStructCreate($tagHDHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
Local $aTest[11]
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
$aTest[0] = _SendMessage($hWnd, $HDM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $HHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $HHT_ONHEADER) <> 0
$aTest[3] = BitAND($iFlags, $HHT_ONDIVIDER) <> 0
$aTest[4] = BitAND($iFlags, $HHT_ONDIVOPEN) <> 0
$aTest[5] = BitAND($iFlags, $HHT_ONFILTER) <> 0
$aTest[6] = BitAND($iFlags, $HHT_ONFILTERBUTTON) <> 0
$aTest[7] = BitAND($iFlags, $HHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $HHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $HHT_TORIGHT) <> 0
$aTest[10] = BitAND($iFlags, $HHT_TOLEFT) <> 0
Return $aTest
EndFunc
Func _GUICtrlHeader_InsertItem($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = 0, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
Local $iFmt = $aAlign[$iAlign]
Local $iMask = BitOR($HDI_WIDTH, $HDI_FORMAT)
If $sText <> "" Then
$iMask = BitOR($iMask, $HDI_TEXT)
$iFmt = BitOR($iFmt, $HDF_STRING)
EndIf
If $iImage <> -1 Then
$iMask = BitOR($iMask, $HDI_IMAGE)
$iFmt = BitOR($iFmt, $HDF_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $HDF_BITMAP_ON_RIGHT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "XY", $iWidth)
DllStructSetData($tItem, "Fmt", $iFmt)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_INSERTITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet
EndFunc
Func _GUICtrlHeader_Layout($hWnd, ByRef $tRECT)
Local $tLayout = DllStructCreate($tagHDLAYOUT)
Local $tWindowPos = DllStructCreate($tagWINDOWPOS)
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tLayout, "Rect", DllStructGetPtr($tRECT))
DllStructSetData($tLayout, "WindowPos", DllStructGetPtr($tWindowPos))
_SendMessage($hWnd, $HDM_LAYOUT, 0, $tLayout, 0, "wparam", "struct*")
Else
Local $iLayout = DllStructGetSize($tLayout)
Local $iRect = DllStructGetSize($tRECT)
Local $iWindowPos = DllStructGetSize($tWindowPos)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iLayout + $iRect + $iWindowPos, $tMemMap)
DllStructSetData($tLayout, "Rect", $pMemory + $iLayout)
DllStructSetData($tLayout, "WindowPos", $pMemory + $iLayout + $iRect)
_MemWrite($tMemMap, $tLayout, $pMemory, $iLayout)
_MemWrite($tMemMap, $tRECT, $pMemory + $iLayout, $iRect)
_SendMessage($hWnd, $HDM_LAYOUT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory + $iLayout + $iRect, $tWindowPos, $iWindowPos)
_MemFree($tMemMap)
EndIf
Return $tWindowPos
EndFunc
Func _GUICtrlHeader_OrderToIndex($hWnd, $iOrder)
Return _SendMessage($hWnd, $HDM_ORDERTOINDEX, $iOrder)
EndFunc
Func _GUICtrlHeader_SetBitmapMargin($hWnd, $iWidth)
Return _SendMessage($hWnd, $HDM_SETBITMAPMARGIN, $iWidth)
EndFunc
Func _GUICtrlHeader_SetFilterChangeTimeout($hWnd, $iTimeOut)
Return _SendMessage($hWnd, $HDM_SETFILTERCHANGETIMEOUT, 0, $iTimeOut)
EndFunc
Func _GUICtrlHeader_SetHotDivider($hWnd, $iFlag, $iInputValue)
Return _SendMessage($hWnd, $HDM_SETHOTDIVIDER, $iFlag, $iInputValue)
EndFunc
Func _GUICtrlHeader_SetImageList($hWnd, $hImage)
Return _SendMessage($hWnd, $HDM_SETIMAGELIST, 0, $hImage, 0, "wparam", "handle", "handle")
EndFunc
Func _GUICtrlHeader_SetItem($hWnd, $iIndex, ByRef $tItem)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemAlign($hWnd, $iIndex, $iAlign)
Local $aAlign[3] = [$HDF_LEFT, $HDF_RIGHT, $HDF_CENTER]
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_JUSTIFYMASK))
$iFormat = BitOR($iFormat, $aAlign[$iAlign])
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemBitmap($hWnd, $iIndex, $hBitmap)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", BitOR($HDI_FORMAT, $HDI_BITMAP))
DllStructSetData($tItem, "Fmt", $HDF_BITMAP)
DllStructSetData($tItem, "hBMP", $hBitmap)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemDisplay($hWnd, $iIndex, $iDisplay)
Local $iFormat = BitAND(_GUICtrlHeader_GetItemFormat($hWnd, $iIndex), Not $HDF_DISPLAYMASK)
If BitAND($iDisplay, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP)
If BitAND($iDisplay, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_BITMAP_ON_RIGHT)
If BitAND($iDisplay, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_OWNERDRAW)
If BitAND($iDisplay, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_STRING)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFlags($hWnd, $iIndex, $iFlags)
Local $iFormat = _GUICtrlHeader_GetItemFormat($hWnd, $iIndex)
$iFormat = BitAND($iFormat, BitNOT($HDF_FLAGMASK))
If BitAND($iFlags, 1) <> 0 Then $iFormat = BitOR($iFormat, $HDF_IMAGE)
If BitAND($iFlags, 2) <> 0 Then $iFormat = BitOR($iFormat, $HDF_RTLREADING)
If BitAND($iFlags, 4) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTDOWN)
If BitAND($iFlags, 8) <> 0 Then $iFormat = BitOR($iFormat, $HDF_SORTUP)
Return _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
EndFunc
Func _GUICtrlHeader_SetItemFormat($hWnd, $iIndex, $iFormat)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_FORMAT)
DllStructSetData($tItem, "Fmt", $iFormat)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemImage($hWnd, $iIndex, $iImage)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_IMAGE)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemOrder($hWnd, $iIndex, $iOrder)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_ORDER)
DllStructSetData($tItem, "Order", $iOrder)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_PARAM)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetItemText($hWnd, $iIndex, $sText)
Local $bUnicode = _GUICtrlHeader_GetUnicodeFormat($hWnd)
Local $iBuffer, $pBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
$pBuffer = DllStructGetPtr($tBuffer)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_TEXT)
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
If $sText <> -1 Then
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
Else
DllStructSetData($tItem, "Text", -1)
EndIf
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $HDM_SETITEMW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $HDM_SETITEMA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetItemWidth($hWnd, $iIndex, $iWidth)
Local $tItem = DllStructCreate($tagHDITEM)
DllStructSetData($tItem, "Mask", $HDI_WIDTH)
DllStructSetData($tItem, "XY", $iWidth)
Return _GUICtrlHeader_SetItem($hWnd, $iIndex, $tItem)
EndFunc
Func _GUICtrlHeader_SetOrderArray($hWnd, ByRef $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If _WinAPI_InProcess($hWnd, $__g_hHDRLastWnd) Then
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer)
$iRet = _SendMessage($hWnd, $HDM_SETORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlHeader_SetUnicodeFormat($hWnd, $bUnicode)
Return _SendMessage($hWnd, $HDM_SETUNICODEFORMAT, $bUnicode)
EndFunc
Global Const $FR_PRIVATE = 0x10
Global Const $FR_NOT_ENUM = 0x20
Global Const $COMPRESSION_BITMAP_PNG = 0
Global Const $COMPRESSION_BITMAP_JPEG = 1
Global Const $BS_DIBPATTERN = 5
Global Const $BS_DIBPATTERN8X8 = 8
Global Const $BS_DIBPATTERNPT = 6
Global Const $BS_HATCHED = 2
Global Const $BS_HOLLOW = 1
Global Const $BS_NULL = 1
Global Const $BS_PATTERN = 3
Global Const $BS_PATTERN8X8 = 7
Global Const $BS_SOLID = 0
Global Const $HS_BDIAGONAL = 3
Global Const $HS_CROSS = 4
Global Const $HS_DIAGCROSS = 5
Global Const $HS_FDIAGONAL = 2
Global Const $HS_HORIZONTAL = 0
Global Const $HS_VERTICAL = 1
Global Const $DIB_PAL_COLORS = 1
Global Const $DIB_RGB_COLORS = 0
Global Const $CA_NEGATIVE = 0x01
Global Const $CA_LOG_FILTER = 0x02
Global Const $ILLUMINANT_DEVICE_DEFAULT = 0
Global Const $ILLUMINANT_A = 1
Global Const $ILLUMINANT_B = 2
Global Const $ILLUMINANT_C = 3
Global Const $ILLUMINANT_D50 = 4
Global Const $ILLUMINANT_D55 = 5
Global Const $ILLUMINANT_D65 = 6
Global Const $ILLUMINANT_D75 = 7
Global Const $ILLUMINANT_F2 = 8
Global Const $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
Global Const $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
Global Const $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
Global Const $ILLUMINANT_NTSC = $ILLUMINANT_C
Global Const $BI_RGB = 0
Global Const $BI_RLE8 = 1
Global Const $BI_RLE4 = 2
Global Const $BI_BITFIELDS = 3
Global Const $BI_JPEG = 4
Global Const $BI_PNG = 5
Global Const $ALTERNATE = 1
Global Const $WINDING = 2
Global Const $DWMWA_NCRENDERING_ENABLED = 1
Global Const $DWMWA_NCRENDERING_POLICY = 2
Global Const $DWMWA_TRANSITIONS_FORCEDISABLED = 3
Global Const $DWMWA_ALLOW_NCPAINT = 4
Global Const $DWMWA_CAPTION_BUTTON_BOUNDS = 5
Global Const $DWMWA_NONCLIENT_RTL_LAYOUT = 6
Global Const $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
Global Const $DWMWA_FLIP3D_POLICY = 8
Global Const $DWMWA_EXTENDED_FRAME_BOUNDS = 9
Global Const $DWMWA_HAS_ICONIC_BITMAP = 10
Global Const $DWMWA_DISALLOW_PEEK = 11
Global Const $DWMWA_EXCLUDED_FROM_PEEK = 12
Global Const $DWMNCRP_USEWINDOWSTYLE = 0
Global Const $DWMNCRP_DISABLED = 1
Global Const $DWMNCRP_ENABLED = 2
Global Const $DWMFLIP3D_DEFAULT = 0
Global Const $DWMFLIP3D_EXCLUDEBELOW = 1
Global Const $DWMFLIP3D_EXCLUDEABOVE = 2
Global Const $DM_BITSPERPEL = 0x00040000
Global Const $DM_COLLATE = 0x0008000
Global Const $DM_COLOR = 0x00000800
Global Const $DM_COPIES = 0x00000100
Global Const $DM_DEFAULTSOURCE = 0x00000200
Global Const $DM_DISPLAYFIXEDOUTPUT = 0x20000000
Global Const $DM_DISPLAYFLAGS = 0x00200000
Global Const $DM_DISPLAYFREQUENCY = 0x00400000
Global Const $DM_DISPLAYORIENTATION = 0x00000080
Global Const $DM_DITHERTYPE = 0x04000000
Global Const $DM_DUPLEX = 0x0001000
Global Const $DM_FORMNAME = 0x00010000
Global Const $DM_ICMINTENT = 0x01000000
Global Const $DM_ICMMETHOD = 0x00800000
Global Const $DM_LOGPIXELS = 0x00020000
Global Const $DM_MEDIATYPE = 0x02000000
Global Const $DM_NUP = 0x00000040
Global Const $DM_ORIENTATION = 0x00000001
Global Const $DM_PANNINGHEIGHT = 0x10000000
Global Const $DM_PANNINGWIDTH = 0x08000000
Global Const $DM_PAPERLENGTH = 0x00000004
Global Const $DM_PAPERSIZE = 0x00000002
Global Const $DM_PAPERWIDTH = 0x00000008
Global Const $DM_PELSHEIGHT = 0x00100000
Global Const $DM_PELSWIDTH = 0x00080000
Global Const $DM_POSITION = 0x00000020
Global Const $DM_PRINTQUALITY = 0x00000400
Global Const $DM_SCALE = 0x00000010
Global Const $DM_TTOPTION = 0x0004000
Global Const $DM_YRESOLUTION = 0x0002000
Global Const $DMPAPER_LETTER = 1
Global Const $DMPAPER_LETTERSMALL = 2
Global Const $DMPAPER_TABLOID = 3
Global Const $DMPAPER_LEDGER = 4
Global Const $DMPAPER_LEGAL = 5
Global Const $DMPAPER_STATEMENT = 6
Global Const $DMPAPER_EXECUTIVE = 7
Global Const $DMPAPER_A3 = 8
Global Const $DMPAPER_A4 = 9
Global Const $DMPAPER_A4SMALL = 10
Global Const $DMPAPER_A5 = 11
Global Const $DMPAPER_B4 = 12
Global Const $DMPAPER_B5 = 13
Global Const $DMPAPER_FOLIO = 14
Global Const $DMPAPER_QUARTO = 15
Global Const $DMPAPER_10X14 = 16
Global Const $DMPAPER_11X17 = 17
Global Const $DMPAPER_NOTE = 18
Global Const $DMPAPER_ENV_9 = 19
Global Const $DMPAPER_ENV_10 = 20
Global Const $DMPAPER_ENV_11 = 21
Global Const $DMPAPER_ENV_12 = 22
Global Const $DMPAPER_ENV_14 = 23
Global Const $DMPAPER_CSHEET = 24
Global Const $DMPAPER_DSHEET = 25
Global Const $DMPAPER_ESHEET = 26
Global Const $DMPAPER_ENV_DL = 27
Global Const $DMPAPER_ENV_C5 = 28
Global Const $DMPAPER_ENV_C3 = 29
Global Const $DMPAPER_ENV_C4 = 30
Global Const $DMPAPER_ENV_C6 = 31
Global Const $DMPAPER_ENV_C65 = 32
Global Const $DMPAPER_ENV_B4 = 33
Global Const $DMPAPER_ENV_B5 = 34
Global Const $DMPAPER_ENV_B6 = 35
Global Const $DMPAPER_ENV_ITALY = 36
Global Const $DMPAPER_ENV_MONARCH = 37
Global Const $DMPAPER_ENV_PERSONAL = 38
Global Const $DMPAPER_FANFOLD_US = 39
Global Const $DMPAPER_FANFOLD_STD_GERMAN = 40
Global Const $DMPAPER_FANFOLD_LGL_GERMAN = 41
Global Const $DMPAPER_ISO_B4 = 42
Global Const $DMPAPER_JAPANESE_POSTCARD = 43
Global Const $DMPAPER_9X11 = 44
Global Const $DMPAPER_10X11 = 45
Global Const $DMPAPER_15X11 = 46
Global Const $DMPAPER_ENV_INVITE = 47
Global Const $DMPAPER_RESERVED_48 = 48
Global Const $DMPAPER_RESERVED_49 = 49
Global Const $DMPAPER_LETTER_EXTRA = 50
Global Const $DMPAPER_LEGAL_EXTRA = 51
Global Const $DMPAPER_TABLOID_EXTRA = 52
Global Const $DMPAPER_A4_EXTRA = 53
Global Const $DMPAPER_LETTER_TRANSVERSE = 54
Global Const $DMPAPER_A4_TRANSVERSE = 55
Global Const $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
Global Const $DMPAPER_A_PLUS = 57
Global Const $DMPAPER_B_PLUS = 58
Global Const $DMPAPER_LETTER_PLUS = 59
Global Const $DMPAPER_A4_PLUS = 60
Global Const $DMPAPER_A5_TRANSVERSE = 61
Global Const $DMPAPER_B5_TRANSVERSE = 62
Global Const $DMPAPER_A3_EXTRA = 63
Global Const $DMPAPER_A5_EXTRA = 64
Global Const $DMPAPER_B5_EXTRA = 65
Global Const $DMPAPER_A2 = 66
Global Const $DMPAPER_A3_TRANSVERSE = 67
Global Const $DMPAPER_A3_EXTRA_TRANSVERSE = 68
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD = 69
Global Const $DMPAPER_A6 = 70
Global Const $DMPAPER_JENV_KAKU2 = 71
Global Const $DMPAPER_JENV_KAKU3 = 72
Global Const $DMPAPER_JENV_CHOU3 = 73
Global Const $DMPAPER_JENV_CHOU4 = 74
Global Const $DMPAPER_LETTER_ROTATED = 75
Global Const $DMPAPER_A3_ROTATED = 76
Global Const $DMPAPER_A4_ROTATED = 77
Global Const $DMPAPER_A5_ROTATED = 78
Global Const $DMPAPER_B4_JIS_ROTATED = 79
Global Const $DMPAPER_B5_JIS_ROTATED = 80
Global Const $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
Global Const $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
Global Const $DMPAPER_A6_ROTATED = 83
Global Const $DMPAPER_JENV_KAKU2_ROTATED = 84
Global Const $DMPAPER_JENV_KAKU3_ROTATED = 85
Global Const $DMPAPER_JENV_CHOU3_ROTATED = 86
Global Const $DMPAPER_JENV_CHOU4_ROTATED = 87
Global Const $DMPAPER_B6_JIS = 88
Global Const $DMPAPER_B6_JIS_ROTATED = 89
Global Const $DMPAPER_12X11 = 90
Global Const $DMPAPER_JENV_YOU4 = 91
Global Const $DMPAPER_JENV_YOU4_ROTATED = 92
Global Const $DMPAPER_P16K = 93
Global Const $DMPAPER_P32K = 94
Global Const $DMPAPER_P32KBIG = 95
Global Const $DMPAPER_PENV_1 = 96
Global Const $DMPAPER_PENV_2 = 97
Global Const $DMPAPER_PENV_3 = 98
Global Const $DMPAPER_PENV_4 = 99
Global Const $DMPAPER_PENV_5 = 100
Global Const $DMPAPER_PENV_6 = 101
Global Const $DMPAPER_PENV_7 = 102
Global Const $DMPAPER_PENV_8 = 103
Global Const $DMPAPER_PENV_9 = 104
Global Const $DMPAPER_PENV_10 = 105
Global Const $DMPAPER_P16K_ROTATED = 106
Global Const $DMPAPER_P32K_ROTATED = 107
Global Const $DMPAPER_P32KBIG_ROTATED = 108
Global Const $DMPAPER_PENV_1_ROTATED = 109
Global Const $DMPAPER_PENV_2_ROTATED = 110
Global Const $DMPAPER_PENV_3_ROTATED = 111
Global Const $DMPAPER_PENV_4_ROTATED = 112
Global Const $DMPAPER_PENV_5_ROTATED = 113
Global Const $DMPAPER_PENV_6_ROTATED = 114
Global Const $DMPAPER_PENV_7_ROTATED = 115
Global Const $DMPAPER_PENV_8_ROTATED = 116
Global Const $DMPAPER_PENV_9_ROTATED = 117
Global Const $DMPAPER_PENV_10_ROTATED = 118
Global Const $DMPAPER_USER = 256
Global Const $DMBIN_UPPER = 1
Global Const $DMBIN_LOWER = 2
Global Const $DMBIN_MIDDLE = 3
Global Const $DMBIN_MANUAL = 4
Global Const $DMBIN_ENVELOPE = 5
Global Const $DMBIN_ENVMANUAL = 6
Global Const $DMBIN_AUTO = 7
Global Const $DMBIN_TRACTOR = 8
Global Const $DMBIN_SMALLFMT = 9
Global Const $DMBIN_LARGEFMT = 10
Global Const $DMBIN_LARGECAPACITY = 11
Global Const $DMBIN_CASSETTE = 14
Global Const $DMBIN_FORMSOURCE = 15
Global Const $DMBIN_USER = 256
Global Const $DMRES_DRAFT = -1
Global Const $DMRES_LOW = -2
Global Const $DMRES_MEDIUM = -3
Global Const $DMRES_HIGH = -4
Global Const $DMDO_DEFAULT = 0
Global Const $DMDO_90 = 1
Global Const $DMDO_180 = 2
Global Const $DMDO_270 = 3
Global Const $DMDFO_DEFAULT = 0
Global Const $DMDFO_STRETCH = 1
Global Const $DMDFO_CENTER = 2
Global Const $DMCOLOR_MONOCHROME = 1
Global Const $DMCOLOR_COLOR = 2
Global Const $DMDUP_SIMPLEX = 1
Global Const $DMDUP_VERTICAL = 2
Global Const $DMDUP_HORIZONTAL = 3
Global Const $DMTT_BITMAP = 1
Global Const $DMTT_DOWNLOAD = 2
Global Const $DMTT_SUBDEV = 3
Global Const $DMTT_DOWNLOAD_OUTLINE = 4
Global Const $DMCOLLATE_FALSE = 0
Global Const $DMCOLLATE_TRUE = 1
Global Const $DM_GRAYSCALE = 1
Global Const $DM_INTERLACED = 2
Global Const $DMNUP_SYSTEM = 1
Global Const $DMNUP_ONEUP = 2
Global Const $DMICMMETHOD_NONE = 1
Global Const $DMICMMETHOD_SYSTEM = 2
Global Const $DMICMMETHOD_DRIVER = 3
Global Const $DMICMMETHOD_DEVICE = 4
Global Const $DMICMMETHOD_USER = 256
Global Const $DMICM_SATURATE = 1
Global Const $DMICM_CONTRAST = 2
Global Const $DMICM_COLORIMETRIC = 3
Global Const $DMICM_ABS_COLORIMETRIC = 4
Global Const $DMICM_USER = 256
Global Const $DMMEDIA_STANDARD = 1
Global Const $DMMEDIA_TRANSPARENCY = 2
Global Const $DMMEDIA_GLOSSY = 3
Global Const $DMMEDIA_USER = 256
Global Const $DMDITHER_NONE = 1
Global Const $DMDITHER_COARSE = 2
Global Const $DMDITHER_FINE = 3
Global Const $DMDITHER_LINEART = 4
Global Const $DMDITHER_ERRORDIFFUSION = 5
Global Const $DMDITHER_RESERVED6 = 6
Global Const $DMDITHER_RESERVED7 = 7
Global Const $DMDITHER_RESERVED8 = 8
Global Const $DMDITHER_RESERVED9 = 9
Global Const $DMDITHER_GRAYSCALE = 10
Global Const $DMDITHER_USER = 256
Global Const $ENUM_CURRENT_SETTINGS = -1
Global Const $ENUM_REGISTRY_SETTINGS = -2
Global Const $DEVICE_FONTTYPE = 0x2
Global Const $RASTER_FONTTYPE = 0x1
Global Const $TRUETYPE_FONTTYPE = 0x4
Global Const $NTM_BOLD = 0x00000020
Global Const $NTM_DSIG = 0x00200000
Global Const $NTM_ITALIC = 0x00000001
Global Const $NTM_MULTIPLEMASTER = 0x00080000
Global Const $NTM_NONNEGATIVE_AC = 0x00010000
Global Const $NTM_PS_OPENTYPE = 0x00020000
Global Const $NTM_REGULAR = 0x00000040
Global Const $NTM_TT_OPENTYPE = 0x00040000
Global Const $NTM_TYPE1 = 0x00100000
Global Const $FLOODFILLBORDER = 0
Global Const $FLOODFILLSURFACE = 1
Global Const $AD_COUNTERCLOCKWISE = 1
Global Const $AD_CLOCKWISE = 2
Global Const $DCB_ACCUMULATE = 0x02
Global Const $DCB_DISABLE = 0x08
Global Const $DCB_ENABLE = 0x04
Global Const $DCB_RESET = 0x01
Global Const $DCB_SET = BitOR($DCB_RESET, $DCB_ACCUMULATE)
Global Const $DCX_WINDOW = 0x00000001
Global Const $DCX_CACHE = 0x00000002
Global Const $DCX_PARENTCLIP = 0x00000020
Global Const $DCX_CLIPSIBLINGS = 0x00000010
Global Const $DCX_CLIPCHILDREN = 0x00000008
Global Const $DCX_NORESETATTRS = 0x00000004
Global Const $DCX_LOCKWINDOWUPDATE = 0x00000400
Global Const $DCX_EXCLUDERGN = 0x00000040
Global Const $DCX_INTERSECTRGN = 0x00000080
Global Const $DCX_INTERSECTUPDATE = 0x00000200
Global Const $DCX_VALIDATE = 0x00200000
Global Const $GGO_BEZIER = 3
Global Const $GGO_BITMAP = 1
Global Const $GGO_GLYPH_INDEX = 0x0080
Global Const $GGO_GRAY2_BITMAP = 4
Global Const $GGO_GRAY4_BITMAP = 5
Global Const $GGO_GRAY8_BITMAP = 6
Global Const $GGO_METRICS = 0
Global Const $GGO_NATIVE = 2
Global Const $GGO_UNHINTED = 0x0100
Global Const $GM_COMPATIBLE = 1
Global Const $GM_ADVANCED = 2
Global Const $MM_ANISOTROPIC = 8
Global Const $MM_HIENGLISH = 5
Global Const $MM_HIMETRIC = 3
Global Const $MM_ISOTROPIC = 7
Global Const $MM_LOENGLISH = 4
Global Const $MM_LOMETRIC = 2
Global Const $MM_TEXT = 1
Global Const $MM_TWIPS = 6
Global Const $R2_BLACK = 1
Global Const $R2_COPYPEN = 13
Global Const $R2_LAST = 16
Global Const $R2_MASKNOTPEN = 3
Global Const $R2_MASKPEN = 9
Global Const $R2_MASKPENNOT = 5
Global Const $R2_MERGENOTPEN = 12
Global Const $R2_MERGEPEN = 15
Global Const $R2_MERGEPENNOT = 14
Global Const $R2_NOP = 11
Global Const $R2_NOT = 6
Global Const $R2_NOTCOPYPEN = 4
Global Const $R2_NOTMASKPEN = 8
Global Const $R2_NOTMERGEPEN = 2
Global Const $R2_NOTXORPEN = 10
Global Const $R2_WHITE = 16
Global Const $R2_XORPEN = 7
Global Const $BLACKONWHITE = 1
Global Const $COLORONCOLOR = 3
Global Const $HALFTONE = 4
Global Const $WHITEONBLACK = 2
Global Const $STRETCH_ANDSCANS = $BLACKONWHITE
Global Const $STRETCH_DELETESCANS = $COLORONCOLOR
Global Const $STRETCH_HALFTONE = $HALFTONE
Global Const $STRETCH_ORSCANS = $WHITEONBLACK
Global Const $TA_BASELINE = 0x0018
Global Const $TA_BOTTOM = 0x0008
Global Const $TA_TOP = 0x0000
Global Const $TA_CENTER = 0x0006
Global Const $TA_LEFT = 0x0000
Global Const $TA_RIGHT = 0x0002
Global Const $TA_NOUPDATECP = 0x0000
Global Const $TA_RTLREADING = 0x0100
Global Const $TA_UPDATECP = 0x0001
Global Const $VTA_BASELINE = $TA_BASELINE
Global Const $VTA_BOTTOM = $TA_RIGHT
Global Const $VTA_TOP = $TA_LEFT
Global Const $VTA_CENTER = $TA_CENTER
Global Const $VTA_LEFT = $TA_BOTTOM
Global Const $VTA_RIGHT = $TA_TOP
Global Const $UDF_BGR = 1
Global Const $UDF_RGB = 0
Global Const $MWT_IDENTITY = 0x01
Global Const $MWT_LEFTMULTIPLY = 0x02
Global Const $MWT_RIGHTMULTIPLY = 0x03
Global Const $MWT_SET = 0x04
Global Const $MONITOR_DEFAULTTONEAREST = 2
Global Const $MONITOR_DEFAULTTONULL = 0
Global Const $MONITOR_DEFAULTTOPRIMARY = 1
Global Const $PT_BEZIERTO = 4
Global Const $PT_LINETO = 2
Global Const $PT_MOVETO = 6
Global Const $PT_CLOSEFIGURE = 1
#Region Global Variables and Constants
Global Const $tagBITMAPV4HEADER = 'struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct'
Global Const $tagCOLORADJUSTMENT = 'ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint'
Global Const $tagDEVMODE = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight'
Global Const $tagDEVMODE_DISPLAY = 'wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;' & $tagPOINT & ';dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency'
Global Const $tagDWM_COLORIZATION_PARAMETERS = 'dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend'
Global Const $tagENHMETAHEADER = 'struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct'
Global Const $tagEXTLOGPEN = 'dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries'
Global Const $tagFONTSIGNATURE = 'dword fsUsb[4];dword fsCsb[2]'
Global Const $tagGLYPHMETRICS = 'uint BlackBoxX;uint BlackBoxY;' & $tagPOINT & ';short CellIncX;short CellIncY'
Global Const $tagLOGBRUSH = 'uint Style;dword Color;ulong_ptr Hatch'
Global Const $tagLOGPEN = 'uint Style;dword Width;dword Color'
Global Const $tagMAT2 = 'short eM11[2];short eM12[2];short eM21[2];short eM22[2]'
Global Const $tagNEWTEXTMETRIC = $tagTEXTMETRIC & ';dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth'
Global Const $tagNEWTEXTMETRICEX = $tagNEWTEXTMETRIC & ';' & $tagFONTSIGNATURE
Global Const $tagPANOSE = 'struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct'
Global Const $tagOUTLINETEXTMETRIC = 'struct;uint otmSize;' & $tagTEXTMETRIC & ';byte otmFiller;' & $tagPANOSE & ';byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct'
Global Const $tagPAINTSTRUCT = 'hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]'
Global Const $tagRGNDATAHEADER = 'struct;dword Size;dword Type;dword Count;dword RgnSize;' & $tagRECT & ';endstruct'
Global Const $tagXFORM = 'float eM11;float eM12;float eM21;float eM22;float eDx;float eDy'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_AbortPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AbortPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AddFontMemResourceEx($pData, $iSize)
Local $aRet = DllCall('gdi32.dll', 'handle', 'AddFontMemResourceEx', 'ptr', $pData, 'dword', $iSize, 'ptr', 0, 'dword*', 0)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aRet[4], $aRet[0])
EndFunc
Func _WinAPI_AddFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'int', 'AddFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'lresult', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0,  'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_AddIconOverlay($hIcon, $hOverlay)
Local $aRet, $hResult = 0, $iError = 0
Local $ahDev[2] = [0, 0]
Local $tSIZE = _WinAPI_GetIconDimension($hIcon)
Local $hIL = DllCall('comctl32.dll', 'handle', 'ImageList_Create', 'int', DllStructGetData($tSIZE, 1),  'int', DllStructGetData($tSIZE, 2), 'uint', 0x0021, 'int', 2, 'int', 2)
If @error Or Not $hIL[0] Then Return SetError(@error + 10, @extended, 0)
Do
$ahDev[0] = _WinAPI_Create32BitHICON($hIcon)
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[0])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 200
ExitLoop
EndIf
$ahDev[1] = _WinAPI_Create32BitHICON($hOverlay)
If @error Then
$iError = @error + 300
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'ImageList_ReplaceIcon', 'handle', $hIL[0], 'int', -1, 'handle', $ahDev[1])
If @error Or ($aRet[0] = -1) Then
$iError = @error + 400
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'bool', 'ImageList_SetOverlayImage', 'handle', $hIL[0], 'int', 1, 'int', 1)
If @error Or Not $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$aRet = DllCall('comctl32.dll', 'handle', 'ImageList_GetIcon', 'handle', $hIL[0], 'int', 0, 'uint', 0x00000100)
If @error Or Not $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$hResult = $aRet[0]
Until 1
DllCall('comctl32.dll', 'bool', 'ImageList_Destroy', 'handle', $hIL[0])
For $i = 0 To 1
If $ahDev[$i] Then
_WinAPI_DestroyIcon($ahDev[$i])
EndIf
Next
If Not $hResult Then Return SetError($iError, 0, 0)
Return $hResult
EndFunc
Func _WinAPI_AdjustBitmap($hBitmap, $iWidth, $iHeight, $iMode = 3, $tAdjustment = 0)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
If $iWidth = -1 Then
$iWidth = DllStructGetData($tObj, 'bmWidth')
EndIf
If $iHeight = -1 Then
$iHeight = DllStructGetData($tObj, 'bmHeight')
EndIf
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
If _WinAPI_SetStretchBltMode($hDestDC, $iMode) Then
Switch $iMode
Case 4
If IsDllStruct($tAdjustment) Then
If Not _WinAPI_SetColorAdjustment($hDestDC, $tAdjustment) Then
EndIf
EndIf
Case Else
EndSwitch
EndIf
$aRet = _WinAPI_StretchBlt($hDestDC, 0, 0, $iWidth, $iHeight, $hSrcDC, 0, 0, DllStructGetData($tObj, 'bmWidth'), DllStructGetData($tObj, 'bmHeight'), 0x00CC0020)
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If Not $aRet Then Return SetError(10, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_AlphaBlend($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iAlpha, $bAlpha = False)
Local $iBlend = BitOR(BitShift(Not ($bAlpha = False), -24), BitShift(BitAND($iAlpha, 0xFF), -16))
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiAlphaBlend', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'handle', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iBlend)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AngleArc($hDC, $iX, $iY, $iRadius, $nStartAngle, $nSweepAngle)
Local $aRet = DllCall('gdi32.dll', 'bool', 'AngleArc', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', $iRadius,  'float', $nStartAngle, 'float', $nSweepAngle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Arc($hDC, $tRECT, $iXStartArc, $iYStartArc, $iXEndArc, $iYEndArc)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Arc', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXStartArc, 'int', $iYStartArc, 'int', $iXEndArc, 'int', $iYEndArc)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ArcTo($hDC, $tRECT, $iXRadial1, $iYRadial1, $iXRadial2, $iYRadial2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ArcTo', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4),  'int', $iXRadial1, 'int', $iYRadial1, 'int', $iXRadial2, 'int', $iYRadial2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPaint($hWnd, ByRef $tPAINTSTRUCT)
$tPAINTSTRUCT = DllStructCreate($tagPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'BeginPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseEnhMetaFile($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CloseEnhMetaFile', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseFigure($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CloseFigure', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ColorAdjustLuma($iRGB, $iPercent, $bScale = True)
If $iRGB = -1 Then Return SetError(10, 0, -1)
If $bScale Then
$iPercent = Floor($iPercent * 10)
EndIf
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorAdjustLuma', 'dword', __RGB($iRGB), 'int', $iPercent, 'bool', $bScale)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorHLSToRGB($iHue, $iLuminance, $iSaturation)
If Not $iSaturation Then $iHue = 160
Local $aRet = DllCall('shlwapi.dll', 'dword', 'ColorHLSToRGB', 'word', $iHue, 'word', $iLuminance, 'word', $iSaturation)
If @error Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_ColorRGBToHLS($iRGB, ByRef $iHue, ByRef $iLuminance, ByRef $iSaturation)
Local $aRet = DllCall('shlwapi.dll', 'none', 'ColorRGBToHLS', 'dword', __RGB($iRGB), 'word*', 0, 'word*', 0, 'word*', 0)
If @error Then Return SetError(@error, @extended, 0)
$iHue = $aRet[2]
$iLuminance = $aRet[3]
$iSaturation = $aRet[4]
Return 1
EndFunc
Func _WinAPI_CombineTransform($tXFORM1, $tXFORM2)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'CombineTransform', 'struct*', $tXFORM, 'struct*', $tXFORM1, 'struct*', $tXFORM2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_CompressBitmapBits($hBitmap, ByRef $pBuffer, $iCompression = 0, $iQuality = 100)
If Not __DLL('gdiplus.dll') Then Return SetError(103, 0, 0)
Local $aSize[2], $iCount, $iFormat, $iLength, $sMime, $aRet, $hDC, $hSv, $hMem, $tBits, $tData, $pData, $iError = 1
Local $hSource = 0, $hImage = 0, $hToken = 0, $pStream = 0, $tParam = 0
Local $tDIB = DllStructCreate($tagDIBSECTION)
Do
Switch $iCompression
Case 0
$sMime = 'image/png'
Case 1
$sMime = 'image/jpeg'
Case Else
$iError = 10
ExitLoop
EndSwitch
While $hBitmap
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB) Then
$iError = 11
ExitLoop 2
EndIf
If (DllStructGetData($tDIB, 'bmBitsPixel') = 32) And (Not DllStructGetData($tDIB, 'biCompression')) Then
$iError = 12
ExitLoop
EndIf
If $hSource Then
$iError = 13
ExitLoop 2
EndIf
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'))
If Not $hSource Then
$iError = @error + 100
ExitLoop 2
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$iError = @error + 200
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
WEnd
If Not $hBitmap Then
ExitLoop
EndIf
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
Next
$tBits = DllStructCreate('byte[' & ($aSize[0] * $aSize[1] * 4) & ']')
If Not _WinAPI_GetBitmapBits($hBitmap, DllStructGetSize($tBits), $tBits) Then
$iError = @error + 300
ExitLoop
EndIf
$tData = DllStructCreate($tagGDIPSTARTUPINPUT)
DllStructSetData($tData, "Version", 1)
$aRet = DllCall('gdiplus.dll', 'int', 'GdiplusStartup', 'ulong_ptr*', 0, 'struct*', $tData, 'ptr', 0)
If @error Or $aRet[0] Then
$iError = @error + 400
ExitLoop
EndIf
If _WinAPI_IsAlphaBitmap($hBitmap) Then
$iFormat = 0x0026200A
Else
$iFormat = 0x00022009
EndIf
$hToken = $aRet[1]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipCreateBitmapFromScan0', 'int', $aSize[0], 'int', $aSize[1],  'uint', $aSize[0] * 4, 'int', $iFormat, 'struct*', $tBits, 'ptr*', 0)
If @error Or $aRet[0] Then
$iError = @error + 500
ExitLoop
EndIf
$hImage = $aRet[6]
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncodersSize', 'uint*', 0, 'uint*', 0)
If @error Or $aRet[0] Then
$iError = @error + 600
ExitLoop
EndIf
$iCount = $aRet[1]
$tData = DllStructCreate('byte[' & $aRet[2] & ']')
If @error Then
$iError = @error + 700
ExitLoop
EndIf
$pData = DllStructGetPtr($tData)
$aRet = DllCall('gdiplus.dll', 'int', 'GdipGetImageEncoders', 'uint', $iCount, 'uint', $aRet[2], 'struct*', $tData)
If @error Or $aRet[0] Then
$iError = @error + 800
ExitLoop
EndIf
Local $tCodec, $pEncoder = 0
For $i = 1 To $iCount
$tCodec = DllStructCreate($tagGDIPIMAGECODECINFO, $pData)
If Not StringInStr(_WinAPI_WideCharToMultiByte(DllStructGetData($tCodec, 'MimeType')), $sMime) Then
$pData += DllStructGetSize($tagGDIPIMAGECODECINFO)
Else
$pEncoder = $pData
$iError = 0
ExitLoop
EndIf
Next
If Not $pEncoder Then
$iError = 15
ExitLoop
EndIf
Switch $iCompression
Case 0
Case 1
Local Const $tagENCODERPARAMETER = 'byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue'
$tParam = DllStructCreate('dword Count;' & $tagENCODERPARAMETER & ';ulong Quality')
DllStructSetData($tParam, 'Count', 1)
DllStructSetData($tParam, 'NumberOfValues', 1)
DllStructSetData($tParam, 'Type', 4)
DllStructSetData($tParam, 'pValue', DllStructGetPtr($tParam, 'Quality'))
DllStructSetData($tParam, 'Quality', $iQuality)
$aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', '{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}',  'ptr', DllStructGetPtr($tParam, 2))
If @error Or $aRet[0] Then
$tParam = 0
EndIf
EndSwitch
$pStream = _WinAPI_CreateStreamOnHGlobal()
$aRet = DllCall('gdiplus.dll', 'int', 'GdipSaveImageToStream', 'handle', $hImage, 'ptr', $pStream,  'ptr', $pEncoder, 'struct*', $tParam)
If @error Or $aRet[0] Then
$iError = @error + 900
ExitLoop
EndIf
$hMem = _WinAPI_GetHGlobalFromStream($pStream)
$aRet = DllCall('kernel32.dll', 'ulong_ptr', 'GlobalSize', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1000
ExitLoop
EndIf
$iLength = $aRet[0]
$aRet = DllCall('kernel32.dll', 'ptr', 'GlobalLock', 'handle', $hMem)
If @error Or Not $aRet[0] Then
$iError = @error + 1100
ExitLoop
EndIf
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If Not @error Then
_WinAPI_MoveMemory($pBuffer, $aRet[0], $iLength)
Else
$iError = @error + 1300
EndIf
Until 1
If $pStream Then
_WinAPI_ReleaseStream($pStream)
EndIf
If $hImage Then
DllCall('gdiplus.dll', 'int', 'GdipDisposeImage', 'handle', $hImage)
EndIf
If $hToken Then
DllCall('gdiplus.dll', 'none', 'GdiplusShutdown', 'ulong_ptr', $hToken)
EndIf
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
If $iError Then Return SetError($iError, 0, 0)
Return $iLength
EndFunc
Func _WinAPI_CopyEnhMetaFile($hEmf, $sFilePath = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CopyEnhMetaFileW', 'handle', $hEmf, $sTypeOfFile, $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyRect($tRECT)
Local $tData = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'CopyRect', 'struct*', $tData, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_Create32BitHBITMAP($hIcon, $bDib = False, $bDelete = False)
Local $hBitmap = 0
Local $aDIB[2] = [0, 0]
Local $hTemp = _WinAPI_Create32BitHICON($hIcon)
If @error Then Return SetError(@error, @extended, 0)
Local $iError = 0
Do
Local $tICONINFO = DllStructCreate($tagICONINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $hTemp, 'struct*', $tICONINFO)
If @error Or Not $aRet[0] Then
$iError = @error + 10
ExitLoop
EndIf
For $i = 0 To 1
$aDIB[$i] = DllStructGetData($tICONINFO, $i + 4)
Next
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($aDIB[0], DllStructGetSize($tBITMAP), $tBITMAP) Then
$iError = @error + 20
ExitLoop
EndIf
If $bDib Then
$hBitmap = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'))
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
_WinAPI_DrawIconEx($hDC, 0, 0, $hTemp)
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = $aDIB[1]
$aDIB[1] = 0
EndIf
Until 1
For $i = 0 To 1
If $aDIB[$i] Then
_WinAPI_DeleteObject($aDIB[$i])
EndIf
Next
_WinAPI_DestroyIcon($hTemp)
If $iError Then Return SetError($iError, 0, 0)
If Not $hBitmap Then Return SetError(12, 0, 0)
If $bDelete Then
_WinAPI_DestroyIcon($hIcon)
EndIf
Return $hBitmap
EndFunc
Func _WinAPI_CreateBitmapIndirect(ByRef $tBITMAP)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBitmapIndirect', 'struct*', $tBITMAP)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateBrushIndirect($iStyle, $iRGB, $iHatch = 0)
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateBrushIndirect', 'struct*', $tLOGBRUSH)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateColorAdjustment($iFlags = 0, $iIlluminant = 0, $iGammaR = 10000, $iGammaG = 10000, $iGammaB = 10000, $iBlack = 0, $iWhite = 10000, $iContrast = 0, $iBrightness = 0, $iColorfulness = 0, $iTint = 0)
Local $tCA = DllStructCreate($tagCOLORADJUSTMENT)
DllStructSetData($tCA, 1, DllStructGetSize($tCA))
DllStructSetData($tCA, 2, $iFlags)
DllStructSetData($tCA, 3, $iIlluminant)
DllStructSetData($tCA, 4, $iGammaR)
DllStructSetData($tCA, 5, $iGammaG)
DllStructSetData($tCA, 6, $iGammaB)
DllStructSetData($tCA, 7, $iBlack)
DllStructSetData($tCA, 8, $iWhite)
DllStructSetData($tCA, 9, $iContrast)
DllStructSetData($tCA, 10, $iBrightness)
DllStructSetData($tCA, 11, $iColorfulness)
DllStructSetData($tCA, 12, $iTint)
Return $tCA
EndFunc
Func _WinAPI_CreateCompatibleBitmapEx($hDC, $iWidth, $iHeight, $iRGB)
Local $hBrush = _WinAPI_CreateBrushIndirect(0, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleBitmap', 'handle', $hDC, 'int', $iWidth, 'int', $iHeight)
Local $hBmp = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBmp)
Local $hDestSv = $aRet[0]
Local $tRECT = _WinAPI_CreateRectEx(0, 0, $iWidth, $iHeight)
Local $iError = 0
$aRet = DllCall('user32.dll', 'int', 'FillRect', 'handle', $hDestDC, 'struct*', $tRECT, 'handle', $hBrush)
If @error Or Not $aRet[0] Then
$iError = @error + 10
_WinAPI_DeleteObject($hBmp)
EndIf
_WinAPI_DeleteObject($hBrush)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, 0)
Return $hBmp
EndFunc
Func _WinAPI_CreateDIBitmap($hDC, ByRef $tBITMAPINFO, $iUsage, $pBits = 0)
Local $iInit = 0
If $pBits Then
$iInit = 0x04
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateDIBitmap', 'handle', $hDC, 'struct*', $tBITMAPINFO, 'dword', $iInit, 'struct*', $pBits,  'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEllipticRgn($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEllipticRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateEnhMetaFile($hDC = 0, $tRECT = 0, $bPixels = False, $sFilePath = '', $sDescription = '')
Local $sTypeOfFile = 'wstr'
If Not StringStripWS($sFilePath, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfFile = 'ptr'
$sFilePath = 0
EndIf
Local $tData = 0, $aData = StringSplit($sDescription, '|', $STR_NOCOUNT)
If UBound($aData) < 2 Then
ReDim $aData[2]
$aData[1] = ''
EndIf
For $i = 0 To 1
$aData[$i] = StringStripWS($aData[$i], $STR_STRIPLEADING + $STR_STRIPTRAILING)
Next
If ($aData[0]) Or ($aData[1]) Then
$tData = _WinAPI_ArrayToStruct($aData)
EndIf
Local $iXp, $iYp, $iXm, $iYm, $hRef = 0
If $bPixels And (IsDllStruct($tRECT)) Then
If Not $hDC Then
$hRef = _WinAPI_GetDC(0)
EndIf
$iXp = _WinAPI_GetDeviceCaps($hRef, 8)
$iYp = _WinAPI_GetDeviceCaps($hRef, 10)
$iXm = _WinAPI_GetDeviceCaps($hRef, 4)
$iYm = _WinAPI_GetDeviceCaps($hRef, 6)
If $hRef Then
_WinAPI_ReleaseDC(0, $hRef)
EndIf
For $i = 1 To 3 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iXm / $iXp * 100))
Next
For $i = 2 To 4 Step 2
DllStructSetData($tRECT, $i, Round(DllStructGetData($tRECT, $i) * $iYm / $iYp * 100))
Next
EndIf
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateEnhMetaFileW', 'handle', $hDC, $sTypeOfFile, $sFilePath, 'struct*', $tRECT,  'struct*', $tData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateFontEx($iHeight, $iWidth = 0, $iEscapement = 0, $iOrientation = 0, $iWeight = 400, $bItalic = False, $bUnderline = False, $bStrikeOut = False, $iCharSet = 1, $iOutPrecision = 0, $iClipPrecision = 0, $iQuality = 0, $iPitchAndFamily = 0, $sFaceName = '', $iStyle = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateFontW', 'int', $iHeight, 'int', $iWidth, 'int', $iEscapement,  'int', $iOrientation, 'int', $iWeight, 'dword', $bItalic, 'dword', $bUnderline, 'dword', $bStrikeOut,  'dword', $iCharSet, 'dword', $iOutPrecision, 'dword', $iClipPrecision, 'dword', $iQuality,  'dword', $iPitchAndFamily, 'wstr', _WinAPI_GetFontName($sFaceName, $iStyle, $iCharSet))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateNullRgn()
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgn', 'int', 0, 'int', 0, 'int', 0, 'int', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreatePen($iPenStyle, $iWidth, $iColor)
Local $aResult = DllCall("gdi32.dll", "handle", "CreatePen", "int", $iPenStyle, "int", $iWidth, "INT", $iColor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_CreatePolygonRgn(Const ByRef $aPoint, $iStart = 0, $iEnd = -1, $iMode = 1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, 0)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreatePolygonRgn', 'struct*', $tData, 'int', $iCount - 1, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateRectRgnIndirect($tRECT)
Local $aRet = DllCall('gdi32.dll', 'handle', 'CreateRectRgnIndirect', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight, $bRGB = 1)
Local $hDC = _WinAPI_GetDC($hWnd)
Local $hDestDC = _WinAPI_CreateCompatibleDC($hDC)
Local $hBitmap = _WinAPI_CreateCompatibleBitmap($hDC, $iWidth, $iHeight)
Local $hOld = _WinAPI_SelectObject($hDestDC, $hBitmap)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, 0)
DllStructSetData($tRECT, 2, 0)
DllStructSetData($tRECT, 3, $iWidth)
DllStructSetData($tRECT, 4, $iHeight)
If $bRGB Then
$iColor = BitOR(BitAND($iColor, 0x00FF00), BitShift(BitAND($iColor, 0x0000FF), -16), BitShift(BitAND($iColor, 0xFF0000), 16))
EndIf
Local $hBrush = _WinAPI_CreateSolidBrush($iColor)
If Not _WinAPI_FillRect($hDestDC, $tRECT, $hBrush) Then
_WinAPI_DeleteObject($hBitmap)
$hBitmap = 0
EndIf
_WinAPI_DeleteObject($hBrush)
_WinAPI_ReleaseDC($hWnd, $hDC)
_WinAPI_SelectObject($hDestDC, $hOld)
_WinAPI_DeleteDC($hDestDC)
If Not $hBitmap Then Return SetError(1, 0, 0)
Return $hBitmap
EndFunc
Func _WinAPI_CreateTransform($nM11 = 1, $nM12 = 0, $nM21 = 0, $nM22 = 1, $nDX = 0, $nDY = 0)
Local $tXFORM = DllStructCreate($tagXFORM)
DllStructSetData($tXFORM, 1, $nM11)
DllStructSetData($tXFORM, 2, $nM12)
DllStructSetData($tXFORM, 3, $nM21)
DllStructSetData($tXFORM, 4, $nM22)
DllStructSetData($tXFORM, 5, $nDX)
DllStructSetData($tXFORM, 6, $nDY)
Return $tXFORM
EndFunc
Func _WinAPI_DeleteEnhMetaFile($hEmf)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DeleteEnhMetaFile', 'handle', $hEmf)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DPtoLP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'DPtoLP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawAnimatedRects($hWnd, $tRectFrom, $tRectTo)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawAnimatedRects', 'hwnd', $hWnd, 'int', 3, 'struct*', $tRectFrom,  'struct*', $tRectTo)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawBitmap($hDC, $iX, $iY, $hBitmap, $iRop = 0x00CC0020)
Local $tObj = DllStructCreate($tagBITMAP)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', 0)
Local $_hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $_hDC)
Local $hSrcDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hBitmap)
Local $hSrcSv = $aRet[0]
Local $iError = 0
$aRet = DllCall('gdi32.dll', 'int', 'BitBlt', 'hwnd', $hDC, 'int', $iX, 'int', $iY, 'int', DllStructGetData($tObj, 'bmWidth'), 'int', DllStructGetData($tObj, 'bmHeight'), 'hwnd', $hSrcDC, 'int', 0, 'int', 0, 'int', $iRop)
If @error Or Not $aRet[0] Then
$iError = @error + 1
EndIf
DllCall('user32.dll', 'int', 'ReleaseDC', 'hwnd', 0, 'handle', $_hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hSrcDC, 'handle', $hSrcSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hSrcDC)
If $iError Then Return SetError(10, 0, 0)
Return 1
EndFunc
Func _WinAPI_DrawFocusRect($hDC, $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'DrawFocusRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DrawLine($hDC, $iX1, $iY1, $iX2, $iY2)
_WinAPI_MoveTo($hDC, $iX1, $iY1)
If @error Then Return SetError(@error, @extended, False)
_WinAPI_LineTo($hDC, $iX2, $iY2)
If @error Then Return SetError(@error + 10, @extended, False)
Return True
EndFunc
Func _WinAPI_DrawShadowText($hDC, $sText, $iRGBText, $iRGBShadow, $iXOffset = 0, $iYOffset = 0, $tRECT = 0, $iFlags = 0)
Local $aRet
If Not IsDllStruct($tRECT) Then
$tRECT = DllStructCreate($tagRECT)
$aRet = DllCall('user32.dll', 'bool', 'GetClientRect', 'hwnd', _WinAPI_WindowFromDC($hDC), 'struct*', $tRECT)
If @error Then Return SetError(@error + 10, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
EndIf
$aRet = DllCall('comctl32.dll', 'int', 'DrawShadowText', 'handle', $hDC, 'wstr', $sText, 'uint', -1, 'struct*', $tRECT,  'dword', $iFlags, 'int', __RGB($iRGBText), 'int', __RGB($iRGBShadow), 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DwmDefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('dwmapi.dll', 'bool', 'DwmDefWindowProc', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam, 'lresult*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[5]
EndFunc
Func _WinAPI_DwmEnableBlurBehindWindow($hWnd, $bEnable = True, $bTransition = False, $hRgn = 0)
Local $tBLURBEHIND = DllStructCreate('dword;bool;handle;bool')
Local $iFlags = 0
If $hRgn Then
$iFlags += 2
DllStructSetData($tBLURBEHIND, 3, $hRgn)
EndIf
DllStructSetData($tBLURBEHIND, 1, BitOR($iFlags, 0x05))
DllStructSetData($tBLURBEHIND, 2, $bEnable)
DllStructSetData($tBLURBEHIND, 4, $bTransition)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableBlurBehindWindow', 'hwnd', $hWnd, 'struct*', $tBLURBEHIND)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmEnableComposition($bEnable)
If $bEnable Then $bEnable = 1
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmEnableComposition', 'uint', $bEnable)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmExtendFrameIntoClientArea($hWnd, $tMARGINS = 0)
If Not IsDllStruct($tMARGINS) Then
$tMARGINS = _WinAPI_CreateMargins(-1, -1, -1, -1)
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmExtendFrameIntoClientArea', 'hwnd', $hWnd, 'struct*', $tMARGINS)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmGetColorizationColor()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetColorizationColor', 'dword*', 0, 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return SetExtended($aRet[2], $aRet[1])
EndFunc
Func _WinAPI_DwmGetColorizationParameters()
Local $tDWMCP = DllStructCreate($tagDWM_COLORIZATION_PARAMETERS)
Local $aRet = DllCall('dwmapi.dll', 'uint', 127, 'struct*', $tDWMCP)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tDWMCP
EndFunc
Func _WinAPI_DwmGetWindowAttribute($hWnd, $iAttribute)
Local $tagStruct
Switch $iAttribute
Case 5, 9
$tagStruct = $tagRECT
Case 1
$tagStruct = 'uint'
Case Else
Return SetError(11, 0, 0)
EndSwitch
Local $tData = DllStructCreate($tagStruct)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmGetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'struct*', $tData, 'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Switch $iAttribute
Case 1
Return DllStructGetData($tData, 1)
Case Else
Return $tData
EndSwitch
EndFunc
Func _WinAPI_DwmInvalidateIconicBitmaps($hWnd)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmInvalidateIconicBitmaps', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmIsCompositionEnabled()
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmIsCompositionEnabled', 'bool*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[1]
EndFunc
Func _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmQueryThumbnailSourceSize', 'handle', $hThumbnail, 'struct*', $tSIZE)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $tSIZE
EndFunc
Func _WinAPI_DwmRegisterThumbnail($hDestination, $hSource)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmRegisterThumbnail', 'hwnd', $hDestination, 'hwnd', $hSource, 'handle*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[3]
EndFunc
Func _WinAPI_DwmSetColorizationParameters($tDWMCP)
Local $aRet = DllCall('dwmapi.dll', 'uint', 131, 'struct*', $tDWMCP, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicLivePreviewBitmap($hWnd, $hBitmap, $bFrame = False, $tClient = 0)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'uint', 'DwmSetIconicLivePreviewBitmap', 'hwnd', $hWnd, 'handle', $hBitmap,  'struct*', $tClient, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetIconicThumbnail($hWnd, $hBitmap, $bFrame = False)
Local $iFlags
If $bFrame Then
$iFlags = 0x00000001
Else
$iFlags = 0
EndIf
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetIconicThumbnail', 'hwnd', $hWnd, 'handle', $hBitmap, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmSetWindowAttribute($hWnd, $iAttribute, $iData)
Switch $iAttribute
Case 2, 3, 4, 6, 7, 8, 10, 11, 12
Case Else
Return SetError(1, 0, 0)
EndSwitch
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmSetWindowAttribute', 'hwnd', $hWnd, 'dword', $iAttribute,  'dword*', $iData, 'dword', 4)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUnregisterThumbnail($hThumbnail)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUnregisterThumbnail', 'handle', $hThumbnail)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_DwmUpdateThumbnailProperties($hThumbnail, $bVisible = True, $bClientAreaOnly = False, $iOpacity = 255, $tRectDest = 0, $tRectSrc = 0)
Local Const $tagDWM_THUMBNAIL_PROPERTIES = 'struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct'
Local $tTHUMBNAILPROPERTIES = DllStructCreate($tagDWM_THUMBNAIL_PROPERTIES)
Local $tSIZE, $iFlags = 0
If Not IsDllStruct($tRectDest) Then
$tSIZE = _WinAPI_DwmQueryThumbnailSourceSize($hThumbnail)
If @error Then
Return SetError(@error + 10, @extended, 0)
EndIf
$tRectDest = _WinAPI_CreateRectEx(0, 0, DllStructGetData($tSIZE, 1), DllStructGetData($tSIZE, 2))
EndIf
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 2, DllStructGetData($tRectDest, $i), $i)
Next
If IsDllStruct($tRectSrc) Then
$iFlags += 2
For $i = 1 To 4
DllStructSetData($tTHUMBNAILPROPERTIES, 3, DllStructGetData($tRectSrc, $i), $i)
Next
EndIf
DllStructSetData($tTHUMBNAILPROPERTIES, 1, BitOR($iFlags, 0x1D))
DllStructSetData($tTHUMBNAILPROPERTIES, 4, $iOpacity)
DllStructSetData($tTHUMBNAILPROPERTIES, 5, $bVisible)
DllStructSetData($tTHUMBNAILPROPERTIES, 6, $bClientAreaOnly)
Local $aRet = DllCall('dwmapi.dll', 'long', 'DwmUpdateThumbnailProperties', 'handle', $hThumbnail,  'struct*', $tTHUMBNAILPROPERTIES)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_Ellipse($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Ellipse', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPaint($hWnd, ByRef $tPAINTSTRUCT)
Local $aRet = DllCall('user32.dll', 'bool', 'EndPaint', 'hwnd', $hWnd, 'struct*', $tPAINTSTRUCT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EndPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EndPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumDisplayMonitors($hDC = 0, $tRECT = 0)
Local $hEnumProc = DllCallbackRegister('__EnumDisplayMonitorsProc', 'bool', 'handle;handle;ptr;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplayMonitors', 'handle', $hDC, 'struct*', $tRECT,  'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDisplaySettings($sDevice, $iMode)
Local $sTypeOfDevice = 'wstr'
If Not StringStripWS($sDevice, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfDevice = 'ptr'
$sDevice = 0
EndIf
Local $tDEVMODE = DllStructCreate($tagDEVMODE_DISPLAY)
DllStructSetData($tDEVMODE, 'Size', DllStructGetSize($tDEVMODE))
DllStructSetData($tDEVMODE, 'DriverExtra', 0)
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDisplaySettingsW', $sTypeOfDevice, $sDevice, 'dword', $iMode,  'struct*', $tDEVMODE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tDEVMODE, 'PelsWidth')
$aResult[1] = DllStructGetData($tDEVMODE, 'PelsHeight')
$aResult[2] = DllStructGetData($tDEVMODE, 'BitsPerPel')
$aResult[3] = DllStructGetData($tDEVMODE, 'DisplayFrequency')
$aResult[4] = DllStructGetData($tDEVMODE, 'DisplayFlags')
Return $aResult
EndFunc
Func _WinAPI_EnumFontFamilies($hDC = 0, $sFaceName = '', $iCharSet = 1, $iFontType = 0x07, $sPattern = '', $bExclude = False)
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
Local $tPattern = DllStructCreate('uint;uint;ptr;wchar[' & (StringLen($sPattern) + 1) & ']')
DllStructSetData($tPattern, 1, $iFontType)
If Not $sPattern Then
DllStructSetData($tPattern, 2, 0)
DllStructSetData($tPattern, 3, 0)
Else
DllStructSetData($tPattern, 2, $bExclude)
DllStructSetData($tPattern, 3, DllStructGetPtr($tPattern, 4))
DllStructSetData($tPattern, 4, $sPattern)
EndIf
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $hCDC
If Not $hDC Then
$hCDC = _WinAPI_CreateCompatibleDC(0)
Else
$hCDC = $hDC
EndIf
Dim $__g_vEnum[101][8] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumFontFamiliesProc', 'int', 'ptr;ptr;dword;PTR')
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hCDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tPattern, 'dword', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If Not $hDC Then
_WinAPI_DeleteDC($hCDC)
EndIf
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EqualRect($tRECT1, $tRECT2)
Local $aRet = DllCall('user32.dll', 'bool', 'EqualRect', 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EqualRgn($hRgn1, $hRgn2)
Local $aRet = DllCall('gdi32.dll', 'bool', 'EqualRgn', 'handle', $hRgn1, 'handle', $hRgn2)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExcludeClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExcludeClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreatePen($iPenStyle, $iWidth, $iBrushStyle, $iRGB, $iHatch = 0, $aUserStyle = 0, $iStart = 0, $iEnd = -1)
Local $iCount = 0, $tStyle = 0
If BitAND($iPenStyle, 0xFF) = 7 Then
If __CheckErrorArrayBounds($aUserStyle, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$tStyle = DllStructCreate('dword[' & ($iEnd - $iStart + 1) & ']')
For $i = $iStart To $iEnd
DllStructSetData($tStyle, 1, $aUserStyle[$i], $iCount + 1)
$iCount += 1
Next
EndIf
Local $tLOGBRUSH = DllStructCreate($tagLOGBRUSH)
DllStructSetData($tLOGBRUSH, 1, $iBrushStyle)
DllStructSetData($tLOGBRUSH, 2, __RGB($iRGB))
DllStructSetData($tLOGBRUSH, 3, $iHatch)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreatePen', 'dword', $iPenStyle, 'dword', $iWidth, 'struct*', $tLOGBRUSH,  'dword', $iCount, 'struct*', $tStyle)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtCreateRegion($tRGNDATA, $tXFORM = 0)
Local $aRet = DllCall('gdi32.dll', 'handle', 'ExtCreateRegion', 'struct*', $tXFORM, 'dword', DllStructGetSize($tRGNDATA),  'struct*', $tRGNDATA)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtFloodFill($hDC, $iX, $iY, $iRGB, $iType = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ExtFloodFill', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB),  'uint', $iType)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ExtSelectClipRgn($hDC, $hRgn, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'int', 'ExtSelectClipRgn', 'handle', $hDC, 'handle', $hRgn, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FillRgn($hDC, $hRgn, $hBrush)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FillRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FlattenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FlattenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_FrameRgn($hDC, $hRgn, $hBrush, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'FrameRgn', 'handle', $hDC, 'handle', $hRgn, 'handle', $hBrush, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GdiComment($hDC, $pBuffer, $iSize)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiComment', 'handle', $hDC, 'uint', $iSize, 'struct*', $pBuffer)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetArcDirection($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetArcDirection', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] < 1) Or ($aRet[0] > 2) Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'GetBitmapBits', 'handle', $hBitmap, 'long', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetBitmapDimensionEx($hBitmap)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBitmapDimensionEx', 'handle', $hBitmap, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetBkColor($hDC)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetBkColor', 'handle', $hDC)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetBoundsRect($hDC, $iFlags = 0)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tRECT)
EndFunc
Func _WinAPI_GetBrushOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetBrushOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetBValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0xFF0000), 16)
EndFunc
Func _WinAPI_GetClipBox($hDC, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipBox', 'handle', $hDC, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetClipRgn($hDC)
Local $hRgn = _WinAPI_CreateRectRgn(0, 0, 0, 0)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'int', 'GetClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Or ($aRet[0] = -1) Then $iError = @error + 10
If $iError Or Not $aRet[0] Then
_WinAPI_DeleteObject($hRgn)
$hRgn = 0
EndIf
Return SetError($iError, 0, $hRgn)
EndFunc
Func _WinAPI_GetColorAdjustment($hDC)
Local $tAdjustment = DllStructCreate($tagCOLORADJUSTMENT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tAdjustment
EndFunc
Func _WinAPI_GetCurrentPosition($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetCurrentPositionEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetDeviceGammaRamp($hDC, ByRef $aRamp)
$aRamp = 0
Local $tData = DllStructCreate('word[256];word[256];word[256]')
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Dim $aRamp[256][3]
For $i = 0 To 2
For $j = 0 To 255
$aRamp[$j][$i] = DllStructGetData($tData, $i + 1, $j + 1)
Next
Next
Return 1
EndFunc
Func _WinAPI_GetDIBColorTable($hBitmap)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $tPeak = DllStructCreate('dword[256]')
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', 256, 'struct*', $tPeak)
If @error Or Not $aRet[0] Then $iError = @error + 10
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Local $tData = DllStructCreate('dword[' & $aRet[0] & ']')
If @error Then Return SetError(@error + 20, @extended, 0)
_WinAPI_MoveMemory($tData, $aRet[4], 4 * $aRet[0])
Return SetExtended($aRet[0], $tData)
EndFunc
Func _WinAPI_GetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBI, $iUsage)
Local $aResult = DllCall("gdi32.dll", "int", "GetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBI, "uint", $iUsage)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetEnhMetaFile($sFilePath)
Local $aRet = DllCall('gdi32.dll', 'handle', 'GetEnhMetaFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetEnhMetaFileBits($hEmf, ByRef $pBuffer)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 50, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error, @extended, 0)
$aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileBits', 'handle', $hEmf, 'uint', $aRet[0], 'ptr', $pBuffer)
If Not $aRet[0] Then Return SetError(60, 0, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetEnhMetaFileDescription($hEmf)
Local $tData = DllStructCreate('wchar[4096]')
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileDescriptionW', 'handle', $hEmf, 'uint', 4096, 'struct*', $tData)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 20, $aRet[0], 0)
If Not $aRet[0] Then Return 0
Local $aData = _WinAPI_StructToArray($tData)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
If $aData[0] > $i Then
$aResult[$i] = $aData[$i + 1]
Else
$aResult[$i] = ''
EndIf
Next
Return $aResult
EndFunc
Func _WinAPI_GetEnhMetaFileDimension($hEmf)
Local $tENHMETAHEADER = _WinAPI_GetEnhMetaFileHeader($hEmf)
If @error Then Return SetError(@error, @extended, 0)
Local $tSIZE = DllStructCreate($tagSIZE)
DllStructSetData($tSIZE, 1, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 3) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 1)) * DllStructGetData($tENHMETAHEADER, 'Device', 1) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 1) / 100))
DllStructSetData($tSIZE, 2, Round((DllStructGetData($tENHMETAHEADER, 'rcFrame', 4) - DllStructGetData($tENHMETAHEADER, 'rcFrame', 2)) * DllStructGetData($tENHMETAHEADER, 'Device', 2) / DllStructGetData($tENHMETAHEADER, 'Millimeters', 2) / 100))
Return $tSIZE
EndFunc
Func _WinAPI_GetEnhMetaFileHeader($hEmf)
Local $tENHMETAHEADER = DllStructCreate($tagENHMETAHEADER)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetEnhMetaFileHeader', 'handle', $hEmf,  'uint', DllStructGetSize($tENHMETAHEADER), 'struct*', $tENHMETAHEADER)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended($aRet[0], $tENHMETAHEADER)
EndFunc
Func _WinAPI_GetFontName($sFaceName, $iStyle = 0, $iCharSet = 1)
If Not $sFaceName Then Return SetError(1, 0, '')
Local $iFlags = 0
If BitAND($iStyle, 0x01) Then
$iFlags += 0x00000020
EndIf
If BitAND($iStyle, 0x02) Then
$iFlags += 0x00000001
EndIf
If Not $iFlags Then
$iFlags = 0x00000040
EndIf
Local $tLOGFONT = DllStructCreate($tagLOGFONT)
DllStructSetData($tLOGFONT, 9, $iCharSet)
DllStructSetData($tLOGFONT, 13, 0)
DllStructSetData($tLOGFONT, 14, StringLeft($sFaceName, 31))
Local $tFN = DllStructCreate('dword;wchar[64]')
DllStructSetData($tFN, 1, $iFlags)
DllStructSetData($tFN, 2, '')
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hEnumProc = DllCallbackRegister('__EnumFontStylesProc', 'int', 'ptr;ptr;dword;lparam')
Local $sRet = ''
Local $aRet = DllCall('gdi32.dll', 'int', 'EnumFontFamiliesExW', 'handle', $hDC, 'struct*', $tLOGFONT,  'ptr', DllCallbackGetPtr($hEnumProc), 'struct*', $tFN, 'dword', 0)
If Not @error And Not $aRet[0] Then $sRet = DllStructGetData($tFN, 2)
DllCallbackFree($hEnumProc)
_WinAPI_DeleteDC($hDC)
If Not $sRet Then Return SetError(2, 0, '')
Return $sRet
EndFunc
Func _WinAPI_GetFontResourceInfo($sFont, $bForce = False, $iFlag = Default)
If $iFlag = Default Then
If $bForce Then
If Not _WinAPI_AddFontResourceEx($sFont, $FR_NOT_ENUM) Then Return SetError(@error + 20, @extended, '')
EndIf
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetFontResourceInfoW', 'wstr', $sFont, 'dword*', 4096, 'wstr', '', 'dword', 0x01)
If @error Or Not $aRet[0] Then $iError = @error + 10
If $bForce Then
_WinAPI_RemoveFontResourceEx($sFont, $FR_NOT_ENUM)
EndIf
If $iError Then Return SetError($iError, 0, '')
Return $aRet[3]
Else
If Not FileExists($sFont) Then
$sFont = RegRead("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $sFont
If Not FileExists($sFont) Then Return SetError(31, 0, "")
EndIf
Local Const $hFile = _WinAPI_CreateFile($sFont, 2, 2, 2)
If Not $hFile Then Return SetError(32, _WinAPI_GetLastError(), "")
Local Const $iFile = FileGetSize($sFont)
Local Const $tBuffer = DllStructCreate("byte[" & $iFile + 1 & "]")
Local Const $pFile = DllStructGetPtr($tBuffer)
Local $iRead
_WinAPI_ReadFile($hFile, $pFile, $iFile, $iRead)
_WinAPI_CloseHandle($hFile)
Local $sTTFName = _WinAPI_GetFontMemoryResourceInfo($pFile, $iFlag)
If @error Then
If @error = 1 And $iFlag = 4 Then
$sTTFName = _WinAPI_GetFontResourceInfo($sFont, True)
Return SetError(@error, @extended, $sTTFName)
EndIf
Return SetError(33, @error, "")
EndIf
Return $sTTFName
EndIf
EndFunc
Func _WinAPI_GetFontMemoryResourceInfo($pMemory, $iFlag = 1)
Local Const $tagTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
Local Const $tagTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
Local Const $tagTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
Local Const $tagTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
Local $tTTOffsetTable = DllStructCreate($tagTT_OFFSET_TABLE, $pMemory)
Local $iNumOfTables = _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uNumOfTables"))
If Not (_WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMajorVersion")) = 1 And _WinAPI_SwapWord(DllStructGetData($tTTOffsetTable, "uMinorVersion")) = 0) Then Return SetError(1, 0, "")
Local $iTblDirSize = DllStructGetSize(DllStructCreate($tagTT_TABLE_DIRECTORY))
Local $bFound = False, $iOffset, $tTblDir
For $i = 0 To $iNumOfTables - 1
$tTblDir = DllStructCreate($tagTT_TABLE_DIRECTORY, $pMemory + DllStructGetSize($tTTOffsetTable) + $i * $iTblDirSize)
If StringLeft(DllStructGetData($tTblDir, "szTag"), 4) = "name" Then
$bFound = True
$iOffset = _WinAPI_SwapDWord(DllStructGetData($tTblDir, "uOffset"))
ExitLoop
EndIf
Next
If Not $bFound Then Return SetError(2, 0, "")
Local $tNTHeader = DllStructCreate($tagTT_NAME_TABLE_HEADER, $pMemory + $iOffset)
Local $iNTHeaderSize = DllStructGetSize($tNTHeader)
Local $iNRCount = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uNRCount"))
Local $iStorageOffset = _WinAPI_SwapWord(DllStructGetData($tNTHeader, "uStorageOffset"))
Local $iTTRecordSize = DllStructGetSize(DllStructCreate($tagTT_NAME_RECORD))
Local $tResult, $sResult, $iStringLength, $iStringOffset, $iEncodingID, $tTTRecord
For $i = 0 To $iNRCount - 1
$tTTRecord = DllStructCreate($tagTT_NAME_RECORD, $pMemory + $iOffset + $iNTHeaderSize + $i * $iTTRecordSize)
If _WinAPI_SwapWord($tTTRecord.uNameID) = $iFlag Then
$iStringLength = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringLength"))
$iStringOffset = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uStringOffset"))
$iEncodingID = _WinAPI_SwapWord(DllStructGetData($tTTRecord, "uEncodingID"))
Local $sWchar = "char"
If $iEncodingID = 1 Then
$sWchar = "word"
$iStringLength = $iStringLength / 2
EndIf
$tResult = DllStructCreate($sWchar & " szTTFName[" & $iStringLength & "]", $pMemory + $iOffset + $iStringOffset + $iStorageOffset)
If $iEncodingID = 1 Then
$sResult = ""
For $j = 1 To $iStringLength
$sResult &= ChrW(_WinAPI_SwapWord(DllStructGetData($tResult, 1, $j)))
Next
Else
$sResult = $tResult.szTTFName
EndIf
If StringLen($sResult) > 0 Then ExitLoop
EndIf
Next
Return $sResult
EndFunc
Func _WinAPI_GetGlyphOutline($hDC, $sChar, $iFormat, ByRef $pBuffer, $tMAT2 = 0)
Local $tGM = DllStructCreate($tagGLYPHMETRICS)
Local $aRet, $iLength = 0
If Not IsDllStruct($tMAT2) Then
$tMAT2 = DllStructCreate('short[8]')
DllStructSetData($tMAT2, 1, 1, 2)
DllStructSetData($tMAT2, 1, 1, 8)
EndIf
If $iFormat Then
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', 0, 'ptr', 0, 'struct*', $tMAT2)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error + 10, @extended, 0)
$iLength = $aRet[0]
$pBuffer = __HeapReAlloc($pBuffer, $iLength, 1)
If @error Then Return SetError(@error + 20, @extended, 0)
EndIf
$aRet = DllCall('gdi32.dll', 'dword', 'GetGlyphOutlineW', 'handle', $hDC, 'uint', AscW($sChar), 'uint', $iFormat,  'struct*', $tGM, 'dword', $iLength, 'ptr', $pBuffer, 'struct*', $tMAT2)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return SetExtended($iLength, $tGM)
EndFunc
Func _WinAPI_GetGraphicsMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetGraphicsMode', 'handle', $hDC)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetGValue($iRGB)
Return BitShift(BitAND(__RGB($iRGB), 0x00FF00), 8)
EndFunc
Func _WinAPI_GetMapMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetMapMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetMonitorInfo($hMonitor)
Local $tMIEX = DllStructCreate('dword;long[4];long[4];dword;wchar[32]')
DllStructSetData($tMIEX, 1, DllStructGetSize($tMIEX))
Local $aRet = DllCall('user32.dll', 'bool', 'GetMonitorInfoW', 'handle', $hMonitor, 'struct*', $tMIEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[4]
For $i = 0 To 1
$aResult[$i] = DllStructCreate($tagRECT)
_WinAPI_MoveMemory($aResult[$i], DllStructGetPtr($tMIEX, $i + 2), 16)
Next
$aResult[3] = DllStructGetData($tMIEX, 5)
Switch DllStructGetData($tMIEX, 4)
Case 1
$aResult[2] = 1
Case Else
$aResult[2] = 0
EndSwitch
Return $aResult
EndFunc
Func _WinAPI_GetOutlineTextMetrics($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $tData = DllStructCreate('byte[' & $aRet[0] & ']')
Local $tOLTM = DllStructCreate($tagOUTLINETEXTMETRIC, DllStructGetPtr($tData))
$aRet = DllCall('gdi32.dll', 'uint', 'GetOutlineTextMetricsW', 'handle', $hDC, 'uint', $aRet[0], 'struct*', $tData)
If Not $aRet[0] Then Return SetError(20, 0, 0)
Return $tOLTM
EndFunc
Func _WinAPI_GetPixel($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetPixel', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_GetPolyFillMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetPolyFillMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPosFromRect($tRECT)
Local $aResult[4]
For $i = 0 To 3
$aResult[$i] = DllStructGetData($tRECT, $i + 1)
If @error Then Return SetError(@error, @extended, 0)
Next
For $i = 2 To 3
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetRegionData($hRgn, ByRef $tRGNDATA)
Local $aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then
$tRGNDATA = 0
Return SetError(@error, @extended, False)
EndIf
$tRGNDATA = DllStructCreate($tagRGNDATAHEADER)
Local $iRectSize = $aRet[0] - DllStructGetSize($tRGNDATA)
If $iRectSize > 0 Then $tRGNDATA = DllStructCreate($tagRGNDATAHEADER & ';byte[' & $iRectSize & ']')
$aRet = DllCall('gdi32.dll', 'dword', 'GetRegionData', 'handle', $hRgn, 'dword', $aRet[0], 'struct*', $tRGNDATA)
If Not $aRet[0] Then $tRGNDATA = 0
Return $aRet[0]
EndFunc
Func _WinAPI_GetRgnBox($hRgn, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetRgnBox', 'handle', $hRgn, 'struct*', $tRECT)
If @error Or Not $aRet[0] Then
$tRECT = 0
Return SetError(@error, @extended, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetROP2($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetROP2', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRValue($iRGB)
Return BitAND(__RGB($iRGB), 0x0000FF)
EndFunc
Func _WinAPI_GetStretchBltMode($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetStretchBltMode', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTabbedTextExtent($hDC, $sText, $aTab = 0, $iStart = 0, $iEnd = -1)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'dword', 'GetTabbedTextExtentW', 'handle', $hDC, 'wstr', $sText, 'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Return _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
EndFunc
Func _WinAPI_GetTextAlign($hDC)
Local $aRet = DllCall('gdi32.dll', 'uint', 'GetTextAlign', 'handle', $hDC)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextCharacterExtra($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextCharacterExtra', 'handle', $hDC)
If @error Or ($aRet[0] = 0x8000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTextFace($hDC)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetTextFaceW', 'handle', $hDC, 'int', 2048, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[3]
EndFunc
Func _WinAPI_GetUDFColorMode()
Return Number($__g_iRGBMode)
EndFunc
Func _WinAPI_GetUpdateRect($hWnd, $bErase = True)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUpdateRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'bool', $bErase)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetUpdateRgn($hWnd, $hRgn, $bErase = True)
Local $aRet = DllCall('user32.dll', 'int', 'GetUpdateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowExt($hDC)
Local $tSIZE = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowExtEx', 'handle', $hDC, 'struct*', $tSIZE)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tSIZE
EndFunc
Func _WinAPI_GetWindowOrg($hDC)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWindowOrgEx', 'handle', $hDC, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_GetWindowRgnBox($hWnd, ByRef $tRECT)
$tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetWindowRgnBox', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWorldTransform($hDC)
Local $tXFORM = DllStructCreate($tagXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tXFORM
EndFunc
Func _WinAPI_GradientFill($hDC, Const ByRef $aVertex, $iStart = 0, $iEnd = -1, $bRotate = False)
If __CheckErrorArrayBounds($aVertex, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aVertex, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, 0)
Local $iPoint = $iEnd - $iStart + 1
If $iPoint > 3 Then
$iEnd = $iStart + 2
$iPoint = 3
EndIf
Local $iMode
Switch $iPoint
Case 2
$iMode = Number(Not $bRotate)
Case 3
$iMode = 2
Case Else
Return SetError(15, 0, 0)
EndSwitch
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'ushort[8];'
Next
Local $tVertex = DllStructCreate($tagStruct)
Local $iCount = 1
Local $tGradient = DllStructCreate('ulong[' & $iPoint & ']')
For $i = $iStart To $iEnd
DllStructSetData($tGradient, 1, $iCount - 1, $iCount)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][0]), 1)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][0]), 2)
DllStructSetData($tVertex, $iCount, _WinAPI_LoWord($aVertex[$i][1]), 3)
DllStructSetData($tVertex, $iCount, _WinAPI_HiWord($aVertex[$i][1]), 4)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetRValue($aVertex[$i][2]), -8), 5)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetGValue($aVertex[$i][2]), -8), 6)
DllStructSetData($tVertex, $iCount, BitShift(_WinAPI_GetBValue($aVertex[$i][2]), -8), 7)
DllStructSetData($tVertex, $iCount, 0, 8)
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiGradientFill', 'handle', $hDC, 'struct*', $tVertex, 'ulong', $iPoint,  'struct*', $tGradient, 'ulong', 1, 'ulong', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_InflateRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'InflateRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectClipRect($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'int', 'IntersectClipRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_IntersectRect($tRECT1, $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IntersectRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InvalidateRgn($hWnd, $hRgn = 0, $bErase = True)
Local $aRet = DllCall('user32.dll', 'bool', 'InvalidateRgn', 'hwnd', $hWnd, 'handle', $hRgn, 'bool', $bErase)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertANDBitmap($hBitmap, $bDelete = False)
Local $tBITMAP = DllStructCreate($tagBITMAP)
If Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tBITMAP), $tBITMAP) Or (DllStructGetData($tBITMAP, 'bmBitsPixel') <> 1) Then
Return SetError(@error + 10, @extended, 0)
EndIf
Local $hResult = _WinAPI_CreateDIB(DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), 1)
If Not $hResult Then Return SetError(@error, @extended, 0)
Local $hSrcDC = _WinAPI_CreateCompatibleDC(0)
Local $hSrcSv = _WinAPI_SelectObject($hSrcDC, $hBitmap)
Local $hDstDC = _WinAPI_CreateCompatibleDC(0)
Local $hDstSv = _WinAPI_SelectObject($hDstDC, $hResult)
_WinAPI_BitBlt($hDstDC, 0, 0, DllStructGetData($tBITMAP, 'bmWidth'), DllStructGetData($tBITMAP, 'bmHeight'), $hSrcDC, 0, 0, 0x00330008)
_WinAPI_SelectObject($hSrcDC, $hSrcSv)
_WinAPI_DeleteDC($hSrcDC)
_WinAPI_SelectObject($hDstDC, $hDstSv)
_WinAPI_DeleteDC($hDstDC)
If $bDelete Then
_WinAPI_DeleteObject($hBitmap)
EndIf
Return $hResult
EndFunc
Func _WinAPI_InvertColor($iColor)
If $iColor = -1 Then Return 0
Return 0xFFFFFF - BitAND($iColor, 0xFFFFFF)
EndFunc
Func _WinAPI_InvertRect($hDC, ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'InvertRect', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_InvertRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'InvertRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsRectEmpty(ByRef $tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'IsRectEmpty', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LineDDA($iX1, $iY1, $iX2, $iY2, $pLineProc, $pData = 0)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LineDDA', 'int', $iX1, 'int', $iY1, 'int', $iX2, 'int', $iY2, 'ptr', $pLineProc,  'lparam', $pData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LineTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "LineTo", "handle", $hDC, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_LockWindowUpdate($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'LockWindowUpdate', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LPtoDP($hDC, ByRef $tPOINT, $iCount = 1)
Local $aRet = DllCall('gdi32.dll', 'bool', 'LPtoDP', 'handle', $hDC, 'struct*', $tPOINT, 'int', $iCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MaskBlt($hDestDC, $iXDest, $iYDest, $iWidth, $iHeight, $hSrcDC, $iXSrc, $iYSrc, $hMask, $iXMask, $iYMask, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MaskBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidth, 'int', $iHeight, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ModifyWorldTransform($hDC, ByRef $tXFORM, $iMode)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ModifyWorldTransform', 'handle', $hDC, 'struct*', $tXFORM, 'dword', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromPoint(ByRef $tPOINT, $iFlag = 1)
If DllStructGetSize($tPOINT) <> 8 Then Return SetError(@error + 10, @extended, 0)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromPoint', 'struct', $tPOINT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromRect(ByRef $tRECT, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'ptr', 'MonitorFromRect', 'struct*', $tRECT, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MonitorFromWindow($hWnd, $iFlag = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'MonitorFromWindow', 'hwnd', $hWnd, 'dword', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_MoveTo($hDC, $iX, $iY)
Local $aResult = DllCall("gdi32.dll", "bool", "MoveToEx", "handle", $hDC, "int", $iX, "int", $iY, "ptr", 0)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_MoveToEx($hDC, $iX, $iY)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'MoveToEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_OffsetClipRgn($hDC, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetClipRgn', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetPoints(ByRef $aPoint, $iXOffset, $iYOffset, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
For $i = $iStart To $iEnd
$aPoint[$i][0] += $iXOffset
$aPoint[$i][1] += $iYOffset
Next
Return 1
EndFunc
Func _WinAPI_OffsetRect(ByRef $tRECT, $iDX, $iDY)
Local $aRet = DllCall('user32.dll', 'bool', 'OffsetRect', 'struct*', $tRECT, 'int', $iDX, 'int', $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetRgn($hRgn, $iXOffset, $iYOffset)
Local $aRet = DllCall('gdi32.dll', 'int', 'OffsetRgn', 'handle', $hRgn, 'int', $iXOffset, 'int', $iYOffset)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OffsetWindowOrg($hDC, $iXOffset, $iYOffset)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'OffsetWindowOrgEx', 'handle', $hDC, 'int', $iXOffset, 'int', $iYOffset,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintDesktop($hDC)
Local $aRet = DllCall('user32.dll', 'bool', 'PaintDesktop', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PaintRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PaintRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PatBlt($hDC, $iX, $iY, $iWidth, $iHeight, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PatBlt', 'handle', $hDC, 'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight,  'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PathToRegion($hDC)
Local $aRet = DllCall('gdi32.dll', 'handle', 'PathToRegion', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PlayEnhMetaFile($hDC, $hEmf, ByRef $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlayEnhMetaFile', 'handle', $hDC, 'handle', $hEmf, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PlgBlt($hDestDC, Const ByRef $aPoint, $hSrcDC, $iXSrc, $iYSrc, $iWidth, $iHeight, $hMask = 0, $iXMask = 0, $iYMask = 0)
If (UBound($aPoint) < 3) Or (UBound($aPoint, $UBOUND_COLUMNS) < 2) Then Return SetError(12, 0, False)
Local $tPoints = DllStructCreate('long[2];long[2];long[2]')
For $i = 0 To 2
For $j = 0 To 1
DllStructSetData($tPoints, $i + 1, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PlgBlt', 'handle', $hDestDC, 'struct*', $tPoints, 'handle', $hSrcDC,  'int', $iXSrc, 'int', $iYSrc, 'int', $iWidth, 'int', $iHeight, 'handle', $hMask,  'int', $iXMask, 'int', $iYMask)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezier($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 1 + 3 * Floor(($iEnd - $iStart) / 3)
If $iPoint < 1 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezier', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyBezierTo($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $iPoint = 3 * Floor(($iEnd - $iStart + 1) / 3)
If $iPoint < 3 Then Return SetError(15, 0, False)
$iEnd = $iStart + $iPoint - 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyBezierTo', 'handle', $hDC, 'struct*', $tPOINT, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PolyDraw($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 3 Then Return SetError(13, 0, False)
Local $iPoint = $iEnd - $iStart + 1
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'long[2];'
Next
Local $tPOINT = DllStructCreate($tagStruct)
Local $tTypes = DllStructCreate('byte[' & $iPoint & ']')
Local $iCount = 0
For $i = $iStart To $iEnd
$iCount += 1
For $j = 0 To 1
DllStructSetData($tPOINT, $iCount, $aPoint[$i][$j], $j + 1)
Next
DllStructSetData($tTypes, 1, $aPoint[$i][2], $iCount)
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'PolyDraw', 'handle', $hDC, 'struct*', $tPOINT, 'struct*', $tTypes, 'dword', $iPoint)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Polygon($hDC, Const ByRef $aPoint, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2, 2) Then Return SetError(@error + 10, @extended, False)
Local $tagStruct = ''
For $i = $iStart To $iEnd
$tagStruct &= 'int[2];'
Next
Local $tData = DllStructCreate($tagStruct)
Local $iCount = 1
For $i = $iStart To $iEnd
For $j = 0 To 1
DllStructSetData($tData, $iCount, $aPoint[$i][$j], $j + 1)
Next
$iCount += 1
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'Polygon', 'handle', $hDC, 'struct*', $tData, 'int', $iCount - 1)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRectEx($iX, $iY, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = _WinAPI_CreateRect($iLeft, $iTop, $iRight, $iBottom)
Local $tPOINT = _WinAPI_CreatePoint($iX, $iY)
Local $aRet = DllCall('user32.dll', 'bool', 'PtInRect', 'struct*', $tRECT, 'struct', $tPOINT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtInRegion($hRgn, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtInRegion', 'handle', $hRgn, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_PtVisible($hDC, $iX, $iY)
Local $aRet = DllCall('gdi32.dll', 'bool', 'PtVisible', 'handle', $hDC, 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = -1 Then Return SetError(10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RadialGradientFill($hDC, $iX, $iY, $iRadius, $iRGB1, $iRGB2, $fAngleStart = 0, $fAngleEnd = 360, $fStep = 5)
If Abs($fAngleStart) > 360 Then
$fAngleStart = Mod($fAngleStart, 360)
EndIf
If Abs($fAngleEnd) > 360 Then
$fAngleEnd = Mod($fAngleEnd, 360)
EndIf
If ($fAngleStart < 0) Or ($fAngleEnd < 0) Then
$fAngleStart += 360
$fAngleEnd += 360
EndIf
If $fAngleStart > $fAngleEnd Then
Local $fVal = $fAngleStart
$fAngleStart = $fAngleEnd
$fAngleEnd = $fVal
EndIf
If $fStep < 1 Then
$fStep = 1
EndIf
Local $fKi = ATan(1) / 45
Local $iXp = Round($iX + $iRadius * Cos($fKi * $fAngleStart))
Local $iYp = Round($iY + $iRadius * Sin($fKi * $fAngleStart))
Local $iXn, $iYn, $fAn = $fAngleStart
Local $aVertex[3][3]
While $fAn < $fAngleEnd
$fAn += $fStep
If $fAn > $fAngleEnd Then
$fAn = $fAngleEnd
EndIf
$iXn = Round($iX + $iRadius * Cos($fKi * $fAn))
$iYn = Round($iY + $iRadius * Sin($fKi * $fAn))
$aVertex[0][0] = $iX
$aVertex[0][1] = $iY
$aVertex[0][2] = $iRGB1
$aVertex[1][0] = $iXp
$aVertex[1][1] = $iYp
$aVertex[1][2] = $iRGB2
$aVertex[2][0] = $iXn
$aVertex[2][1] = $iYn
$aVertex[2][2] = $iRGB2
If Not _WinAPI_GradientFill($hDC, $aVertex, 0, 2) Then
Return SetError(@error, @extended, 0)
EndIf
$iXp = $iXn
$iYp = $iYn
WEnd
Return 1
EndFunc
Func _WinAPI_Rectangle($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'Rectangle', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RectInRegion($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectInRegion', 'handle', $hRgn, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RectIsEmpty(ByRef $tRECT)
Return (DllStructGetData($tRECT, "Left") = 0) And (DllStructGetData($tRECT, "Top") = 0) And  (DllStructGetData($tRECT, "Right") = 0) And (DllStructGetData($tRECT, "Bottom") = 0)
EndFunc
Func _WinAPI_RectVisible($hDC, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RectVisible', 'handle', $hDC, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Switch $aRet[0]
Case 0, 1, 2
Case Else
Return SetError(10, $aRet[0], 0)
EndSwitch
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontMemResourceEx($hFont)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontMemResourceEx', 'handle', $hFont)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RemoveFontResourceEx($sFont, $iFlag = 0, $bNotify = False)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RemoveFontResourceExW', 'wstr', $sFont, 'dword', $iFlag, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, False)
If $bNotify Then
Local Const $WM_FONTCHANGE = 0x001D
Local Const $HWND_BROADCAST = 0xFFFF
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $HWND_BROADCAST, 'uint', $WM_FONTCHANGE, 'wparam', 0, 'lparam', 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_RGB($iRed, $iGreen, $iBlue)
Return __RGB(BitOR(BitShift($iBlue, -16), BitShift($iGreen, -8), $iRed))
EndFunc
Func _WinAPI_RotatePoints(ByRef $aPoint, $iXC, $iYC, $fAngle, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aPoint, $iStart, $iEnd, 2) Then Return SetError(@error + 10, @extended, 0)
If UBound($aPoint, $UBOUND_COLUMNS) < 2 Then Return SetError(13, 0, 0)
Local $fCos = Cos(ATan(1) / 45 * $fAngle)
Local $fSin = Sin(ATan(1) / 45 * $fAngle)
Local $iXn, $iYn
For $i = $iStart To $iEnd
$iXn = $aPoint[$i][0] - $iXC
$iYn = $aPoint[$i][1] - $iYC
$aPoint[$i][0] = $iXC + Round($iXn * $fCos - $iYn * $fSin)
$aPoint[$i][1] = $iYC + Round($iXn * $fSin + $iYn * $fCos)
Next
Return 1
EndFunc
Func _WinAPI_RoundRect($hDC, $tRECT, $iWidth, $iHeight)
Local $aRet = DllCall('gdi32.dll', 'bool', 'RoundRect', 'handle', $hDC, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3),  'int', DllStructGetData($tRECT, 4), 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SaveHBITMAPToFile($sFilePath, $hBitmap, $iXPelsPerMeter = Default, $iYPelsPerMeter = Default)
Local $tBMP = DllStructCreate('align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset')
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $hDC, $hSv, $hSource = 0
While $hBitmap
If (Not _WinAPI_GetObject($hBitmap, DllStructGetSize($tDIB), $tDIB)) Or (DllStructGetData($tDIB, 'biCompression')) Then
$hBitmap = 0
Else
Switch DllStructGetData($tDIB, 'bmBitsPixel')
Case 32
If Not _WinAPI_IsAlphaBitmap($hBitmap) Then
If Not $hSource Then
$hSource = _WinAPI_CreateDIB(DllStructGetData($tDIB, 'bmWidth'), DllStructGetData($tDIB, 'bmHeight'), 24)
If Not $hSource Then
$hBitmap = 0
EndIf
$hDC = _WinAPI_CreateCompatibleDC(0)
$hSv = _WinAPI_SelectObject($hDC, $hSource)
If _WinAPI_DrawBitmap($hDC, 0, 0, $hBitmap) Then
$hBitmap = $hSource
Else
$hBitmap = 0
EndIf
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
Else
$hBitmap = 0
EndIf
ContinueLoop
EndIf
Case Else
EndSwitch
If (Not DllStructGetData($tDIB, 'bmBits')) Or (Not DllStructGetData($tDIB, 'biSizeImage')) Then
If Not $hSource Then
$hBitmap = _WinAPI_CopyBitmap($hBitmap)
$hSource = $hBitmap
Else
$hBitmap = 0
EndIf
Else
ExitLoop
EndIf
EndIf
WEnd
Local $hFile = 0, $iError = 0, $iResult = 0
Do
If Not $hBitmap Then
$iError = 1
ExitLoop
EndIf
Local $aData[4][2]
$aData[0][0] = DllStructGetPtr($tBMP)
$aData[0][1] = DllStructGetSize($tBMP)
$aData[1][0] = DllStructGetPtr($tDIB, 'biSize')
$aData[1][1] = 40
$aData[2][1] = DllStructGetData($tDIB, 'biClrUsed') * 4
Local $tTable = 0
If $aData[2][1] Then
$tTable = _WinAPI_GetDIBColorTable($hBitmap)
If @error Or (@extended <> $aData[2][1] / 4) Then
$iError = @error + 10
ExitLoop
EndIf
EndIf
$aData[2][0] = DllStructGetPtr($tTable)
$aData[3][0] = DllStructGetData($tDIB, 'bmBits')
$aData[3][1] = DllStructGetData($tDIB, 'biSizeImage')
DllStructSetData($tBMP, 'bfType', 0x4D42)
DllStructSetData($tBMP, 'bfSize', $aData[0][1] + $aData[1][1] + $aData[2][1] + $aData[3][1])
DllStructSetData($tBMP, 'bfReserved1', 0)
DllStructSetData($tBMP, 'bfReserved2', 0)
DllStructSetData($tBMP, 'bfOffset', $aData[0][1] + $aData[1][1] + $aData[2][1])
$hDC = _WinAPI_GetDC(0)
If $iXPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biXPelsPerMeter') Then
DllStructSetData($tDIB, 'biXPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 8) / _WinAPI_GetDeviceCaps($hDC, 4) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biXPelsPerMeter', $iXPelsPerMeter)
EndIf
If $iYPelsPerMeter = Default Then
If Not DllStructGetData($tDIB, 'biYPelsPerMeter') Then
DllStructSetData($tDIB, 'biYPelsPerMeter', _WinAPI_GetDeviceCaps($hDC, 10) / _WinAPI_GetDeviceCaps($hDC, 6) * 1000)
EndIf
Else
DllStructSetData($tDIB, 'biYPelsPerMeter', $iYPelsPerMeter)
EndIf
_WinAPI_ReleaseDC(0, $hDC)
$hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then
$iError = @error + 20
ExitLoop
EndIf
Local $iBytes
For $i = 0 To 3
If $aData[$i][1] Then
If Not _WinAPI_WriteFile($hFile, $aData[$i][0], $aData[$i][1], $iBytes) Then
$iError = @error + 30
ExitLoop 2
EndIf
EndIf
Next
$iResult = 1
Until 1
If $hSource Then
_WinAPI_DeleteObject($hSource)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_SaveHICONToFile($sFilePath, Const ByRef $vIcon, $bCompress = 0, $iStart = 0, $iEnd = -1)
Local $aIcon, $aTemp, $iCount = 1
If Not IsArray($vIcon) Then
Dim $aIcon[1] = [$vIcon]
Dim $aTemp[1] = [0]
Else
If __CheckErrorArrayBounds($vIcon, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
If $iCount Then
Dim $aIcon[$iCount]
Dim $aTemp[$iCount]
For $i = 0 To $iCount - 1
$aIcon[$i] = $vIcon[$iStart + $i]
$aTemp[$i] = 0
Next
EndIf
EndIf
Local $hFile = _WinAPI_CreateFile($sFilePath, 1, 4)
If @error Then Return SetError(@error + 20, @extended, 0)
Local $tIco = DllStructCreate('align 1;ushort Reserved;ushort Type;ushort Count;byte Data[' & (16 * $iCount) & ']')
Local $iLength = DllStructGetSize($tIco)
Local $tBI = DllStructCreate($tagBITMAPINFOHEADER)
Local $tII = DllStructCreate($tagICONINFO)
Local $tDIB = DllStructCreate($tagDIBSECTION)
Local $iDIB = DllStructGetSize($tDIB)
Local $pDIB = DllStructGetPtr($tDIB)
Local $iOffset = $iLength
DllStructSetData($tBI, 'biSize', 40)
DllStructSetData($tBI, 'biPlanes', 1)
DllStructSetData($tBI, 'biXPelsPerMeter', 0)
DllStructSetData($tBI, 'biYPelsPerMeter', 0)
DllStructSetData($tBI, 'biClrUsed', 0)
DllStructSetData($tBI, 'biClrImportant', 0)
DllStructSetData($tIco, 'Reserved', 0)
DllStructSetData($tIco, 'Type', 1)
DllStructSetData($tIco, 'Count', $iCount)
Local $iResult = 0, $iError = 0, $iBytes
Local $aInfo[8], $aRet, $pData = 0, $iIndex = 0
Local $aSize[2], $tData = 0
Do
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 30
ExitLoop
EndIf
While $iCount > $iIndex
$aRet = DllCall('user32.dll', 'bool', 'GetIconInfo', 'handle', $aIcon[$iIndex], 'struct*', $tII)
If @error Or Not $aRet[0] Then
$iError = @error + 40
ExitLoop 2
EndIf
For $i = 4 To 5
$aInfo[$i] = _WinAPI_CopyImage(DllStructGetData($tII, $i), 0, 0, 0, 0x2008)
If _WinAPI_GetObject($aInfo[$i], $iDIB, $pDIB) Then
$aInfo[$i - 4] = DllStructGetData($tDIB, 'biSizeImage')
$aInfo[$i - 2] = DllStructGetData($tDIB, 'bmBits')
Else
$iError = @error + 50
EndIf
Next
$aInfo[6] = 40
$aInfo[7] = DllStructGetData($tDIB, 'bmBitsPixel')
Switch $aInfo[7]
Case 16, 24
Case 32
If Not _WinAPI_IsAlphaBitmap($aInfo[5]) Then
If Not $aTemp[$iIndex] Then
$aIcon[$iIndex] = _WinAPI_Create32BitHICON($aIcon[$iIndex])
$aTemp[$iIndex] = $aIcon[$iIndex]
If Not @error Then
ContinueLoop
Else
ContinueCase
EndIf
EndIf
Else
If ($aInfo[1] >= 256 * 256 * 4) And ($bCompress) Then
$iBytes = _WinAPI_CompressBitmapBits($aInfo[5], $pData)
If Not @error Then
$aInfo[0] = 0
$aInfo[1] = $iBytes
$aInfo[2] = 0
$aInfo[3] = $pData
$aInfo[6] = 0
EndIf
EndIf
EndIf
Case Else
$iError = 60
EndSwitch
If Not $iError Then
$tData = DllStructCreate('byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset', DllStructGetPtr($tIco) + 6 + 16 * $iIndex)
DllStructSetData($tData, 'ColorCount', 0)
DllStructSetData($tData, 'Reserved', 0)
DllStructSetData($tData, 'Planes', 1)
DllStructSetData($tData, 'BitCount', $aInfo[7])
DllStructSetData($tData, 'Size', $aInfo[0] + $aInfo[1] + $aInfo[6])
DllStructSetData($tData, 'Offset', $iOffset)
For $i = 0 To 1
$aSize[$i] = DllStructGetData($tDIB, $i + 2)
If $aSize[$i] < 256 Then
DllStructSetData($tData, $i + 1, $aSize[$i])
Else
DllStructSetData($tData, $i + 1, 0)
EndIf
Next
DllStructSetData($tBI, 'biWidth', $aSize[0])
DllStructSetData($tBI, 'biHeight', 2 * $aSize[1])
DllStructSetData($tBI, 'biBitCount', $aInfo[7])
DllStructSetData($tBI, 'biCompression', 0)
DllStructSetData($tBI, 'biSizeImage', $aInfo[0] + $aInfo[1])
$iOffset += $aInfo[0] + $aInfo[1] + $aInfo[6]
Do
If $aInfo[6] Then
If Not _WinAPI_WriteFile($hFile, $tBI, $aInfo[6], $iBytes) Then
$iError = @error + 70
ExitLoop
EndIf
For $i = 1 To 0 Step -1
If Not _WinAPI_WriteFile($hFile, $aInfo[$i + 2], $aInfo[$i], $iBytes) Then
$iError = @error + 80
ExitLoop 2
EndIf
Next
Else
If Not _WinAPI_WriteFile($hFile, $aInfo[3], $aInfo[1], $iBytes) Then
$iError = @error + 90
ExitLoop
EndIf
EndIf
Until 1
EndIf
For $i = 4 To 5
_WinAPI_DeleteObject($aInfo[$i])
Next
If $iError Then
ExitLoop 2
EndIf
$iIndex += 1
WEnd
$aRet = DllCall('kernel32.dll', 'bool', 'SetFilePointerEx', 'handle', $hFile, 'int64', 0, 'int64*', 0, 'dword', 0)
If @error Or Not $aRet[0] Then
$iError = @error + 100
ExitLoop
EndIf
If Not _WinAPI_WriteFile($hFile, $tIco, $iLength, $iBytes) Then
$iError = @error + 110
ExitLoop
EndIf
$iResult = 1
Until 1
For $i = 0 To $iCount - 1
If $aTemp[$i] Then
_WinAPI_DestroyIcon($aTemp[$i])
EndIf
Next
If $pData Then
__HeapFree($pData)
EndIf
_WinAPI_CloseHandle($hFile)
If Not $iResult Then
FileDelete($sFilePath)
EndIf
Return SetError($iError, 0, $iResult)
EndFunc
Func _WinAPI_ScaleWindowExt($hDC, $iXNum, $iXDenom, $iYNum, $iYDenom)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'ScaleWindowExtEx', 'handle', $hDC, 'int', $iXNum, 'int', $iXDenom, 'int', $iYNum,  'int', $iYDenom, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipPath($hDC, $iMode = 5)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SelectClipPath', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SelectClipRgn($hDC, $hRgn)
Local $aRet = DllCall('gdi32.dll', 'int', 'SelectClipRgn', 'handle', $hDC, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetArcDirection($hDC, $iDirection)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetArcDirection', 'handle', $hDC, 'int', $iDirection)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapBits($hBitmap, $iSize, $pBits)
Local $aRet = DllCall('gdi32.dll', 'long', 'SetBitmapBits', 'handle', $hBitmap, 'dword', $iSize, 'struct*', $pBits)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBitmapDimensionEx($hBitmap, $iWidth, $iHeight)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBitmapDimensionEx', 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBoundsRect($hDC, $iFlags, $tRECT = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetBoundsRect', 'handle', $hDC, 'struct*', $tRECT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetBrushOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetBrushOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetColorAdjustment($hDC, $tAdjustment)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetColorAdjustment', 'handle', $hDC, 'struct*', $tAdjustment)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDCBrushColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCBrushColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDCPenColor($hDC, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'dword', 'SetDCPenColor', 'handle', $hDC, 'dword', __RGB($iRGB))
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return __RGB($aRet[0])
EndFunc
Func _WinAPI_SetDeviceGammaRamp($hDC, Const ByRef $aRamp)
If (UBound($aRamp, $UBOUND_DIMENSIONS) <> 2) Or (UBound($aRamp, $UBOUND_ROWS) <> 256) Or (UBound($aRamp, $UBOUND_COLUMNS) <> 3) Then
Return SetError(12, 0, 0)
EndIf
Local $tData = DllStructCreate('ushort[256];ushort[256];ushort[256]')
For $i = 0 To 2
For $j = 0 To 255
DllStructSetData($tData, $i + 1, $aRamp[$j][$i], $j + 1)
Next
Next
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetDeviceGammaRamp', 'handle', $hDC, 'struct*', $tData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBColorTable($hBitmap, $tColorTable, $iColorCount)
If $iColorCount > DllStructGetSize($tColorTable) / 4 Then Return SetError(1, 0, 0)
Local $hDC = _WinAPI_CreateCompatibleDC(0)
Local $hSv = _WinAPI_SelectObject($hDC, $hBitmap)
Local $iError = 0
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetDIBColorTable', 'handle', $hDC, 'uint', 0, 'uint', $iColorCount, 'struct*', $tColorTable)
If @error Then $iError = @error
_WinAPI_SelectObject($hDC, $hSv)
_WinAPI_DeleteDC($hDC)
If $iError Then Return SetError($iError, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetDIBits($hDC, $hBitmap, $iStartScan, $iScanLines, $pBits, $tBMI, $iColorUse = 0)
Local $aResult = DllCall("gdi32.dll", "int", "SetDIBits", "handle", $hDC, "handle", $hBitmap, "uint", $iStartScan,  "uint", $iScanLines, "struct*", $pBits, "struct*", $tBMI, "INT", $iColorUse)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDIBitsToDevice($hDC, $iXDest, $iYDest, $iWidth, $iHeight, $iXSrc, $iYSrc, $iStartScan, $iScanLines, $tBITMAPINFO, $iUsage, $pBits)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetDIBitsToDevice', 'handle', $hDC, 'int', $iXDest, 'int', $iYDest,  'dword', $iWidth, 'dword', $iHeight, 'int', $iXSrc, 'int', $iYSrc, 'uint', $iStartScan,  'uint', $iScanLines, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetEnhMetaFileBits($pData, $iLength)
Local $aRet = DllCall('gdi32.dll', 'handle', 'SetEnhMetaFileBits', 'uint', $iLength, 'struct*', $pData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetGraphicsMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetGraphicsMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetMapMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetMapMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPixel($hDC, $iX, $iY, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetPixelV', 'handle', $hDC, 'int', $iX, 'int', $iY, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetPolyFillMode($hDC, $iMode = 1)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetPolyFillMode', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetRectRgn($hRgn, $tRECT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetRectRgn', 'handle', $hRgn, 'int', DllStructGetData($tRECT, 1),  'int', DllStructGetData($tRECT, 2), 'int', DllStructGetData($tRECT, 3), 'int', DllStructGetData($tRECT, 4))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetROP2($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetROP2', 'handle', $hDC, 'int', $iMode)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetStretchBltMode($hDC, $iMode)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetStretchBltMode', 'handle', $hDC, 'int', $iMode)
If @error Or Not $aRet[0] Or ($aRet[0] = 87) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextAlign($hDC, $iMode = 0)
Local $aRet = DllCall('gdi32.dll', 'uint', 'SetTextAlign', 'handle', $hDC, 'uint', $iMode)
If @error Or ($aRet[0] = 4294967295) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextCharacterExtra($hDC, $iCharExtra)
Local $aRet = DllCall('gdi32.dll', 'int', 'SetTextCharacterExtra', 'handle', $hDC, 'int', $iCharExtra)
If @error Or ($aRet[0] = 0x80000000) Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_SetTextJustification($hDC, $iBreakExtra, $iBreakCount)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetTextJustification', 'handle', $hDC, 'int', $iBreakExtra, 'int', $iBreakCount)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUDFColorMode($iMode)
$__g_iRGBMode = Not ($iMode = 0)
EndFunc
Func _WinAPI_SetWindowExt($hDC, $iXExtent, $iYExtent)
$__g_vExt = DllStructCreate($tagSIZE)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowExtEx', 'handle', $hDC, 'int', $iXExtent, 'int', $iYExtent,  'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowOrg($hDC, $iX, $iY)
$__g_vExt = DllStructCreate($tagPOINT)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWindowOrgEx', 'handle', $hDC, 'int', $iX, 'int', $iY, 'struct*', $__g_vExt)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWorldTransform($hDC, ByRef $tXFORM)
Local $aRet = DllCall('gdi32.dll', 'bool', 'SetWorldTransform', 'handle', $hDC, 'struct*', $tXFORM)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRop)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StretchBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest, 'int', $iWidthDest,  'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', $iRop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StretchDIBits($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $tBITMAPINFO, $iUsage, $pBits, $iRop)
Local $aRet = DllCall('gdi32.dll', 'int', 'StretchDIBits', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'struct*', $pBits, 'struct*', $tBITMAPINFO, 'uint', $iUsage,  'dword', $iRop)
If @error Or ($aRet[0] = -1) Then Return SetError(@error + 10, $aRet[0], 0)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokeAndFillPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokeAndFillPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_StrokePath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'StrokePath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SubtractRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'SubtractRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_TabbedTextOut($hDC, $iX, $iY, $sText, $aTab = 0, $iStart = 0, $iEnd = -1, $iOrigin = 0)
Local $iTab, $iCount
If Not IsArray($aTab) Then
If $aTab Then
$iTab = $aTab
Dim $aTab[1] = [$iTab]
$iStart = 0
$iEnd = 0
$iCount = 1
Else
$iCount = 0
EndIf
Else
$iCount = 1
EndIf
Local $tTab = 0
If $iCount Then
If __CheckErrorArrayBounds($aTab, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
$iCount = $iEnd - $iStart + 1
$tTab = DllStructCreate('uint[' & $iCount & ']')
$iTab = 1
For $i = $iStart To $iEnd
DllStructSetData($tTab, 1, $aTab[$i], $iTab)
$iTab += 1
Next
EndIf
Local $aRet = DllCall('user32.dll', 'long', 'TabbedTextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText), 'int', $iCount, 'struct*', $tTab, 'int', $iOrigin)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$__g_vExt = _WinAPI_CreateSize(_WinAPI_LoWord($aRet[0]), _WinAPI_HiWord($aRet[0]))
Return 1
EndFunc
Func _WinAPI_TextOut($hDC, $iX, $iY, $sText)
Local $aRet = DllCall('gdi32.dll', 'bool', 'TextOutW', 'handle', $hDC, 'int', $iX, 'int', $iY, 'wstr', $sText,  'int', StringLen($sText))
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_TransparentBlt($hDestDC, $iXDest, $iYDest, $iWidthDest, $iHeightDest, $hSrcDC, $iXSrc, $iYSrc, $iWidthSrc, $iHeightSrc, $iRGB)
Local $aRet = DllCall('gdi32.dll', 'bool', 'GdiTransparentBlt', 'handle', $hDestDC, 'int', $iXDest, 'int', $iYDest,  'int', $iWidthDest, 'int', $iHeightDest, 'hwnd', $hSrcDC, 'int', $iXSrc, 'int', $iYSrc,  'int', $iWidthSrc, 'int', $iHeightSrc, 'dword', __RGB($iRGB))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnionRect(ByRef $tRECT1, ByRef $tRECT2)
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'UnionRect', 'struct*', $tRECT, 'struct*', $tRECT1, 'struct*', $tRECT2)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, 0, 0)
Return $tRECT
EndFunc
Func _WinAPI_ValidateRect($hWnd, $tRECT = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRect', 'hwnd', $hWnd, 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ValidateRgn($hWnd, $hRgn = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'ValidateRgn', 'hwnd', $hWnd, 'handle', $hRgn)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WidenPath($hDC)
Local $aRet = DllCall('gdi32.dll', 'bool', 'WidenPath', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_WindowFromDC($hDC)
Local $aRet = DllCall('user32.dll', 'hwnd', 'WindowFromDC', 'handle', $hDC)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumDisplayMonitorsProc($hMonitor, $hDC, $pRECT, $lParam)
#forceref $hDC, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = $hMonitor
If Not $pRECT Then
$__g_vEnum[$__g_vEnum[0][0]][1] = 0
Else
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructCreate($tagRECT)
If Not _WinAPI_MoveMemory(DllStructGetPtr($__g_vEnum[$__g_vEnum[0][0]][1]), $pRECT, 16) Then Return 0
EndIf
Return 1
EndFunc
Func __EnumFontFamiliesProc($pELFEX, $pNTMEX, $iFontType, $pPattern)
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tPattern = DllStructCreate('uint;uint;ptr', $pPattern)
If $iFontType And Not BitAND($iFontType, DllStructGetData($tPattern, 1)) Then
Return 1
EndIf
If DllStructGetData($tPattern, 3) Then
Local $aRet = DllCall('shlwapi.dll', 'bool', 'PathMatchSpecW', 'ptr', DllStructGetPtr($tELFEX, 14), 'ptr', DllStructGetData($tPattern, 3))
If Not @error Then
If DllStructGetData($tPattern, 2) Then
If $aRet[0] Then
Return 1
Else
EndIf
Else
If $aRet[0] Then
Else
Return 1
EndIf
EndIf
EndIf
EndIf
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tELFEX, 14)
$__g_vEnum[$__g_vEnum[0][0]][1] = DllStructGetData($tELFEX, 16)
$__g_vEnum[$__g_vEnum[0][0]][2] = DllStructGetData($tELFEX, 15)
$__g_vEnum[$__g_vEnum[0][0]][3] = DllStructGetData($tELFEX, 17)
$__g_vEnum[$__g_vEnum[0][0]][4] = $iFontType
$__g_vEnum[$__g_vEnum[0][0]][5] = DllStructGetData($tNTMEX, 19)
$__g_vEnum[$__g_vEnum[0][0]][6] = DllStructGetData($tNTMEX, 20)
$__g_vEnum[$__g_vEnum[0][0]][7] = DllStructGetData($tNTMEX, 21)
Return 1
EndFunc
Func __EnumFontStylesProc($pELFEX, $pNTMEX, $iFontType, $pFN)
#forceref $iFontType
Local $tELFEX = DllStructCreate($tagLOGFONT & ';wchar FullName[64];wchar Style[32];wchar Script[32]', $pELFEX)
Local $tNTMEX = DllStructCreate($tagNEWTEXTMETRICEX, $pNTMEX)
Local $tFN = DllStructCreate('dword;wchar[64]', $pFN)
If BitAND(DllStructGetData($tNTMEX, 'ntmFlags'), 0x0061) = DllStructGetData($tFN, 1) Then
DllStructSetData($tFN, 2, DllStructGetData($tELFEX, 'FullName'))
Return 0
Else
Return 1
EndIf
EndFunc
#EndRegion Internal Functions
Global Const $LINGUISTIC_IGNORECASE = 0x00000010
Global Const $LINGUISTIC_IGNOREDIACRITIC = 0x00000020
Global Const $NORM_IGNORECASE = 0x00000001
Global Const $NORM_IGNOREKANATYPE = 0x00010000
Global Const $NORM_IGNORENONSPACE = 0x00000002
Global Const $NORM_IGNORESYMBOLS = 0x00000004
Global Const $NORM_IGNOREWIDTH = 0x00020000
Global Const $NORM_LINGUISTIC_CASING = 0x08000000
Global Const $SORT_DIGITSASNUMBERS = 0x00000008
Global Const $SORT_STRINGSORT = 0x00001000
Global Const $CSTR_LESS_THAN = 1
Global Const $CSTR_EQUAL = 2
Global Const $CSTR_GREATER_THAN = 3
Global Const $MUI_LANGUAGE_ID = 0x0004
Global Const $MUI_LANGUAGE_NAME = 0x0008
Global Const $DATE_AUTOLAYOUT = 0x40
Global Const $DATE_LONGDATE = 0x02
Global Const $DATE_LTRREADING = 0x10
Global Const $DATE_SHORTDATE = 0x01
Global Const $DATE_RTLREADING = 0x20
Global Const $DATE_USE_ALT_CALENDAR = 0x04
Global Const $DATE_YEARMONTH = 0x08
Global Const $GEO_NATION = 1
Global Const $GEO_LATITUDE = 2
Global Const $GEO_LONGITUDE = 3
Global Const $GEO_ISO2 = 4
Global Const $GEO_ISO3 = 5
Global Const $GEO_RFC1766 = 6
Global Const $GEO_LCID = 7
Global Const $GEO_FRIENDLYNAME = 8
Global Const $GEO_OFFICIALNAME = 9
Global Const $GEO_TIMEZONES = 10
Global Const $GEO_OFFICIALLANGUAGES = 11
Global Const $GEO_ISO_UN_NUMBER = 12
Global Const $GEO_PARENT = 13
Global Const $LOCALE_ILANGUAGE = 0x0001
Global Const $LOCALE_SLANGUAGE = 0x0002
Global Const $LOCALE_SENGLANGUAGE = 0x1001
Global Const $LOCALE_SABBREVLANGNAME = 0x0003
Global Const $LOCALE_SNATIVELANGNAME = 0x0004
Global Const $LOCALE_ICOUNTRY = 0x0005
Global Const $LOCALE_SCOUNTRY = 0x0006
Global Const $LOCALE_SENGCOUNTRY = 0x1002
Global Const $LOCALE_SABBREVCTRYNAME = 0x0007
Global Const $LOCALE_SNATIVECTRYNAME = 0x0008
Global Const $LOCALE_IDEFAULTLANGUAGE = 0x0009
Global Const $LOCALE_IDEFAULTCOUNTRY = 0x000A
Global Const $LOCALE_IDEFAULTCODEPAGE = 0x000B
Global Const $LOCALE_IDEFAULTANSICODEPAGE = 0x1004
Global Const $LOCALE_IDEFAULTMACCODEPAGE = 0x1011
Global Const $LOCALE_SLIST = 0x000C
Global Const $LOCALE_IMEASURE = 0x000D
Global Const $LOCALE_SDECIMAL = 0x000E
Global Const $LOCALE_STHOUSAND = 0x000F
Global Const $LOCALE_SGROUPING = 0x0010
Global Const $LOCALE_IDIGITS = 0x0011
Global Const $LOCALE_ILZERO = 0x0012
Global Const $LOCALE_INEGNUMBER = 0x1010
Global Const $LOCALE_SNATIVEDIGITS = 0x0013
Global Const $LOCALE_SCURRENCY = 0x0014
Global Const $LOCALE_SINTLSYMBOL = 0x0015
Global Const $LOCALE_SMONDECIMALSEP = 0x0016
Global Const $LOCALE_SMONTHOUSANDSEP = 0x0017
Global Const $LOCALE_SMONGROUPING = 0x0018
Global Const $LOCALE_ICURRDIGITS = 0x0019
Global Const $LOCALE_IINTLCURRDIGITS = 0x001A
Global Const $LOCALE_ICURRENCY = 0x001B
Global Const $LOCALE_INEGCURR = 0x001C
Global Const $LOCALE_SDATE = 0x001D
Global Const $LOCALE_STIME = 0x001E
Global Const $LOCALE_SSHORTDATE = 0x001F
Global Const $LOCALE_SLONGDATE = 0x0020
Global Const $LOCALE_STIMEFORMAT = 0x1003
Global Const $LOCALE_IDATE = 0x0021
Global Const $LOCALE_ILDATE = 0x0022
Global Const $LOCALE_ITIME = 0x0023
Global Const $LOCALE_ITIMEMARKPOSN = 0x1005
Global Const $LOCALE_ICENTURY = 0x0024
Global Const $LOCALE_ITLZERO = 0x0025
Global Const $LOCALE_IDAYLZERO = 0x0026
Global Const $LOCALE_IMONLZERO = 0x0027
Global Const $LOCALE_S1159 = 0x0028
Global Const $LOCALE_S2359 = 0x0029
Global Const $LOCALE_ICALENDARTYPE = 0x1009
Global Const $LOCALE_IOPTIONALCALENDAR = 0x100B
Global Const $LOCALE_IFIRSTDAYOFWEEK = 0x100C
Global Const $LOCALE_IFIRSTWEEKOFYEAR = 0x100D
Global Const $LOCALE_SDAYNAME1 = 0x002A
Global Const $LOCALE_SDAYNAME2 = 0x002B
Global Const $LOCALE_SDAYNAME3 = 0x002C
Global Const $LOCALE_SDAYNAME4 = 0x002D
Global Const $LOCALE_SDAYNAME5 = 0x002E
Global Const $LOCALE_SDAYNAME6 = 0x002F
Global Const $LOCALE_SDAYNAME7 = 0x0030
Global Const $LOCALE_SABBREVDAYNAME1 = 0x0031
Global Const $LOCALE_SABBREVDAYNAME2 = 0x0032
Global Const $LOCALE_SABBREVDAYNAME3 = 0x0033
Global Const $LOCALE_SABBREVDAYNAME4 = 0x0034
Global Const $LOCALE_SABBREVDAYNAME5 = 0x0035
Global Const $LOCALE_SABBREVDAYNAME6 = 0x0036
Global Const $LOCALE_SABBREVDAYNAME7 = 0x0037
Global Const $LOCALE_SMONTHNAME1 = 0x0038
Global Const $LOCALE_SMONTHNAME2 = 0x0039
Global Const $LOCALE_SMONTHNAME3 = 0x003A
Global Const $LOCALE_SMONTHNAME4 = 0x003B
Global Const $LOCALE_SMONTHNAME5 = 0x003C
Global Const $LOCALE_SMONTHNAME6 = 0x003D
Global Const $LOCALE_SMONTHNAME7 = 0x003E
Global Const $LOCALE_SMONTHNAME8 = 0x003F
Global Const $LOCALE_SMONTHNAME9 = 0x0040
Global Const $LOCALE_SMONTHNAME10 = 0x0041
Global Const $LOCALE_SMONTHNAME11 = 0x0042
Global Const $LOCALE_SMONTHNAME12 = 0x0043
Global Const $LOCALE_SMONTHNAME13 = 0x100E
Global Const $LOCALE_SABBREVMONTHNAME1 = 0x0044
Global Const $LOCALE_SABBREVMONTHNAME2 = 0x0045
Global Const $LOCALE_SABBREVMONTHNAME3 = 0x0046
Global Const $LOCALE_SABBREVMONTHNAME4 = 0x0047
Global Const $LOCALE_SABBREVMONTHNAME5 = 0x0048
Global Const $LOCALE_SABBREVMONTHNAME6 = 0x0049
Global Const $LOCALE_SABBREVMONTHNAME7 = 0x004A
Global Const $LOCALE_SABBREVMONTHNAME8 = 0x004B
Global Const $LOCALE_SABBREVMONTHNAME9 = 0x004C
Global Const $LOCALE_SABBREVMONTHNAME10 = 0x004D
Global Const $LOCALE_SABBREVMONTHNAME11 = 0x004E
Global Const $LOCALE_SABBREVMONTHNAME12 = 0x004F
Global Const $LOCALE_SABBREVMONTHNAME13 = 0x100F
Global Const $LOCALE_SPOSITIVESIGN = 0x0050
Global Const $LOCALE_SNEGATIVESIGN = 0x0051
Global Const $LOCALE_IPOSSIGNPOSN = 0x0052
Global Const $LOCALE_INEGSIGNPOSN = 0x0053
Global Const $LOCALE_IPOSSYMPRECEDES = 0x0054
Global Const $LOCALE_IPOSSEPBYSPACE = 0x0055
Global Const $LOCALE_INEGSYMPRECEDES = 0x0056
Global Const $LOCALE_INEGSEPBYSPACE = 0x0057
Global Const $LOCALE_FONTSIGNATURE = 0x0058
Global Const $LOCALE_SISO639LANGNAME = 0x0059
Global Const $LOCALE_SISO3166CTRYNAME = 0x005A
Global Const $LOCALE_IDEFAULTEBCDICCODEPAGE = 0x1012
Global Const $LOCALE_IPAPERSIZE = 0x100A
Global Const $LOCALE_SENGCURRNAME = 0x1007
Global Const $LOCALE_SNATIVECURRNAME = 0x1008
Global Const $LOCALE_SYEARMONTH = 0x1006
Global Const $LOCALE_SSORTNAME = 0x1013
Global Const $LOCALE_IDIGITSUBSTITUTION = 0x1014
Global Const $LOCALE_CUSTOM_DEFAULT = 0x0C00
Global Const $LOCALE_CUSTOM_UI_DEFAULT = 0x1400
Global Const $LOCALE_CUSTOM_UNSPECIFIED = 0x1000
Global Const $LOCALE_INVARIANT = 0x007F
Global Const $LOCALE_SYSTEM_DEFAULT = 0x0800
Global Const $LOCALE_USER_DEFAULT = 0x0400
Global Const $TIME_FORCE24HOURFORMAT = 0x08
Global Const $TIME_NOMINUTESORSECONDS = 0x01
Global Const $TIME_NOSECONDS = 0x02
Global Const $TIME_NOTIMEMARKER = 0x04
Global Const $LCID_INSTALLED = 1
Global Const $LCID_SUPPORTED = 2
#Region Global Variables and Constants
Global $__g_vVal
Global Const $tagVS_FIXEDFILEINFO = 'dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_BeginUpdateResource($sFilePath, $bDelete = False)
Local $aRet = DllCall('kernel32.dll', 'handle', 'BeginUpdateResourceW', 'wstr', $sFilePath, 'bool', $bDelete)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ClipCursor($tRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'ClipCursor', 'struct*', $tRECT)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CopyCursor($hCursor)
Return _WinAPI_CopyIcon($hCursor)
EndFunc
Func _WinAPI_CreateCaret($hWnd, $hBitmap, $iWidth = 0, $iHeight = 0)
Local $aRet = DllCall('user32.dll', 'bool', 'CreateCaret', 'hwnd', $hWnd, 'handle', $hBitmap, 'int', $iWidth, 'int', $iHeight)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCaret()
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCaret')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DestroyCursor($hCursor)
Local $aRet = DllCall('user32.dll', 'bool', 'DestroyCursor', 'handle', $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_EndUpdateResource($hUpdate, $bDiscard = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'EndUpdateResourceW', 'handle', $hUpdate, 'bool', $bDiscard)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumResourceLanguages($hModule, $sType, $sName)
Local $iLibrary = 0, $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResLanguagesProc', 'bool', 'handle;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceNames($hModule, $sType)
Local $aRet, $hEnumProc, $iLibrary = 0, $sTypeOfType = 'int'
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
Dim $__g_vEnum[101] = [0]
$hEnumProc = DllCallbackRegister('__EnumResNamesProc', 'bool', 'handle;ptr;ptr;long_ptr')
$aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceNamesW', 'handle', $hModule, $sTypeOfType, $sType,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumResourceTypes($hModule)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(1, 0, 0)
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101] = [0]
Local $hEnumProc = DllCallbackRegister('__EnumResTypesProc', 'bool', 'handle;ptr;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceTypesW', 'handle', $hModule,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', 0)
If @error Or Not $aRet[0] Or (Not $__g_vEnum[0]) Then
$__g_vEnum = @error + 10
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindResource($hInstance, $sType, $sName)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceW', 'handle', $hInstance, $sTypeOfName, $sName, $sTypeOfType, $sType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'handle', 'FindResourceExW', 'handle', $hInstance, $sTypeOfType, $sType,  $sTypeOfName, $sName, 'ushort', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_FreeResource($hData)
Local $aRet = DllCall('kernel32.dll', 'bool', 'FreeResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretBlinkTime()
Local $aRet = DllCall('user32.dll', 'uint', 'GetCaretBlinkTime')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCaretPos()
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetCaretPos', 'struct*', $tagPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[2]
For $i = 0 To 1
$aResult[$i] = DllStructGetData($tPOINT, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetClipCursor()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClipCursor', 'struct*', $tRECT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetCursor()
Local $aRet = DllCall('user32.dll', 'handle', 'GetCursor')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetFileVersionInfo($sFilePath, ByRef $pBuffer, $iFlags = 0)
Local $aRet
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeExW', 'dword', BitAND($iFlags, 0x03), 'wstr', $sFilePath,  'ptr', 0)
Else
$aRet = DllCall('version.dll', 'dword', 'GetFileVersionInfoSizeW', 'wstr', $sFilePath, 'ptr', 0)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
$pBuffer = __HeapReAlloc($pBuffer, $aRet[0], 1)
If @error Then Return SetError(@error + 100, @extended, 0)
Local $iNbByte = $aRet[0]
If $__WINVER >= 0x0600 Then
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoExW', 'dword', BitAND($iFlags, 0x07), 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
Else
$aRet = DllCall('version.dll', 'bool', 'GetFileVersionInfoW', 'wstr', $sFilePath,  'dword', 0, 'dword', $iNbByte, 'ptr', $pBuffer)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iNbByte
EndFunc
Func _WinAPI_HideCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'HideCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadBitmap($hInstance, $sBitmap)
Local $sBitmapType = "int"
If IsString($sBitmap) Then $sBitmapType = "wstr"
Local $aResult = DllCall("user32.dll", "handle", "LoadBitmapW", "handle", $hInstance, $sBitmapType, $sBitmap)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadCursor($hInstance, $sName)
Local $sTypeOfName = 'int'
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorW', 'handle', $hInstance, $sTypeOfName, $sName)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadCursorFromFile($sFilePath)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadCursorFromFileW', 'wstr', $sFilePath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadIndirectString($sStrIn)
Local $aRet = DllCall('shlwapi.dll', 'uint', 'SHLoadIndirectString', 'wstr', $sStrIn, 'wstr', '', 'uint', 4096, 'ptr*', 0)
If @error Then Return SetError(@error, @extended, '')
If $aRet[0] Then Return SetError(10, $aRet[0], '')
Return $aRet[2]
EndFunc
Func _WinAPI_LoadString($hInstance, $iStringID)
Local $aResult = DllCall("user32.dll", "int", "LoadStringW", "handle", $hInstance, "uint", $iStringID, "wstr", "", "int", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return SetExtended($aResult[0], $aResult[3])
EndFunc
Func _WinAPI_LoadLibraryEx($sFileName, $iFlags = 0)
Local $aResult = DllCall("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $sFileName, "ptr", 0, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_LoadResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'handle', 'LoadResource', 'handle', $hInstance, 'handle', $hResource)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LoadStringEx($hModule, $iID, $iLanguage = $LOCALE_USER_DEFAULT)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then Return SetError(@error + 20, @extended, '')
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Local $sResult = ''
Local $pData = __ResLoad($hModule, 6, Floor($iID / 16) + 1, $iLanguage)
If Not @error Then
Local $iOffset = 0
For $i = 0 To Mod($iID, 16) - 1
$iOffset += 2 * (DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) + 1)
Next
$sResult = DllStructGetData(DllStructCreate('ushort;wchar[' & DllStructGetData(DllStructCreate('ushort', $pData + $iOffset), 1) & ']', $pData + $iOffset), 2)
If @error Then $sResult = ''
Else
Return SetError(10, 0, '')
EndIf
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
Return SetError(Number(Not $sResult), 0, $sResult)
EndFunc
Func _WinAPI_LockResource($hData)
Local $aRet = DllCall('kernel32.dll', 'ptr', 'LockResource', 'handle', $hData)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCaretBlinkTime($iDuration)
Local $iPrev = _WinAPI_GetCaretBlinkTime()
If Not $iPrev Then Return SetError(@error + 20, @extended, 0)
Local $aRet = DllCall('user32.dll', 'bool', 'SetCaretBlinkTime', 'uint', $iDuration)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $iPrev
EndFunc
Func _WinAPI_SetCaretPos($iX, $iY)
Local $aRet = DllCall('user32.dll', 'int', 'SetCaretPos', 'int', $iX, 'int', $iY)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCursor($hCursor)
Local $aResult = DllCall("user32.dll", "handle", "SetCursor", "handle", $hCursor)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetSystemCursor($hCursor, $iID, $bCopy = False)
If $bCopy Then
$hCursor = _WinAPI_CopyCursor($hCursor)
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'SetSystemCursor', 'handle', $hCursor, 'dword', $iID)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowCaret($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowCaret', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShowCursor($bShow)
Local $aResult = DllCall("user32.dll", "int", "ShowCursor", "bool", $bShow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SizeOfResource($hInstance, $hResource)
Local $aRet = DllCall('kernel32.dll', 'dword', 'SizeofResource', 'handle', $hInstance, 'handle', $hResource)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateResource($hUpdate, $sType, $sName, $iLanguage, $pData, $iSize)
Local $sTypeOfType = 'int', $sTypeOfName = 'int'
If IsString($sType) Then
$sTypeOfType = 'wstr'
EndIf
If IsString($sName) Then
$sTypeOfName = 'wstr'
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'UpdateResourceW', 'handle', $hUpdate, $sTypeOfType, $sType, $sTypeOfName, $sName,  'word', $iLanguage, 'ptr', $pData, 'dword', $iSize)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_VerQueryRoot($pData)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, @extended, 0)
Local $tVFFI = DllStructCreate($tagVS_FIXEDFILEINFO)
If Not _WinAPI_MoveMemory($tVFFI, $aRet[3], $aRet[4]) Then Return SetError(@error + 20, @extended, 0)
Return $tVFFI
EndFunc
Func _WinAPI_VerQueryValue($pData, $sValues = '')
$sValues = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $sValues Then
$sValues = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$sValues = StringSplit($sValues, '|', $STR_NOCOUNT)
Local $aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0,  'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then Return SetError(@error + 10, 0, 0)
Local $iLength = Floor($aRet[4] / 4)
Local $tLang = DllStructCreate('dword[' & $iLength & ']', $aRet[3])
If @error Then Return SetError(@error + 20, 0, 0)
Local $sCP, $aInfo[101][UBound($sValues) + 1] = [[0]]
For $i = 1 To $iLength
__Inc($aInfo)
$aInfo[$aInfo[0][0]][0] = _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))
$sCP = Hex(_WinAPI_MakeLong(_WinAPI_HiWord(DllStructGetData($tLang, 1, $i)), _WinAPI_LoWord(DllStructGetData($tLang, 1, $i))), 8)
For $j = 0 To UBound($sValues) - 1
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $sValues[$j],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$aInfo[$aInfo[0][0]][$j + 1] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$aInfo[$aInfo[0][0]][$j + 1] = ''
EndIf
Next
Next
__Inc($aInfo, -1)
Return $aInfo
EndFunc
Func _WinAPI_VerQueryValueEx($hModule, $sValues = '', $iLanguage = 0x0400)
$__g_vVal = StringRegExpReplace($sValues, '\A[\s\|]*|[\s\|]*\Z', '')
If Not $__g_vVal Then
$__g_vVal = 'Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild'
EndIf
$__g_vVal = StringSplit($__g_vVal, '|')
If Not IsArray($__g_vVal) Then Return SetError(1, 0, 0)
Local $iLibrary = 0
If IsString($hModule) Then
If StringStripWS($hModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$hModule = _WinAPI_LoadLibraryEx($hModule, 0x00000003)
If Not $hModule Then
Return SetError(@error + 10, @extended, 0)
EndIf
$iLibrary = 1
Else
$hModule = 0
EndIf
EndIf
Dim $__g_vEnum[101][$__g_vVal[0] + 1] = [[0]]
Local $hEnumProc = DllCallbackRegister('__EnumVerValuesProc', 'bool', 'ptr;ptr;ptr;word;long_ptr')
Local $aRet = DllCall('kernel32.dll', 'bool', 'EnumResourceLanguagesW', 'handle', $hModule, 'int', 16, 'int', 1,  'ptr', DllCallbackGetPtr($hEnumProc), 'long_ptr', $iLanguage)
Do
If @error Then
$__g_vEnum = @error + 20
Else
If Not $aRet[0] Then
Switch _WinAPI_GetLastError()
Case 0, 15106
ExitLoop
Case Else
$__g_vEnum = 20
EndSwitch
Else
ExitLoop
EndIf
EndIf
Until 1
If $iLibrary Then
_WinAPI_FreeLibrary($hModule)
EndIf
DllCallbackFree($hEnumProc)
If Not $__g_vEnum[0][0] Then $__g_vEnum = 230
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumResLanguagesProc($hModule, $iType, $iName, $iLanguage, $lParam)
#forceref $hModule, $iType, $iName, $lParam
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0]] = $iLanguage
Return 1
EndFunc
Func __EnumResNamesProc($hModule, $iType, $iName, $lParam)
#forceref $hModule, $iType, $lParam
Local $iLength = _WinAPI_StrLen($iName)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iName), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iName)
EndIf
Return 1
EndFunc
Func __EnumResTypesProc($hModule, $iType, $lParam)
#forceref $hModule, $lParam
Local $iLength = _WinAPI_StrLen($iType)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $iType), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = Number($iType)
EndIf
Return 1
EndFunc
Func __EnumVerValuesProc($hModule, $iType, $iName, $iLanguage, $iDefault)
Local $aRet, $iEnum = 1, $iError = 0
Switch $iDefault
Case -1
Case 0x0400
$iLanguage = 0x0400
$iEnum = 0
Case Else
If $iLanguage <> $iDefault Then
Return 1
EndIf
$iEnum = 0
EndSwitch
Do
Local $pData = __ResLoad($hModule, $iType, $iName, $iLanguage)
If @error Then
$iError = @error + 10
ExitLoop
EndIf
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\VarFileInfo\Translation', 'ptr*', 0, 'uint*', 0)
If @error Or Not $aRet[0] Or Not $aRet[4] Then
$iError = @error + 20
ExitLoop
EndIf
Local $tData = DllStructCreate('ushort;ushort', $aRet[3])
If @error Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
If Not $iError Then
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData($tData, 1)
Local $sCP = Hex(_WinAPI_MakeLong(DllStructGetData($tData, 2), DllStructGetData($tData, 1)), 8)
For $i = 1 To $__g_vVal[0]
$aRet = DllCall('version.dll', 'bool', 'VerQueryValueW', 'ptr', $pData, 'wstr', '\StringFileInfo\' & $sCP & '\' & $__g_vVal[$i],  'ptr*', 0, 'uint*', 0)
If Not @error And $aRet[0] And $aRet[4] Then
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData(DllStructCreate('wchar[' & $aRet[4] & ']', $aRet[3]), 1)
Else
$__g_vEnum[$__g_vEnum[0][0]][$i] = ''
EndIf
Next
Else
$__g_vEnum = @error + 40
EndIf
If $__g_vEnum Then Return SetError($iError, 0, 0)
Return $iEnum
EndFunc
Func __ResLoad($hInstance, $sType, $sName, $iLanguage)
Local $hInfo = _WinAPI_FindResourceEx($hInstance, $sType, $sName, $iLanguage)
If Not $hInfo Then Return SetError(@error + 10, @extended, 0)
Local $iSize = _WinAPI_SizeOfResource($hInstance, $hInfo)
If Not $iSize Then Return SetError(@error + 20, @extended, 0)
Local $hData = _WinAPI_LoadResource($hInstance, $hInfo)
If Not $hData Then Return SetError(@error + 30, @extended, 0)
Local $pData = _WinAPI_LockResource($hData)
If Not $pData Then Return SetError(@error + 40, @extended, 0)
Return SetExtended($iSize, $pData)
EndFunc
#EndRegion Internal Functions
Global $__g_hLVLastWnd
Global Const $__LISTVIEWCONSTANT_SORTINFOSIZE = 11
Global $__g_aListViewSortInfo[1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
Global Const $__LISTVIEWCONSTANT_ClassName = "SysListView32"
Global Const $__LISTVIEWCONSTANT_WS_MAXIMIZEBOX = 0x00010000
Global Const $__LISTVIEWCONSTANT_WS_MINIMIZEBOX = 0x00020000
Global Const $__LISTVIEWCONSTANT_GUI_RUNDEFMSG = 'GUI_RUNDEFMSG'
Global Const $__LISTVIEWCONSTANT_WM_SETREDRAW = 0x000B
Global Const $__LISTVIEWCONSTANT_WM_SETFONT = 0x0030
Global Const $__LISTVIEWCONSTANT_WM_NOTIFY = 0x004E
Global Const $__LISTVIEWCONSTANT_DEFAULT_GUI_FONT = 17
Global Const $__LISTVIEWCONSTANT_ILD_TRANSPARENT = 0x00000001
Global Const $__LISTVIEWCONSTANT_ILD_BLEND25 = 0x00000002
Global Const $__LISTVIEWCONSTANT_ILD_BLEND50 = 0x00000004
Global Const $__LISTVIEWCONSTANT_ILD_MASK = 0x00000010
Global Const $__LISTVIEWCONSTANT_VK_DOWN = 0x28
Global Const $__LISTVIEWCONSTANT_VK_END = 0x23
Global Const $__LISTVIEWCONSTANT_VK_HOME = 0x24
Global Const $__LISTVIEWCONSTANT_VK_LEFT = 0x25
Global Const $__LISTVIEWCONSTANT_VK_NEXT = 0x22
Global Const $__LISTVIEWCONSTANT_VK_PRIOR = 0x21
Global Const $__LISTVIEWCONSTANT_VK_RIGHT = 0x27
Global Const $__LISTVIEWCONSTANT_VK_UP = 0x26
Global Const $tagLVBKIMAGE = "ulong Flags;hwnd hBmp;ptr Image;uint ImageMax;int XOffPercent;int YOffPercent"
Global Const $tagLVCOLUMN = "uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal"
Global Const $tagLVGROUP = "uint Size;uint Mask;ptr Header;int HeaderMax;ptr Footer;int FooterMax;int GroupID;uint StateMask;uint State;uint Align;" &  "ptr  pszSubtitle;uint cchSubtitle;ptr pszTask;uint cchTask;ptr pszDescriptionTop;uint cchDescriptionTop;ptr pszDescriptionBottom;" &  "uint cchDescriptionBottom;int iTitleImage;int iExtendedImage;int iFirstItem;uint cItems;ptr pszSubsetTitle;uint cchSubsetTitle"
Global Const $tagLVINSERTMARK = "uint Size;dword Flags;int Item;dword Reserved"
Global Const $tagLVSETINFOTIP = "uint Size;dword Flags;ptr Text;int Item;int SubItem"
Func _GUICtrlListView_AddArray($hWnd, ByRef $aItems)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tItem = DllStructCreate($tagLVITEM)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", 4096)
Local $iLastItem = _GUICtrlListView_GetItemCount($hWnd)
_GUICtrlListView_BeginUpdate($hWnd)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Next
Next
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
_SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
Next
Next
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
For $iI = 0 To UBound($aItems) - 1
DllStructSetData($tItem, "Item", $iI + $iLastItem)
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tBuffer, "Text", $aItems[$iI][0])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
For $iJ = 1 To UBound($aItems, $UBOUND_COLUMNS) - 1
DllStructSetData($tItem, "SubItem", $iJ)
DllStructSetData($tBuffer, "Text", $aItems[$iI][$iJ])
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
Next
Next
EndIf
_GUICtrlListView_EndUpdate($hWnd)
EndFunc
Func _GUICtrlListView_AddColumn($hWnd, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Return _GUICtrlListView_InsertColumn($hWnd, _GUICtrlListView_GetColumnCount($hWnd), $sText, $iWidth, $iAlign, $iImage, $bOnRight)
EndFunc
Func _GUICtrlListView_AddItem($hWnd, $sText, $iImage = -1, $iParam = 0)
Return _GUICtrlListView_InsertItem($hWnd, $sText, -1, $iImage, $iParam)
EndFunc
Func _GUICtrlListView_AddSubItem($hWnd, $iIndex, $sText, $iSubItem, $iImage = -1)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_ApproximateViewHeight($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitShift((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
Else
Return BitShift((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 16)
EndIf
EndFunc
Func _GUICtrlListView_ApproximateViewRect($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))
EndIf
Local $aView[2]
$aView[0] = BitAND($iView, 0xFFFF)
$aView[1] = BitShift($iView, 16)
Return $aView
EndFunc
Func _GUICtrlListView_ApproximateViewWidth($hWnd, $iCount = -1, $iCX = -1, $iCY = -1)
If IsHWnd($hWnd) Then
Return BitAND((_SendMessage($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
Else
Return BitAND((GUICtrlSendMsg($hWnd, $LVM_APPROXIMATEVIEWRECT, $iCount, _WinAPI_MakeLong($iCX, $iCY))), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_Arrange($hWnd, $iArrange = 0)
Local $aArrange[4] = [$LVA_DEFAULT, $LVA_ALIGNLEFT, $LVA_ALIGNTOP, $LVA_SNAPTOGRID]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ARRANGE, $aArrange[$iArrange]) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ARRANGE, $aArrange[$iArrange], 0) <> 0
EndIf
EndFunc
Func __GUICtrlListView_ArrayDelete(ByRef $avArray, $iElement)
If Not IsArray($avArray) Then Return SetError(1, 0, "")
Local $iUpper = UBound($avArray)
If $iUpper = 1 Then
SetError(2)
Return ""
EndIf
Local $avNewArray[$iUpper - 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$avNewArray[0][0] = $avArray[0][0]
If $iElement < 0 Then
$iElement = 0
EndIf
If $iElement > ($iUpper - 1) Then
$iElement = ($iUpper - 1)
EndIf
If $iElement > 0 Then
For $iCntr = 0 To $iElement - 1
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
If $iElement < ($iUpper - 1) Then
For $iCntr = ($iElement + 1) To ($iUpper - 1)
For $x = 1 To $__LISTVIEWCONSTANT_SORTINFOSIZE - 1
$avNewArray[$iCntr - 1][$x] = $avArray[$iCntr][$x]
Next
Next
EndIf
$avArray = $avNewArray
SetError(0)
Return 1
EndFunc
Func _GUICtrlListView_BeginUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, False) = 0
EndFunc
Func _GUICtrlListView_CancelEditLabel($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_CANCELEDITLABEL)
Else
GUICtrlSendMsg($hWnd, $LVM_CANCELEDITLABEL, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_ClickItem($hWnd, $iIndex, $sButton = "left", $bMove = False, $iClicks = 1, $iSpeed = 1)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
_GUICtrlListView_EnsureVisible($hWnd, $iIndex, False)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $LVIR_LABEL)
Local $tPoint = _WinAPI_PointFromRect($tRECT, True)
$tPoint = _WinAPI_ClientToScreen($hWnd, $tPoint)
Local $iX, $iY
_WinAPI_GetXYFromPoint($tPoint, $iX, $iY)
Local $iMode = Opt("MouseCoordMode", 1)
If Not $bMove Then
Local $aPos = MouseGetPos()
_WinAPI_ShowCursor(False)
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
MouseMove($aPos[0], $aPos[1], 0)
_WinAPI_ShowCursor(True)
Else
MouseClick($sButton, $iX, $iY, $iClicks, $iSpeed)
EndIf
Opt("MouseCoordMode", $iMode)
EndFunc
Func _GUICtrlListView_CopyItems($hWnd_Source, $hWnd_Destination, $bDelFlag = False)
Local $a_Indices, $tItem = DllStructCreate($tagLVITEM), $iIndex
Local $iCols = _GUICtrlListView_GetColumnCount($hWnd_Source)
Local $iItems = _GUICtrlListView_GetItemCount($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Source)
_GUICtrlListView_BeginUpdate($hWnd_Destination)
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hWnd_Source), $LVS_EX_CHECKBOXES) == $LVS_EX_CHECKBOXES Then
For $i = 0 To $iItems - 1
If (_GUICtrlListView_GetItemChecked($hWnd_Source, $i)) Then
If IsArray($a_Indices) Then
ReDim $a_Indices[UBound($a_Indices) + 1]
Else
Local $a_Indices[2]
EndIf
$a_Indices[0] = $a_Indices[0] + 1
$a_Indices[UBound($a_Indices) - 1] = $i
EndIf
Next
If (IsArray($a_Indices)) Then
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
_GUICtrlListView_SetItemChecked($hWnd_Destination, $iIndex)
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
EndIf
If (_GUICtrlListView_GetSelectedCount($hWnd_Source)) Then
$a_Indices = _GUICtrlListView_GetSelectedIndices($hWnd_Source, 1)
For $i = 1 To $a_Indices[0]
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", 0)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
$iIndex = _GUICtrlListView_AddItem($hWnd_Destination, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], 0), DllStructGetData($tItem, "Image"))
For $x = 1 To $iCols - 1
DllStructSetData($tItem, "Item", $a_Indices[$i])
DllStructSetData($tItem, "SubItem", $x)
_GUICtrlListView_GetItemEx($hWnd_Source, $tItem)
_GUICtrlListView_AddSubItem($hWnd_Destination, $iIndex, _GUICtrlListView_GetItemText($hWnd_Source, $a_Indices[$i], $x), $x, DllStructGetData($tItem, "Image"))
Next
Next
_GUICtrlListView_SetItemSelected($hWnd_Source, -1, False)
If $bDelFlag Then
For $i = $a_Indices[0] To 1 Step -1
_GUICtrlListView_DeleteItem($hWnd_Source, $a_Indices[$i])
Next
EndIf
EndIf
_GUICtrlListView_EndUpdate($hWnd_Source)
_GUICtrlListView_EndUpdate($hWnd_Destination)
EndFunc
Func _GUICtrlListView_Create($hWnd, $sHeaderText, $iX, $iY, $iWidth = 150, $iHeight = 150, $iStyle = 0x0000000D, $iExStyle = 0x00000000, $bCoInit = False)
If Not IsHWnd($hWnd) Then Return SetError(1, 0, 0)
If Not IsString($sHeaderText) Then Return SetError(2, 0, 0)
If $iWidth = -1 Then $iWidth = 150
If $iHeight = -1 Then $iHeight = 150
If $iStyle = -1 Then $iStyle = $LVS_DEFAULT
If $iExStyle = -1 Then $iExStyle = 0x00000000
Local Const $S_OK = 0x0
Local Const $S_FALSE = 0x1
Local Const $RPC_E_CHANGED_MODE = 0x80010106
Local Const $E_INVALIDARG = 0x80070057
Local Const $E_OUTOFMEMORY = 0x8007000E
Local Const $E_UNEXPECTED = 0x8000FFFF
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local Const $COINIT_APARTMENTTHREADED = 0x02
Local $iStr_len = StringLen($sHeaderText)
If $iStr_len Then $sHeaderText = StringSplit($sHeaderText, $sSeparatorChar)
$iStyle = BitOR($__UDFGUICONSTANT_WS_CHILD, $__UDFGUICONSTANT_WS_VISIBLE, $iStyle)
If $bCoInit Then
Local $aResult = DllCall('ole32.dll', 'long', 'CoInitializeEx', 'ptr', 0, 'dword', $COINIT_APARTMENTTHREADED)
If @error Then Return SetError(@error, @extended, 0)
Switch $aResult[0]
Case $S_OK
Case $S_FALSE
Case $RPC_E_CHANGED_MODE
Case $E_INVALIDARG
Case $E_OUTOFMEMORY
Case $E_UNEXPECTED
EndSwitch
EndIf
Local $nCtrlID = __UDF_GetNextGlobalID($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Local $hList = _WinAPI_CreateWindowEx($iExStyle, $__LISTVIEWCONSTANT_ClassName, "", $iStyle, $iX, $iY, $iWidth, $iHeight, $hWnd, $nCtrlID)
_SendMessage($hList, $__LISTVIEWCONSTANT_WM_SETFONT, _WinAPI_GetStockObject($__LISTVIEWCONSTANT_DEFAULT_GUI_FONT), True)
If $iStr_len Then
For $x = 1 To $sHeaderText[0]
_GUICtrlListView_InsertColumn($hList, $x - 1, $sHeaderText[$x], 75)
Next
EndIf
Return $hList
EndFunc
Func _GUICtrlListView_CreateDragImage($hWnd, $iIndex)
Local $aDrag[3]
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $tPoint, 0, "wparam", "struct*", "handle")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$aDrag[0] = _SendMessage($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, $pMemory, 0, "wparam", "ptr", "handle")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$aDrag[0] = Ptr(GUICtrlSendMsg($hWnd, $LVM_CREATEDRAGIMAGE, $iIndex, DllStructGetPtr($tPoint)))
EndIf
$aDrag[1] = DllStructGetData($tPoint, "X")
$aDrag[2] = DllStructGetData($tPoint, "Y")
Return $aDrag
EndFunc
Func _GUICtrlListView_CreateSolidBitMap($hWnd, $iColor, $iWidth, $iHeight)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _WinAPI_CreateSolidBitmap($hWnd, $iColor, $iWidth, $iHeight)
EndFunc
Func _GUICtrlListView_DeleteAllItems($hWnd)
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = 0
For $iIndex = _GUICtrlListView_GetItemCount($hWnd) - 1 To 0 Step -1
$iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
GUICtrlDelete($iParam)
EndIf
Next
If _GUICtrlListView_GetItemCount($hWnd) = 0 Then Return True
EndIf
Return _SendMessage($hWnd, $LVM_DELETEALLITEMS) <> 0
EndFunc
Func _GUICtrlListView_DeleteColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_DELETECOLUMN, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_DELETECOLUMN, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_DeleteItem($hWnd, $iIndex)
Local $vCID = 0
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $iIndex)
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
If GUICtrlDelete($iParam) Then
Return True
EndIf
EndIf
EndIf
Return _SendMessage($hWnd, $LVM_DELETEITEM, $iIndex) <> 0
EndFunc
Func _GUICtrlListView_DeleteItemsSelected($hWnd)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If _GUICtrlListView_GetSelectedCount($hWnd) = $iItemCount Then
Return _GUICtrlListView_DeleteAllItems($hWnd)
Else
Local $aSelected = _GUICtrlListView_GetSelectedIndices($hWnd, True)
If Not IsArray($aSelected) Then Return SetError($LV_ERR, $LV_ERR, 0)
_GUICtrlListView_SetItemSelected($hWnd, -1, False)
Local $vCID = 0, $iNative_Delete, $iUDF_Delete
If IsHWnd($hWnd) Then
$vCID = _WinAPI_GetDlgCtrlID($hWnd)
Else
$vCID = $hWnd
$hWnd = GUICtrlGetHandle($hWnd)
EndIf
For $iIndex = $aSelected[0] To 1 Step -1
If $vCID < $_UDF_STARTID Then
Local $iParam = _GUICtrlListView_GetItemParam($hWnd, $aSelected[$iIndex])
If GUICtrlGetState($iParam) > 0 And GUICtrlGetHandle($iParam) = 0 Then
$iNative_Delete = GUICtrlDelete($iParam)
If $iNative_Delete Then ContinueLoop
EndIf
EndIf
$iUDF_Delete = _SendMessage($hWnd, $LVM_DELETEITEM, $aSelected[$iIndex])
If $iNative_Delete + $iUDF_Delete = 0 Then
ExitLoop
EndIf
Next
Return Not $iIndex
EndIf
EndFunc
Func _GUICtrlListView_Destroy(ByRef $hWnd)
If Not _WinAPI_IsClassName($hWnd, $__LISTVIEWCONSTANT_ClassName) Then Return SetError(2, 2, False)
Local $iDestroyed = 0
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Local $nCtrlID = _WinAPI_GetDlgCtrlID($hWnd)
Local $hParent = _WinAPI_GetParent($hWnd)
$iDestroyed = _WinAPI_DestroyWindow($hWnd)
Local $iRet = __UDF_FreeGlobalID($hParent, $nCtrlID)
If Not $iRet Then
EndIf
Else
Return SetError(1, 1, False)
EndIf
Else
$iDestroyed = GUICtrlDelete($hWnd)
EndIf
If $iDestroyed Then $hWnd = 0
Return $iDestroyed <> 0
EndFunc
Func __GUICtrlListView_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $__LISTVIEWCONSTANT_ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _GUICtrlListView_DrawDragImage(ByRef $hWnd, ByRef $aDrag)
Local $hDC = _WinAPI_GetWindowDC($hWnd)
Local $tPoint = _WinAPI_GetMousePos(True, $hWnd)
_WinAPI_InvalidateRect($hWnd)
__GUICtrlListView_Draw($aDrag[0], 0, $hDC, DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y"))
_WinAPI_ReleaseDC($hWnd, $hDC)
EndFunc
Func _GUICtrlListView_EditLabel($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aResult
If IsHWnd($hWnd) Then
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return _SendMessage($hWnd, $LVM_EDITLABELW, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
Else
Return _SendMessage($hWnd, $LVM_EDITLABEL, $iIndex, 0, 0, "wparam", "lparam", "hwnd")
EndIf
Else
$aResult = DllCall("user32.dll", "hwnd", "SetFocus", "hwnd", GUICtrlGetHandle($hWnd))
If @error Then Return SetError(@error, @extended, 0)
If $aResult = 0 Then Return 0
If $bUnicode Then
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABELW, $iIndex, 0))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_EDITLABEL, $iIndex, 0))
EndIf
EndIf
EndFunc
Func _GUICtrlListView_EnableGroupView($hWnd, $bEnable = True)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENABLEGROUPVIEW, $bEnable, 0)
EndIf
EndFunc
Func _GUICtrlListView_EndUpdate($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
Return _SendMessage($hWnd, $__LISTVIEWCONSTANT_WM_SETREDRAW, True) = 0
EndFunc
Func _GUICtrlListView_EnsureVisible($hWnd, $iIndex, $bPartialOK = False)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_ENSUREVISIBLE, $iIndex, $bPartialOK)
EndIf
EndFunc
Func _GUICtrlListView_FindInText($hWnd, $sText, $iStart = -1, $bWrapOK = True, $bReverse = False)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
If $iColumns = 0 Then $iColumns = 1
If $bReverse And $iStart = -1 Then Return -1
Local $sList
If $bReverse Then
For $iI = $iStart - 1 To 0 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = $iStart + 1 To $iCount - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
If (($iStart = -1) Or Not $bWrapOK) And Not $bReverse Then Return -1
If $bReverse And $bWrapOK Then
For $iI = $iCount - 1 To $iStart + 1 Step -1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
Else
For $iI = 0 To $iStart - 1
For $iJ = 0 To $iColumns - 1
$sList = _GUICtrlListView_GetItemText($hWnd, $iI, $iJ)
If StringInStr($sList, $sText) Then Return $iI
Next
Next
EndIf
Return -1
EndFunc
Func _GUICtrlListView_FindItem($hWnd, $iStart, ByRef $tFindInfo, $sText = "")
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
Local $pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $tFindInfo, 0, "wparam", "struct*")
Else
Local $iFindInfo = DllStructGetSize($tFindInfo)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iFindInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iFindInfo
DllStructSetData($tFindInfo, "Text", $pText)
_MemWrite($tMemMap, $tFindInfo, $pMemory, $iFindInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_FINDITEM, $iStart, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tFindInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_FINDITEM, $iStart, DllStructGetPtr($tFindInfo))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_FindNearest($hWnd, $iX, $iY, $iDir = 0, $iStart = -1, $bWrapOK = True)
Local $aDir[8] = [$__LISTVIEWCONSTANT_VK_LEFT, $__LISTVIEWCONSTANT_VK_RIGHT, $__LISTVIEWCONSTANT_VK_UP, $__LISTVIEWCONSTANT_VK_DOWN, $__LISTVIEWCONSTANT_VK_HOME, $__LISTVIEWCONSTANT_VK_END, $__LISTVIEWCONSTANT_VK_PRIOR, $__LISTVIEWCONSTANT_VK_NEXT]
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_NEARESTXY
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
DllStructSetData($tFindInfo, "X", $iX)
DllStructSetData($tFindInfo, "Y", $iY)
DllStructSetData($tFindInfo, "Direction", $aDir[$iDir])
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindParam($hWnd, $iParam, $iStart = -1)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
DllStructSetData($tFindInfo, "Flags", $LVFI_PARAM)
DllStructSetData($tFindInfo, "Param", $iParam)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo)
EndFunc
Func _GUICtrlListView_FindText($hWnd, $sText, $iStart = -1, $bPartialOK = True, $bWrapOK = True)
Local $tFindInfo = DllStructCreate($tagLVFINDINFO)
Local $iFlags = $LVFI_STRING
If $bPartialOK Then $iFlags = BitOR($iFlags, $LVFI_PARTIAL)
If $bWrapOK Then $iFlags = BitOR($iFlags, $LVFI_WRAP)
DllStructSetData($tFindInfo, "Flags", $iFlags)
Return _GUICtrlListView_FindItem($hWnd, $iStart, $tFindInfo, $sText)
EndFunc
Func _GUICtrlListView_GetBkColor($hWnd)
Local $i_Color
If IsHWnd($hWnd) Then
$i_Color = _SendMessage($hWnd, $LVM_GETBKCOLOR)
Else
$i_Color = GUICtrlSendMsg($hWnd, $LVM_GETBKCOLOR, 0, 0)
EndIf
Return __GUICtrlListView_ReverseColorOrder($i_Color)
EndFunc
Func _GUICtrlListView_GetBkImage($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
DllStructSetData($tImage, "ImageMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tImage, $iImage)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Local $aImage[4]
Switch BitAND(DllStructGetData($tImage, "Flags"), $LVBKIF_SOURCE_MASK)
Case $LVBKIF_SOURCE_HBITMAP
$aImage[0] = 1
Case $LVBKIF_SOURCE_URL
$aImage[0] = 2
EndSwitch
$aImage[1] = DllStructGetData($tBuffer, "Text")
$aImage[2] = DllStructGetData($tImage, "XOffPercent")
$aImage[3] = DllStructGetData($tImage, "YOffPercent")
Return SetError($iRet <> 0, 0, $aImage)
EndFunc
Func _GUICtrlListView_GetCallbackMask($hWnd)
Local $iFlags = 0
Local $iMask = _SendMessage($hWnd, $LVM_GETCALLBACKMASK)
If BitAND($iMask, $LVIS_CUT) <> 0 Then $iFlags = BitOR($iFlags, 1)
If BitAND($iMask, $LVIS_DROPHILITED) <> 0 Then $iFlags = BitOR($iFlags, 2)
If BitAND($iMask, $LVIS_FOCUSED) <> 0 Then $iFlags = BitOR($iFlags, 4)
If BitAND($iMask, $LVIS_SELECTED) <> 0 Then $iFlags = BitOR($iFlags, 8)
If BitAND($iMask, $LVIS_OVERLAYMASK) <> 0 Then $iFlags = BitOR($iFlags, 16)
If BitAND($iMask, $LVIS_STATEIMAGEMASK) <> 0 Then $iFlags = BitOR($iFlags, 32)
Return $iFlags
EndFunc
Func _GUICtrlListView_GetColumn($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
DllStructSetData($tColumn, "Mask", $LVCF_ALLDATA)
DllStructSetData($tColumn, "TextMax", 4096)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tColumn, $iColumn)
_MemRead($tMemMap, $pText, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Local $aColumn[9]
Switch BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_JUSTIFYMASK)
Case $LVCFMT_RIGHT
$aColumn[0] = 1
Case $LVCFMT_CENTER
$aColumn[0] = 2
Case Else
$aColumn[0] = 0
EndSwitch
$aColumn[1] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_IMAGE) <> 0
$aColumn[2] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_BITMAP_ON_RIGHT) <> 0
$aColumn[3] = BitAND(DllStructGetData($tColumn, "Fmt"), $LVCFMT_COL_HAS_IMAGES) <> 0
$aColumn[4] = DllStructGetData($tColumn, "CX")
$aColumn[5] = DllStructGetData($tBuffer, "Text")
$aColumn[6] = DllStructGetData($tColumn, "SubItem")
$aColumn[7] = DllStructGetData($tColumn, "Image")
$aColumn[8] = DllStructGetData($tColumn, "Order")
Return SetError($iRet = 0, 0, $aColumn)
EndFunc
Func _GUICtrlListView_GetColumnCount($hWnd)
Return _SendMessage(_GUICtrlListView_GetHeader($hWnd), 0x1200)
EndFunc
Func _GUICtrlListView_GetColumnOrder($hWnd)
Local $a_Cols = _GUICtrlListView_GetColumnOrderArray($hWnd), $s_Cols = ""
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
For $i = 1 To $a_Cols[0]
$s_Cols &= $a_Cols[$i] & $sSeparatorChar
Next
$s_Cols = StringTrimRight($s_Cols, 1)
Return $s_Cols
EndFunc
Func _GUICtrlListView_GetColumnOrderArray($hWnd)
Local $iColumns = _GUICtrlListView_GetColumnCount($hWnd)
Local $tBuffer = DllStructCreate("int[" & $iColumns & "]")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNORDERARRAY, $iColumns, DllStructGetPtr($tBuffer))
EndIf
Local $aBuffer[$iColumns + 1]
$aBuffer[0] = $iColumns
For $iI = 1 To $iColumns
$aBuffer[$iI] = DllStructGetData($tBuffer, 1, $iI)
Next
Return $aBuffer
EndFunc
Func _GUICtrlListView_GetColumnWidth($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOLUMNWIDTH, $iCol)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOLUMNWIDTH, $iCol, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetCounterPage($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETCOUNTPERPAGE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETCOUNTPERPAGE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetEditControl($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETEDITCONTROL))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETEDITCONTROL, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetEmptyText($hWnd)
Local $tText = DllStructCreate("char[4096]")
Local $iRet
If IsHWnd($hWnd) Then
Local $iText = DllStructGetSize($tText)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iText + 4096, $tMemMap)
Local $pText = $pMemory + $iText
DllStructSetData($tText, "Text", $pText)
_MemWrite($tMemMap, $pText, $pMemory, $iText)
$iRet = _SendMessage($hWnd, $LVM_GETEMPTYTEXT, 4096, $pMemory)
_MemRead($tMemMap, $pText, $tText, 4096)
_MemFree($tMemMap)
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETEMPTYTEXT, 4096, DllStructGetPtr($tText))
If $iRet = 0 Then Return SetError(-1, 0, "")
Return DllStructGetData($tText, 1)
EndIf
EndFunc
Func _GUICtrlListView_GetExtendedListViewStyle($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetFocusedGroup($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETFOCUSEDGROUP)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETFOCUSEDGROUP, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupInfo($hWnd, $iGroupID)
Local $tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_HEADER, $LVGF_ALIGN))
Local $iErr = @error
Local $aGroup[2]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
Return SetError($iErr, 0, $aGroup)
EndFunc
Func __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, $iMask)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFO, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFO, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Return SetError($iRet <> $iGroupID, 0, $tGroup)
EndFunc
Func _GUICtrlListView_GetGroupInfoByIndex($hWnd, $iIndex)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID))
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPINFOBYINDEX, $iIndex, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[3]
$aGroup[0] = _WinAPI_WideCharToMultiByte(DllStructGetData($tGroup, "Header"))
Select
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_CENTER) <> 0
$aGroup[1] = 1
Case BitAND(DllStructGetData($tGroup, "Align"), $LVGA_HEADER_RIGHT) <> 0
$aGroup[1] = 2
Case Else
$aGroup[1] = 0
EndSelect
$aGroup[2] = DllStructGetData($tGroup, "GroupID")
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupRect($hWnd, $iGroupID, $iGet = $LVGGR_GROUP)
Local $tGroup = DllStructCreate($tagRECT)
DllStructSetData($tGroup, "Top", $iGet)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $tGroup, 0, "wparam", "struct*")
Else
Local $iGroup = DllStructGetSize($tGroup)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup, $tMemMap)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
$iRet = _SendMessage($hWnd, $LVM_GETGROUPRECT, $iGroupID, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tGroup, $iGroup)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETGROUPRECT, $iGroupID, DllStructGetPtr($tGroup))
EndIf
Local $aGroup[4]
For $x = 0 To 3
$aGroup[$x] = DllStructGetData($tGroup, $x + 1)
Next
Return SetError($iRet = 0, 0, $aGroup)
EndFunc
Func _GUICtrlListView_GetGroupState($hWnd, $iGroupID, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETGROUPSTATE, $iGroupID, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetGroupViewEnabled($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISGROUPVIEWENABLED) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISGROUPVIEWENABLED, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetHeader($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETHEADER))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETHEADER, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotCursor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTCURSOR, 0, 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETHOTCURSOR, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetHotItem($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOTITEM)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOTITEM, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetHoverTime($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETHOVERTIME)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETHOVERTIME, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetImageList($hWnd, $iImageList)
Local $aImageList[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0, 0, "wparam", "lparam", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_GETIMAGELIST, $aImageList[$iImageList], 0))
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMark($hWnd)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $tMark, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark)
$iRet = _SendMessage($hWnd, $LVM_GETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Local $aMark[2]
$aMark[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aMark[1] = DllStructGetData($tMark, "Item")
Return SetError($iRet = 0, 0, $aMark)
EndFunc
Func _GUICtrlListView_GetInsertMarkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKCOLOR, $LVSIL_STATE, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetInsertMarkRect($hWnd)
Local $aRect[5]
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $tRECT, 0, "wparam", "struct*") <> 0
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
$aRect[0] = _SendMessage($hWnd, $LVM_GETINSERTMARKRECT, 0, $pMemory, 0, "wparam", "ptr") <> 0
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
$aRect[0] = GUICtrlSendMsg($hWnd, $LVM_GETINSERTMARKRECT, 0, DllStructGetPtr($tRECT)) <> 0
EndIf
$aRect[1] = DllStructGetData($tRECT, "Left")
$aRect[2] = DllStructGetData($tRECT, "Top")
$aRect[3] = DllStructGetData($tRECT, "Right")
$aRect[4] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetISearchString($hWnd)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer
If IsHWnd($hWnd) Then
If $bUnicode Then
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGW) + 1
Else
$iBuffer = _SendMessage($hWnd, $LVM_GETISEARCHSTRINGA) + 1
EndIf
Else
If $bUnicode Then
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, 0) + 1
Else
$iBuffer = GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, 0) + 1
EndIf
EndIf
If $iBuffer = 1 Then Return ""
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pMemory)
Else
_SendMessage($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pMemory)
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGW, 0, $pBuffer)
Else
GUICtrlSendMsg($hWnd, $LVM_GETISEARCHSTRINGA, 0, $pBuffer)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItem($hWnd, $iIndex, $iSubItem = 0)
Local $aItem[8]
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", BitOR($LVIF_GROUPID, $LVIF_IMAGE, $LVIF_INDENT, $LVIF_PARAM, $LVIF_STATE))
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "StateMask", -1)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Local $iState = DllStructGetData($tItem, "State")
If BitAND($iState, $LVIS_CUT) <> 0 Then $aItem[0] = BitOR($aItem[0], 1)
If BitAND($iState, $LVIS_DROPHILITED) <> 0 Then $aItem[0] = BitOR($aItem[0], 2)
If BitAND($iState, $LVIS_FOCUSED) <> 0 Then $aItem[0] = BitOR($aItem[0], 4)
If BitAND($iState, $LVIS_SELECTED) <> 0 Then $aItem[0] = BitOR($aItem[0], 8)
$aItem[1] = __GUICtrlListView_OverlayImageMaskToIndex($iState)
$aItem[2] = __GUICtrlListView_StateImageMaskToIndex($iState)
$aItem[3] = _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem)
$aItem[4] = DllStructGetData($tItem, "Image")
$aItem[5] = DllStructGetData($tItem, "Param")
$aItem[6] = DllStructGetData($tItem, "Indent")
$aItem[7] = DllStructGetData($tItem, "GroupID")
Return $aItem
EndFunc
Func _GUICtrlListView_GetItemChecked($hWnd, $iIndex)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tLVITEM = DllStructCreate($tagLVITEM)
Local $iSize = DllStructGetSize($tLVITEM)
If @error Then Return SetError($LV_ERR, $LV_ERR, False)
DllStructSetData($tLVITEM, "Mask", $LVIF_STATE)
DllStructSetData($tLVITEM, "Item", $iIndex)
DllStructSetData($tLVITEM, "StateMask", 0xffff)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tLVITEM, 0, "wparam", "struct*") <> 0
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tLVITEM)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr") <> 0
Else
$iRet = _SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr") <> 0
EndIf
_MemRead($tMemMap, $pMemory, $tLVITEM, $iSize)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tLVITEM)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem) <> 0
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem) <> 0
EndIf
EndIf
If Not $iRet Then Return SetError($LV_ERR, $LV_ERR, False)
Return BitAND(DllStructGetData($tLVITEM, "State"), 0x2000) <> 0
EndFunc
Func _GUICtrlListView_GetItemCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMCOUNT, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetItemCut($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_CUT) <> 0
EndFunc
Func _GUICtrlListView_GetItemDropHilited($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_DROPHILITED) <> 0
EndFunc
Func _GUICtrlListView_GetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tItem, $iItem)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_GetItemFocused($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_FOCUSED) <> 0
EndFunc
Func _GUICtrlListView_GetItemGroupID($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "GroupID")
EndFunc
Func _GUICtrlListView_GetItemImage($hWnd, $iIndex, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Image")
EndFunc
Func _GUICtrlListView_GetItemIndent($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Indent")
EndFunc
Func __GUICtrlListView_GetItemOverlayImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_OVERLAYMASK), 8)
EndFunc
Func _GUICtrlListView_GetItemParam($hWnd, $iIndex)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
_GUICtrlListView_GetItemEx($hWnd, $tItem)
Return DllStructGetData($tItem, "Param")
EndFunc
Func _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Local $aPoint[2], $iRet
Local $tPoint = DllStructCreate($tagPOINT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $tPoint, 0, "wparam", "struct*") Then Return $aPoint
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
If Not _SendMessage($hWnd, $LVM_GETITEMPOSITION, $iIndex, $pMemory, 0, "wparam", "ptr") Then Return $aPoint
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMPOSITION, $iIndex, DllStructGetPtr($tPoint))
If Not $iRet Then Return $aPoint
EndIf
$aPoint[0] = DllStructGetData($tPoint, "X")
$aPoint[1] = DllStructGetData($tPoint, "Y")
Return $aPoint
EndFunc
Func _GUICtrlListView_GetItemPositionX($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[0]
EndFunc
Func _GUICtrlListView_GetItemPositionY($hWnd, $iIndex)
Local $aPoint = _GUICtrlListView_GetItemPosition($hWnd, $iIndex)
Return $aPoint[1]
EndFunc
Func _GUICtrlListView_GetItemRect($hWnd, $iIndex, $iPart = 3)
Local $tRECT = _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart)
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetItemRectEx($hWnd, $iIndex, $iPart = 3)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iPart)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Return $tRECT
EndFunc
Func _GUICtrlListView_GetItemSelected($hWnd, $iIndex)
Return _GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_SELECTED) <> 0
EndFunc
Func _GUICtrlListView_GetItemSpacing($hWnd, $bSmall = False)
Local $iSpace
If IsHWnd($hWnd) Then
$iSpace = _SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall)
Else
$iSpace = GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0)
EndIf
Local $aSpace[2]
$aSpace[0] = BitAND($iSpace, 0xFFFF)
$aSpace[1] = BitShift($iSpace, 16)
Return $aSpace
EndFunc
Func _GUICtrlListView_GetItemSpacingX($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitAND(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
Else
Return BitAND(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 0xFFFF)
EndIf
EndFunc
Func _GUICtrlListView_GetItemSpacingY($hWnd, $bSmall = False)
If IsHWnd($hWnd) Then
Return BitShift(_SendMessage($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
Else
Return BitShift(GUICtrlSendMsg($hWnd, $LVM_GETITEMSPACING, $bSmall, 0), 16)
EndIf
EndFunc
Func _GUICtrlListView_GetItemState($hWnd, $iIndex, $iMask)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iIndex, $iMask)
EndIf
EndFunc
Func _GUICtrlListView_GetItemStateImage($hWnd, $iIndex)
Return BitShift(_GUICtrlListView_GetItemState($hWnd, $iIndex, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_GetItemText($hWnd, $iIndex, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[4096]")
Else
$tBuffer = DllStructCreate("char Text[4096]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "TextMax", 4096)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + 4096, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $bUnicode Then
_SendMessage($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
_SendMessage($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pText, $tBuffer, 4096)
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTW, $iIndex, $pItem)
Else
GUICtrlSendMsg($hWnd, $LVM_GETITEMTEXTA, $iIndex, $pItem)
EndIf
EndIf
Return DllStructGetData($tBuffer, "Text")
EndFunc
Func _GUICtrlListView_GetItemTextArray($hWnd, $iItem = -1)
Local $sItems = _GUICtrlListView_GetItemTextString($hWnd, $iItem)
If $sItems = "" Then
Local $aItems[1] = [0]
Return SetError($LV_ERR, $LV_ERR, $aItems)
EndIf
Return StringSplit($sItems, Opt('GUIDataSeparatorChar'))
EndFunc
Func _GUICtrlListView_GetItemTextString($hWnd, $iItem = -1)
Local $sRow = "", $sSeparatorChar = Opt('GUIDataSeparatorChar'), $iSelected
If $iItem = -1 Then
$iSelected = _GUICtrlListView_GetNextItem($hWnd)
Else
$iSelected = $iItem
EndIf
For $x = 0 To _GUICtrlListView_GetColumnCount($hWnd) - 1
$sRow &= _GUICtrlListView_GetItemText($hWnd, $iSelected, $x) & $sSeparatorChar
Next
Return StringTrimRight($sRow, 1)
EndFunc
Func _GUICtrlListView_GetNextItem($hWnd, $iStart = -1, $iSearch = 0, $iState = 8)
Local $aSearch[5] = [$LVNI_ALL, $LVNI_ABOVE, $LVNI_BELOW, $LVNI_TOLEFT, $LVNI_TORIGHT]
Local $iFlags = $aSearch[$iSearch]
If BitAND($iState, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_CUT)
If BitAND($iState, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_DROPHILITED)
If BitAND($iState, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_FOCUSED)
If BitAND($iState, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVNI_SELECTED)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETNEXTITEM, $iStart, $iFlags)
EndIf
EndFunc
Func _GUICtrlListView_GetNumberOfWorkAreas($hWnd)
Local $tBuffer = DllStructCreate("int Data")
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_SendMessage($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETNUMBEROFWORKAREAS, 0, DllStructGetPtr($tBuffer))
EndIf
Return DllStructGetData($tBuffer, "Data")
EndFunc
Func _GUICtrlListView_GetOrigin($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
$iRet = _SendMessage($hWnd, $LVM_GETORIGIN, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tPoint, $iPoint)
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETORIGIN, 0, DllStructGetPtr($tPoint))
EndIf
Local $aOrigin[2]
$aOrigin[0] = DllStructGetData($tPoint, "X")
$aOrigin[1] = DllStructGetData($tPoint, "Y")
Return SetError(@error, $iRet = 1, $aOrigin)
EndFunc
Func _GUICtrlListView_GetOriginX($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[0]
EndFunc
Func _GUICtrlListView_GetOriginY($hWnd)
Local $aOrigin = _GUICtrlListView_GetOrigin($hWnd)
Return $aOrigin[1]
EndFunc
Func _GUICtrlListView_GetOutlineColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETOUTLINECOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETOUTLINECOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedColumn($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOLUMN)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOLUMN, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetSelectedCount($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTEDCOUNT)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTEDCOUNT, 0, 0)
EndIf
EndFunc
Func __GUICtrlListView_GetCheckedIndices($hWnd)
Local $iCount = _GUICtrlListView_GetItemCount($hWnd)
Local $aSelected[$iCount + 1] = [0]
For $i = 0 To $iCount - 1
If _GUICtrlListView_GetItemChecked($hWnd, $i) Then
$aSelected[0] += 1
$aSelected[$aSelected[0]] = $i
EndIf
Next
ReDim $aSelected[$aSelected[0] + 1]
Return $aSelected
EndFunc
Func _GUICtrlListView_GetSelectedIndices($hWnd, $bArray = False)
Local $sIndices, $aIndices[1] = [0]
Local $iRet, $iCount = _GUICtrlListView_GetItemCount($hWnd)
For $iItem = 0 To $iCount
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETITEMSTATE, $iItem, $LVIS_SELECTED)
EndIf
If $iRet Then
If (Not $bArray) Then
If StringLen($sIndices) Then
$sIndices &= "|" & $iItem
Else
$sIndices = $iItem
EndIf
Else
ReDim $aIndices[UBound($aIndices) + 1]
$aIndices[0] = UBound($aIndices) - 1
$aIndices[UBound($aIndices) - 1] = $iItem
EndIf
EndIf
Next
If (Not $bArray) Then
Return String($sIndices)
Else
Return $aIndices
EndIf
EndFunc
Func _GUICtrlListView_GetSelectionMark($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETSELECTIONMARK)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETSELECTIONMARK, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetStringWidth($hWnd, $sString)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sString) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sString)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $tBuffer, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemRead($tMemMap, $pMemory, $tBuffer, $iBuffer)
_MemFree($tMemMap)
EndIf
Else
Local $pBuffer = DllStructGetPtr($tBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHW, 0, $pBuffer)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_GETSTRINGWIDTHA, 0, $pBuffer)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_GetSubItemRect($hWnd, $iIndex, $iSubItem, $iPart = 0)
Local $aPart[2] = [$LVIR_BOUNDS, $LVIR_ICON]
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Top", $iSubItem)
DllStructSetData($tRECT, "Left", $aPart[$iPart])
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_GETSUBITEMRECT, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETSUBITEMRECT, $iIndex, DllStructGetPtr($tRECT))
EndIf
Local $aRect[4]
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_GetTextBkColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTBKCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTBKCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetTextColor($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTEXTCOLOR)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTEXTCOLOR, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetToolTips($hWnd)
If IsHWnd($hWnd) Then
Return HWnd(_SendMessage($hWnd, $LVM_GETTOOLTIPS))
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_GETTOOLTIPS, 0, 0))
EndIf
EndFunc
Func _GUICtrlListView_GetTopIndex($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETTOPINDEX)
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETTOPINDEX, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_GetUnicodeFormat($hWnd)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_GETUNICODEFORMAT) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_GETUNICODEFORMAT, 0, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_GetView($hWnd)
Local $iView
If IsHWnd($hWnd) Then
$iView = _SendMessage($hWnd, $LVM_GETVIEW)
Else
$iView = GUICtrlSendMsg($hWnd, $LVM_GETVIEW, 0, 0)
EndIf
Switch $iView
Case $LV_VIEW_ICON
Return Int($LV_VIEW_ICON)
Case $LV_VIEW_DETAILS
Return Int($LV_VIEW_DETAILS)
Case $LV_VIEW_LIST
Return Int($LV_VIEW_LIST)
Case $LV_VIEW_SMALLICON
Return Int($LV_VIEW_SMALLICON)
Case $LV_VIEW_TILE
Return Int($LV_VIEW_TILE)
Case Else
Return -1
EndSwitch
EndFunc
Func _GUICtrlListView_GetViewDetails($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_DETAILS
EndFunc
Func _GUICtrlListView_GetViewLarge($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_ICON
EndFunc
Func _GUICtrlListView_GetViewList($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_LIST
EndFunc
Func _GUICtrlListView_GetViewSmall($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_SMALLICON
EndFunc
Func _GUICtrlListView_GetViewTile($hWnd)
Return _GUICtrlListView_GetView($hWnd) = $LV_VIEW_TILE
EndFunc
Func _GUICtrlListView_GetViewRect($hWnd)
Local $aRect[4] = [0, 0, 0, 0]
Local $iView = _GUICtrlListView_GetView($hWnd)
If ($iView <> 1) And ($iView <> 3) Then Return $aRect
Local $tRECT = DllStructCreate($tagRECT)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_SendMessage($hWnd, $LVM_GETVIEWRECT, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tRECT, $iRect)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_GETVIEWRECT, 0, DllStructGetPtr($tRECT))
EndIf
$aRect[0] = DllStructGetData($tRECT, "Left")
$aRect[1] = DllStructGetData($tRECT, "Top")
$aRect[2] = DllStructGetData($tRECT, "Right")
$aRect[3] = DllStructGetData($tRECT, "Bottom")
Return $aRect
EndFunc
Func _GUICtrlListView_HideColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_HitTest($hWnd, $iX = -1, $iY = -1)
Local $aTest[10]
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
Local $iTest = DllStructGetSize($tTest)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest, $pMemory, $iTest)
$aTest[0] = _SendMessage($hWnd, $LVM_HITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
$aTest[0] = GUICtrlSendMsg($hWnd, $LVM_HITTEST, 0, DllStructGetPtr($tTest))
EndIf
Local $iFlags = DllStructGetData($tTest, "Flags")
$aTest[1] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[2] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func __GUICtrlListView_IndexToOverlayImageMask($iIndex)
Return BitShift($iIndex, -8)
EndFunc
Func __GUICtrlListView_IndexToStateImageMask($iIndex)
Return BitShift($iIndex, -12)
EndFunc
Func _GUICtrlListView_InsertColumn($hWnd, $iIndex, $sText, $iWidth = 50, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = BitOR($LVCF_FMT, $LVCF_WIDTH, $LVCF_TEXT)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iFmt = $aAlign[$iAlign]
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
If $iAlign > 0 Then _GUICtrlListView_SetColumn($hWnd, $iRet, $sText, $iWidth, $iAlign, $iImage, $bOnRight)
Return $iRet
EndFunc
Func _GUICtrlListView_InsertGroup($hWnd, $iIndex, $iGroupID, $sHeader, $iAlign = 0)
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
Local $tGroup = DllStructCreate($tagLVGROUP)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_GROUPID)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "GroupID", $iGroupID)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_INSERTGROUP, $iIndex, $tGroup, 0, "wparam", "struct*")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTGROUP, $iIndex, DllStructGetPtr($tGroup))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertItem($hWnd, $sText, $iIndex = -1, $iImage = -1, $iParam = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iBuffer, $tBuffer, $iRet
If $iIndex = -1 Then $iIndex = 999999999
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Param", $iParam)
$iBuffer = StringLen($sText) + 1
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Text", DllStructGetPtr($tBuffer))
DllStructSetData($tItem, "TextMax", $iBuffer)
Local $iMask = BitOR($LVIF_TEXT, $LVIF_PARAM)
If $iImage >= 0 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Image", $iImage)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Or ($sText = -1) Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_INSERTITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_INSERTITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_InsertMarkHitTest($hWnd, $iX = -1, $iY = -1)
Local $iMode = Opt("MouseCoordMode", 1)
Local $aPos = MouseGetPos()
Opt("MouseCoordMode", $iMode)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $aPos[0])
DllStructSetData($tPoint, "Y", $aPos[1])
Local $aResult = DllCall("user32.dll", "bool", "ScreenToClient", "hwnd", $hWnd, "struct*", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
If $aResult[0] = 0 Then Return 0
If $iX = -1 Then $iX = DllStructGetData($tPoint, "X")
If $iY = -1 Then $iY = DllStructGetData($tPoint, "Y")
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tPoint, "X", $iX)
DllStructSetData($tPoint, "Y", $iY)
DllStructSetData($tMark, "Size", $iMark)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $tPoint, $tMark, 0, "struct*", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemM = _MemInit($hWnd, $iPoint + $iMark, $tMemMap)
Local $pMemP = $pMemM + $iPoint
_MemWrite($tMemMap, $tMark, $pMemM, $iMark)
_MemWrite($tMemMap, $tPoint, $pMemP, $iPoint)
_SendMessage($hWnd, $LVM_INSERTMARKHITTEST, $pMemP, $pMemM, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemM, $tMark, $iMark)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_INSERTMARKHITTEST, DllStructGetPtr($tPoint), DllStructGetPtr($tMark))
EndIf
Local $aTest[2]
$aTest[0] = DllStructGetData($tMark, "Flags") = $LVIM_AFTER
$aTest[1] = DllStructGetData($tMark, "Item")
Return $aTest
EndFunc
Func _GUICtrlListView_IsItemVisible($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_ISITEMVISIBLE, $iIndex) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_ISITEMVISIBLE, $iIndex, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_JustifyColumn($hWnd, $iIndex, $iAlign = -1)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $iMask = $LVCF_FMT
Local $iFmt = $aAlign[$iAlign]
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn, $tMemMap)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_MapIDToIndex($hWnd, $iID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPIDTOINDEX, $iID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPIDTOINDEX, $iID, 0)
EndIf
EndFunc
Func _GUICtrlListView_MapIndexToID($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MAPINDEXTOID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MAPINDEXTOID, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_MoveGroup($hWnd, $iGroupID, $iIndex = -1)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_MOVEGROUP, $iGroupID, $iIndex)
EndIf
EndFunc
Func __GUICtrlListView_OverlayImageMaskToIndex($iMask)
Return BitShift(BitAND($LVIS_OVERLAYMASK, $iMask), 8)
EndFunc
Func _GUICtrlListView_RedrawItems($hWnd, $iFirst, $iLast)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_REDRAWITEMS, $iFirst, $iLast) <> 0
EndIf
EndFunc
Func _GUICtrlListView_RegisterSortCallBack($hWnd, $vCompareType = 1, $bArrows = True, $sPrivateCallback = "__GUICtrlListView_Sort")
#Au3Stripper_Ignore_Funcs=$sPrivateCallback
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
If IsBool($vCompareType) Then $vCompareType = ($vCompareType) ? 1 : 0
Local $hHeader = _GUICtrlListView_GetHeader($hWnd)
ReDim $__g_aListViewSortInfo[UBound($__g_aListViewSortInfo) + 1][$__LISTVIEWCONSTANT_SORTINFOSIZE]
$__g_aListViewSortInfo[0][0] = UBound($__g_aListViewSortInfo) - 1
Local $iIndex = $__g_aListViewSortInfo[0][0]
$__g_aListViewSortInfo[$iIndex][1] = $hWnd
$__g_aListViewSortInfo[$iIndex][2] =  DllCallbackRegister($sPrivateCallback, "int", "int;int;hwnd")
$__g_aListViewSortInfo[$iIndex][3] = -1
$__g_aListViewSortInfo[$iIndex][4] = -1
$__g_aListViewSortInfo[$iIndex][5] = 1
$__g_aListViewSortInfo[$iIndex][6] = -1
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][8] = $vCompareType
$__g_aListViewSortInfo[$iIndex][9] = $bArrows
$__g_aListViewSortInfo[$iIndex][10] = $hHeader
Return $__g_aListViewSortInfo[$iIndex][2] <> 0
EndFunc
Func _GUICtrlListView_RemoveAllGroups($hWnd)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_REMOVEALLGROUPS)
Else
GUICtrlSendMsg($hWnd, $LVM_REMOVEALLGROUPS, 0, 0)
EndIf
EndFunc
Func _GUICtrlListView_RemoveGroup($hWnd, $iGroupID)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_REMOVEGROUP, $iGroupID)
Else
Return GUICtrlSendMsg($hWnd, $LVM_REMOVEGROUP, $iGroupID, 0)
EndIf
EndFunc
Func __GUICtrlListView_ReverseColorOrder($iColor)
Local $sH = Hex(String($iColor), 6)
Return '0x' & StringMid($sH, 5, 2) & StringMid($sH, 3, 2) & StringMid($sH, 1, 2)
EndFunc
Func _GUICtrlListView_Scroll($hWnd, $iDX, $iDY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SCROLL, $iDX, $iDY) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetBkColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetBkImage($hWnd, $sURL = "", $iStyle = 0, $iXOffset = 0, $iYOffset = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
If Not IsHWnd($hWnd) Then Return SetError($LV_ERR, $LV_ERR, False)
Local $aStyle[2] = [$LVBKIF_STYLE_NORMAL, $LVBKIF_STYLE_TILE]
Local $iBuffer = StringLen($sURL) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tImage = DllStructCreate($tagLVBKIMAGE)
Local $iRet = 0
If $sURL <> "" Then $iRet = $LVBKIF_SOURCE_URL
$iRet = BitOR($iRet, $aStyle[$iStyle])
DllStructSetData($tBuffer, "Text", $sURL)
DllStructSetData($tImage, "Flags", $iRet)
DllStructSetData($tImage, "XOffPercent", $iXOffset)
DllStructSetData($tImage, "YOffPercent", $iYOffset)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tImage, "Image", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $tImage, 0, "wparam", "struct*")
Else
Local $iImage = DllStructGetSize($tImage)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iImage + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iImage
DllStructSetData($tImage, "Image", $pText)
_MemWrite($tMemMap, $tImage, $pMemory, $iImage)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETBKIMAGEA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pImage = DllStructGetPtr($tImage)
DllStructSetData($tImage, "Image", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEW, 0, $pImage)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETBKIMAGEA, 0, $pImage)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetCallBackMask($hWnd, $iMask)
Local $iFlags = 0
If BitAND($iMask, 1) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_CUT)
If BitAND($iMask, 2) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_DROPHILITED)
If BitAND($iMask, 4) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_FOCUSED)
If BitAND($iMask, 8) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_SELECTED)
If BitAND($iMask, 16) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_OVERLAYMASK)
If BitAND($iMask, 32) <> 0 Then $iFlags = BitOR($iFlags, $LVIS_STATEIMAGEMASK)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCALLBACKMASK, $iFlags) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCALLBACKMASK, $iFlags, 0) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetColumn($hWnd, $iIndex, $sText, $iWidth = -1, $iAlign = -1, $iImage = -1, $bOnRight = False)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $aAlign[3] = [$LVCFMT_LEFT, $LVCFMT_RIGHT, $LVCFMT_CENTER]
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tColumn = DllStructCreate($tagLVCOLUMN)
Local $iMask = $LVCF_TEXT
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
$iMask = BitOR($iMask, $LVCF_FMT)
Local $iFmt = $aAlign[$iAlign]
If $iWidth <> -1 Then $iMask = BitOR($iMask, $LVCF_WIDTH)
If $iImage <> -1 Then
$iMask = BitOR($iMask, $LVCF_IMAGE)
$iFmt = BitOR($iFmt, $LVCFMT_COL_HAS_IMAGES, $LVCFMT_IMAGE)
Else
$iImage = 0
EndIf
If $bOnRight Then $iFmt = BitOR($iFmt, $LVCFMT_BITMAP_ON_RIGHT)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tColumn, "Mask", $iMask)
DllStructSetData($tColumn, "Fmt", $iFmt)
DllStructSetData($tColumn, "CX", $iWidth)
DllStructSetData($tColumn, "TextMax", $iBuffer)
DllStructSetData($tColumn, "Image", $iImage)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tColumn, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $tColumn, 0, "wparam", "struct*")
Else
Local $iColumn = DllStructGetSize($tColumn)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iColumn + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iColumn
DllStructSetData($tColumn, "Text", $pText)
_MemWrite($tMemMap, $tColumn, $pMemory, $iColumn)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNW, $iIndex, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNA, $iIndex, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pColumn = DllStructGetPtr($tColumn)
DllStructSetData($tColumn, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNW, $iIndex, $pColumn)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNA, $iIndex, $pColumn)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnOrder($hWnd, $sOrder)
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Return _GUICtrlListView_SetColumnOrderArray($hWnd, StringSplit($sOrder, $sSeparatorChar))
EndFunc
Func _GUICtrlListView_SetColumnOrderArray($hWnd, $aOrder)
Local $tBuffer = DllStructCreate("int[" & $aOrder[0] & "]")
For $iI = 1 To $aOrder[0]
DllStructSetData($tBuffer, 1, $aOrder[$iI], $iI)
Next
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $tBuffer, 0, "wparam", "struct*")
Else
Local $iBuffer = DllStructGetSize($tBuffer)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iBuffer, $tMemMap)
_MemWrite($tMemMap, $tBuffer, $pMemory, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNORDERARRAY, $aOrder[0], DllStructGetPtr($tBuffer))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetColumnWidth($hWnd, $iCol, $iWidth)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETCOLUMNWIDTH, $iCol, $iWidth)
EndIf
EndFunc
Func _GUICtrlListView_SetExtendedListViewStyle($hWnd, $iExStyle, $iExMask = 0)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETEXTENDEDLISTVIEWSTYLE, $iExMask, $iExStyle)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet
EndFunc
Func _GUICtrlListView_SetGroupInfo($hWnd, $iGroupID, $sHeader, $iAlign = 0, $iState = $LVGS_NORMAL)
Local $tGroup = 0
If BitAND($iState, $LVGS_SELECTED) Then
$tGroup = __GUICtrlListView_GetGroupInfoEx($hWnd, $iGroupID, BitOR($LVGF_GROUPID, $LVGF_ITEMS))
If DllStructGetData($tGroup, "GroupId") <> $iGroupID Or DllStructGetData($tGroup, "cItems") = 0 Then Return False
EndIf
Local $aAlign[3] = [$LVGA_HEADER_LEFT, $LVGA_HEADER_CENTER, $LVGA_HEADER_RIGHT]
If $iAlign < 0 Or $iAlign > 2 Then $iAlign = 0
Local $tHeader = _WinAPI_MultiByteToWideChar($sHeader)
Local $pHeader = DllStructGetPtr($tHeader)
Local $iHeader = StringLen($sHeader)
$tGroup = DllStructCreate($tagLVGROUP)
Local $pGroup = DllStructGetPtr($tGroup)
Local $iGroup = DllStructGetSize($tGroup)
Local $iMask = BitOR($LVGF_HEADER, $LVGF_ALIGN, $LVGF_STATE)
DllStructSetData($tGroup, "Size", $iGroup)
DllStructSetData($tGroup, "Mask", $iMask)
DllStructSetData($tGroup, "HeaderMax", $iHeader)
DllStructSetData($tGroup, "Align", $aAlign[$iAlign])
DllStructSetData($tGroup, "State", $iState)
DllStructSetData($tGroup, "StateMask", $iState)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iGroup + $iHeader, $tMemMap)
Local $pText = $pMemory + $iGroup
DllStructSetData($tGroup, "Header", $pText)
_MemWrite($tMemMap, $tGroup, $pMemory, $iGroup)
_MemWrite($tMemMap, $tHeader, $pText, $iHeader)
$iRet = _SendMessage($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pMemory)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
_SendMessage($hWnd, $LVM_SETGROUPINFO, 0, $pMemory)
_MemFree($tMemMap)
EndIf
_WinAPI_InvalidateRect($hWnd)
Else
DllStructSetData($tGroup, "Header", $pHeader)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, $iGroupID, $pGroup)
DllStructSetData($tGroup, "Mask", $LVGF_GROUPID)
DllStructSetData($tGroup, "GroupID", $iGroupID)
GUICtrlSendMsg($hWnd, $LVM_SETGROUPINFO, 0, $pGroup)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetHotCursor($hWnd, $hCursor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETHOTCURSOR, 0, $hCursor))
EndIf
EndFunc
Func _GUICtrlListView_SetHotItem($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOTITEM, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOTITEM, $iIndex, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetHoverTime($hWnd, $iTime)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETHOVERTIME, 0, $iTime)
EndIf
EndFunc
Func _GUICtrlListView_SetIconSpacing($hWnd, $iCX, $iCY)
Local $iRet, $aPadding[2]
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETICONSPACING, 0, _WinAPI_MakeLong($iCX, $iCY))
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
$aPadding[0] = BitAND($iRet, 0xFFFF)
$aPadding[1] = BitShift($iRet, 16)
Return $aPadding
EndFunc
Func _GUICtrlListView_SetImageList($hWnd, $hHandle, $iType = 0)
Local $aType[3] = [$LVSIL_NORMAL, $LVSIL_SMALL, $LVSIL_STATE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle, 0, "wparam", "handle", "handle")
Else
Return Ptr(GUICtrlSendMsg($hWnd, $LVM_SETIMAGELIST, $aType[$iType], $hHandle))
EndIf
EndFunc
Func _GUICtrlListView_SetInfoTip($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $tBuffer = _WinAPI_MultiByteToWideChar($sText)
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $iBuffer = StringLen($sText)
Local $tInfo = DllStructCreate($tagLVSETINFOTIP)
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
DllStructSetData($tInfo, "Item", $iIndex)
DllStructSetData($tInfo, "SubItem", $iSubItem)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $tInfo, 0, "wparam", "struct*")
Else
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iInfo + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iInfo
DllStructSetData($tInfo, "Text", $pText)
_MemWrite($tMemMap, $tInfo, $pMemory, $iInfo)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETINFOTIP, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
DllStructSetData($tInfo, "Text", $pBuffer)
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINFOTIP, 0, DllStructGetPtr($tInfo))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMark($hWnd, $iIndex, $bAfter = False)
Local $tMark = DllStructCreate($tagLVINSERTMARK)
Local $iMark = DllStructGetSize($tMark)
DllStructSetData($tMark, "Size", $iMark)
If $bAfter Then DllStructSetData($tMark, "Flags", $LVIM_AFTER)
DllStructSetData($tMark, "Item", $iIndex)
DllStructSetData($tMark, "Reserved", 0)
Local $iRet
If IsHWnd($hWnd) Then
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iMark, $tMemMap)
_MemWrite($tMemMap, $tMark, $pMemory, $iMark)
$iRet = _SendMessage($hWnd, $LVM_SETINSERTMARK, 0, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARK, 0, DllStructGetPtr($tMark))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetInsertMarkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETINSERTMARKCOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetItem($hWnd, $sText, $iIndex = 0, $iSubItem = 0, $iImage = -1, $iParam = -1, $iIndent = -1)
Local $pBuffer, $iBuffer
If $sText <> -1 Then
$iBuffer = StringLen($sText) + 1
Local $tBuffer
If _GUICtrlListView_GetUnicodeFormat($hWnd) Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
$pBuffer = DllStructGetPtr($tBuffer)
DllStructSetData($tBuffer, "Text", $sText)
Else
$iBuffer = 0
$pBuffer = -1
EndIf
Local $tItem = DllStructCreate($tagLVITEM)
Local $iMask = $LVIF_TEXT
If $iImage <> -1 Then $iMask = BitOR($iMask, $LVIF_IMAGE)
If $iParam <> -1 Then $iMask = BitOR($iMask, $LVIF_PARAM)
If $iIndent <> -1 Then $iMask = BitOR($iMask, $LVIF_INDENT)
DllStructSetData($tItem, "Mask", $iMask)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Text", $pBuffer)
DllStructSetData($tItem, "TextMax", $iBuffer)
DllStructSetData($tItem, "Image", $iImage)
DllStructSetData($tItem, "Param", $iParam)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemChecked($hWnd, $iIndex, $bCheck = True)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $pMemory, $tMemMap, $iRet
Local $tItem = DllStructCreate($tagLVITEM)
Local $pItem = DllStructGetPtr($tItem)
Local $iItem = DllStructGetSize($tItem)
If @error Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
If $iIndex <> -1 Then
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Return $iRet <> 0
EndIf
Else
If $bUnicode Then
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0
EndIf
EndIf
Else
For $x = 0 To _GUICtrlListView_GetItemCount($hWnd) - 1
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $x)
If ($bCheck) Then
DllStructSetData($tItem, "State", 0x2000)
Else
DllStructSetData($tItem, "State", 0x1000)
EndIf
DllStructSetData($tItem, "StateMask", 0xf000)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
If Not _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*") <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
$pMemory = _MemInit($hWnd, $iItem, $tMemMap)
_MemWrite($tMemMap, $tItem)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
If Not $iRet <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
Else
If $bUnicode Then
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
Else
If Not GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem) <> 0 Then Return SetError($LV_ERR, $LV_ERR, $LV_ERR)
EndIf
EndIf
Next
Return True
EndIf
Return False
EndFunc
Func _GUICtrlListView_SetItemCount($hWnd, $iItems)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMCOUNT, $iItems, BitOR($LVSICF_NOINVALIDATEALL, $LVSICF_NOSCROLL)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemCut($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_CUT
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_CUT)
EndFunc
Func _GUICtrlListView_SetItemDropHilited($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_DROPHILITED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_DROPHILITED)
EndFunc
Func _GUICtrlListView_SetItemEx($hWnd, ByRef $tItem)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If IsHWnd($hWnd) Then
Local $iItem = DllStructGetSize($tItem)
Local $iBuffer = DllStructGetData($tItem, "TextMax")
Local $pBuffer = DllStructGetData($tItem, "Text")
If $bUnicode Then $iBuffer *= 2
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
If $pBuffer <> 0 Then _MemWrite($tMemMap, $pBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
Else
Local $pItem = DllStructGetPtr($tItem)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemFocused($hWnd, $iIndex, $bEnabled = True)
Local $iState = 0
If $bEnabled Then $iState = $LVIS_FOCUSED
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $LVIS_FOCUSED)
EndFunc
Func _GUICtrlListView_SetItemGroupID($hWnd, $iIndex, $iGroupID)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_GROUPID)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "GroupID", $iGroupID)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemImage($hWnd, $iIndex, $iImage, $iSubItem = 0)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_IMAGE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
DllStructSetData($tItem, "Image", $iImage)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemIndent($hWnd, $iIndex, $iIndent)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_INDENT)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Indent", $iIndent)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func __GUICtrlListView_SetItemOverlayImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, __GUICtrlListView_IndexToOverlayImageMask($iImage), $LVIS_OVERLAYMASK)
EndFunc
Func _GUICtrlListView_SetItemParam($hWnd, $iIndex, $iParam)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_PARAM)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "Param", $iParam)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem)
EndFunc
Func _GUICtrlListView_SetItemPosition($hWnd, $iIndex, $iCX, $iCY)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION, $iIndex, _WinAPI_MakeLong($iCX, $iCY)) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetItemPosition32($hWnd, $iIndex, $iCX, $iCY)
Local $tPoint = DllStructCreate($tagPOINT)
DllStructSetData($tPoint, "X", $iCX)
DllStructSetData($tPoint, "Y", $iCY)
Local $iRet
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $tPoint, 0, "wparam", "struct*")
Else
Local $iPoint = DllStructGetSize($tPoint)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iPoint, $tMemMap)
_MemWrite($tMemMap, $tPoint)
$iRet = _SendMessage($hWnd, $LVM_SETITEMPOSITION32, $iIndex, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMPOSITION32, $iIndex, DllStructGetPtr($tPoint))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemSelected($hWnd, $iIndex, $bSelected = True, $bFocused = False)
Local $tStruct = DllStructCreate($tagLVITEM)
Local $iRet, $iSelected = 0, $iFocused = 0, $iSize, $tMemMap, $pMemory
If ($bSelected = True) Then $iSelected = $LVIS_SELECTED
If ($bFocused = True And $iIndex <> -1) Then $iFocused = $LVIS_FOCUSED
DllStructSetData($tStruct, "Mask", $LVIF_STATE)
DllStructSetData($tStruct, "Item", $iIndex)
DllStructSetData($tStruct, "State", BitOR($iSelected, $iFocused))
DllStructSetData($tStruct, "StateMask", BitOR($LVIS_SELECTED, $iFocused))
$iSize = DllStructGetSize($tStruct)
If IsHWnd($hWnd) Then
$pMemory = _MemInit($hWnd, $iSize, $tMemMap)
_MemWrite($tMemMap, $tStruct, $pMemory, $iSize)
$iRet = _SendMessage($hWnd, $LVM_SETITEMSTATE, $iIndex, $pMemory)
_MemFree($tMemMap)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMSTATE, $iIndex, DllStructGetPtr($tStruct))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetItemState($hWnd, $iIndex, $iState, $iStateMask)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tItem, "Mask", $LVIF_STATE)
DllStructSetData($tItem, "Item", $iIndex)
DllStructSetData($tItem, "State", $iState)
DllStructSetData($tItem, "StateMask", $iStateMask)
Return _GUICtrlListView_SetItemEx($hWnd, $tItem) <> 0
EndFunc
Func _GUICtrlListView_SetItemStateImage($hWnd, $iIndex, $iImage)
Return _GUICtrlListView_SetItemState($hWnd, $iIndex, BitShift($iImage, -12), $LVIS_STATEIMAGEMASK)
EndFunc
Func _GUICtrlListView_SetItemText($hWnd, $iIndex, $sText, $iSubItem = 0)
Local $bUnicode = _GUICtrlListView_GetUnicodeFormat($hWnd)
Local $iRet
If $iSubItem = -1 Then
Local $sSeparatorChar = Opt('GUIDataSeparatorChar')
Local $i_Cols = _GUICtrlListView_GetColumnCount($hWnd)
Local $a_Text = StringSplit($sText, $sSeparatorChar)
If $i_Cols > $a_Text[0] Then $i_Cols = $a_Text[0]
For $i = 1 To $i_Cols
$iRet = _GUICtrlListView_SetItemText($hWnd, $iIndex, $a_Text[$i], $i - 1)
If Not $iRet Then ExitLoop
Next
Return $iRet
EndIf
Local $iBuffer = StringLen($sText) + 1
Local $tBuffer
If $bUnicode Then
$tBuffer = DllStructCreate("wchar Text[" & $iBuffer & "]")
$iBuffer *= 2
Else
$tBuffer = DllStructCreate("char Text[" & $iBuffer & "]")
EndIf
Local $pBuffer = DllStructGetPtr($tBuffer)
Local $tItem = DllStructCreate($tagLVITEM)
DllStructSetData($tBuffer, "Text", $sText)
DllStructSetData($tItem, "Mask", $LVIF_TEXT)
DllStructSetData($tItem, "item", $iIndex)
DllStructSetData($tItem, "SubItem", $iSubItem)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
DllStructSetData($tItem, "Text", $pBuffer)
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $tItem, 0, "wparam", "struct*")
Else
Local $iItem = DllStructGetSize($tItem)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iItem + $iBuffer, $tMemMap)
Local $pText = $pMemory + $iItem
DllStructSetData($tItem, "Text", $pText)
_MemWrite($tMemMap, $tItem, $pMemory, $iItem)
_MemWrite($tMemMap, $tBuffer, $pText, $iBuffer)
If $bUnicode Then
$iRet = _SendMessage($hWnd, $LVM_SETITEMW, 0, $pMemory, 0, "wparam", "ptr")
Else
$iRet = _SendMessage($hWnd, $LVM_SETITEMA, 0, $pMemory, 0, "wparam", "ptr")
EndIf
_MemFree($tMemMap)
EndIf
Else
Local $pItem = DllStructGetPtr($tItem)
DllStructSetData($tItem, "Text", $pBuffer)
If $bUnicode Then
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMW, 0, $pItem)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETITEMA, 0, $pItem)
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetOutlineColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETOUTLINECOLOR, 0, $iColor)
EndIf
EndFunc
Func _GUICtrlListView_SetSelectedColumn($hWnd, $iCol)
If IsHWnd($hWnd) Then
_SendMessage($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol)
_WinAPI_InvalidateRect($hWnd)
Else
GUICtrlSendMsg($hWnd, $LVM_SETSELECTEDCOLUMN, $iCol, 0)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
EndFunc
Func _GUICtrlListView_SetSelectionMark($hWnd, $iIndex)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETSELECTIONMARK, 0, $iIndex)
EndIf
EndFunc
Func _GUICtrlListView_SetTextBkColor($hWnd, $iColor)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETTEXTBKCOLOR, 0, $iColor) <> 0
EndIf
EndFunc
Func _GUICtrlListView_SetTextColor($hWnd, $iColor)
Local $iRet
If IsHWnd($hWnd) Then
$iRet = _SendMessage($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect($hWnd)
Else
$iRet = GUICtrlSendMsg($hWnd, $LVM_SETTEXTCOLOR, 0, $iColor)
_WinAPI_InvalidateRect(GUICtrlGetHandle($hWnd))
EndIf
Return $iRet <> 0
EndFunc
Func _GUICtrlListView_SetToolTips($hWnd, $hToolTip)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip, 0, "wparam", "hwnd", "hwnd")
Else
Return HWnd(GUICtrlSendMsg($hWnd, $LVM_SETTOOLTIPS, 0, $hToolTip))
EndIf
EndFunc
Func _GUICtrlListView_SetUnicodeFormat($hWnd, $bUnicode)
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode)
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETUNICODEFORMAT, $bUnicode, 0)
EndIf
EndFunc
Func _GUICtrlListView_SetView($hWnd, $iView)
Local $aView[5] = [$LV_VIEW_ICON, $LV_VIEW_DETAILS, $LV_VIEW_LIST, $LV_VIEW_SMALLICON, $LV_VIEW_TILE]
If IsHWnd($hWnd) Then
Return _SendMessage($hWnd, $LVM_SETVIEW, $aView[$iView]) <> -1
Else
Return GUICtrlSendMsg($hWnd, $LVM_SETVIEW, $aView[$iView], 0) <> -1
EndIf
EndFunc
Func _GUICtrlListView_SetWorkAreas($hWnd, $iLeft, $iTop, $iRight, $iBottom)
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, "Left", $iLeft)
DllStructSetData($tRECT, "Top", $iTop)
DllStructSetData($tRECT, "Right", $iRight)
DllStructSetData($tRECT, "Bottom", $iBottom)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $tRECT, 0, "wparam", "struct*")
Else
Local $iRect = DllStructGetSize($tRECT)
Local $tMemMap
Local $pMemory = _MemInit($hWnd, $iRect, $tMemMap)
_MemWrite($tMemMap, $tRECT, $pMemory, $iRect)
_SendMessage($hWnd, $LVM_SETWORKAREAS, 1, $pMemory, 0, "wparam", "ptr")
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SETWORKAREAS, 1, DllStructGetPtr($tRECT))
EndIf
EndFunc
Func _GUICtrlListView_SimpleSort($hWnd, ByRef $vSortSense, $iCol, $bToggleSense = True)
Local $iItemCount = _GUICtrlListView_GetItemCount($hWnd)
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $vSeparatorChar = Opt('GUIDataSeparatorChar')
Local $iColumnCount = _GUICtrlListView_GetColumnCount($hWnd)
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $aListViewItems[$iItemCount][$iColumnCount + 2]
Local $aSelectedItems = StringSplit(_GUICtrlListView_GetSelectedIndices($hWnd), $vSeparatorChar)
Local $aCheckedItems = __GUICtrlListView_GetCheckedIndices($hWnd)
Local $sItemText, $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hWnd, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hWnd, $i, False)
_GUICtrlListView_SetItemChecked($hWnd, $i, False)
For $j = 0 To $iColumnCount - 1
$sItemText = StringStripWS(_GUICtrlListView_GetItemText($hWnd, $i, $j), $STR_STRIPTRAILING)
If (StringIsFloat($sItemText) Or StringIsInt($sItemText)) Then
$aListViewItems[$i][$j] = Number($sItemText)
Else
$aListViewItems[$i][$j] = $sItemText
EndIf
Next
$aListViewItems[$i][$iIndexValue] = $i
$aListViewItems[$i][$iItemParam] = _GUICtrlListView_GetItemParam($hWnd, $i)
Next
_ArraySort($aListViewItems, $iDescending, 0, 0, $iCol)
For $i = 0 To $iItemCount - 1
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hWnd, $i, $aListViewItems[$i][$j], $j)
Next
_GUICtrlListView_SetItemParam($hWnd, $i, $aListViewItems[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aSelectedItems[$j] Then
If $aListViewItems[$i][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hWnd, $i, True, True)
Else
_GUICtrlListView_SetItemSelected($hWnd, $i, True)
EndIf
ExitLoop
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewItems[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hWnd, $i, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
EndIf
EndFunc
#Au3Stripper_Ignore_Funcs=__GUICtrlListView_Sort
Func __GUICtrlListView_Sort($nItem1, $nItem2, $hWnd)
Local $iIndex, $sVal1, $sVal2, $nResult
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
If $__g_aListViewSortInfo[$iIndex][3] = $__g_aListViewSortInfo[$iIndex][4] Then
If Not $__g_aListViewSortInfo[$iIndex][7] Then
$__g_aListViewSortInfo[$iIndex][5] *= -1
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
Else
$__g_aListViewSortInfo[$iIndex][7] = 1
EndIf
$__g_aListViewSortInfo[$iIndex][6] = $__g_aListViewSortInfo[$iIndex][3]
$sVal1 = _GUICtrlListView_GetItemText($hWnd, $nItem1, $__g_aListViewSortInfo[$iIndex][3])
$sVal2 = _GUICtrlListView_GetItemText($hWnd, $nItem2, $__g_aListViewSortInfo[$iIndex][3])
If $__g_aListViewSortInfo[$iIndex][8] = 1 Then
If (StringIsFloat($sVal1) Or StringIsInt($sVal1)) Then $sVal1 = Number($sVal1)
If (StringIsFloat($sVal2) Or StringIsInt($sVal2)) Then $sVal2 = Number($sVal2)
EndIf
If $__g_aListViewSortInfo[$iIndex][8] < 2 Then
$nResult = 0
If $sVal1 < $sVal2 Then
$nResult = -1
ElseIf $sVal1 > $sVal2 Then
$nResult = 1
EndIf
Else
$nResult = DllCall('shlwapi.dll', 'int', 'StrCmpLogicalW', 'wstr', $sVal1, 'wstr', $sVal2)[0]
EndIf
$nResult = $nResult * $__g_aListViewSortInfo[$iIndex][5]
Return $nResult
EndFunc
Func _GUICtrlListView_SortItems($hWnd, $iCol)
Local $iRet, $iIndex, $pFunction, $hHeader, $iFormat
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
$iIndex = $x
ExitLoop
EndIf
Next
$pFunction = DllCallbackGetPtr($__g_aListViewSortInfo[$iIndex][2])
$__g_aListViewSortInfo[$iIndex][3] = $iCol
$__g_aListViewSortInfo[$iIndex][7] = 0
$__g_aListViewSortInfo[$iIndex][4] = $__g_aListViewSortInfo[$iIndex][6]
$iRet = _SendMessage($hWnd, $LVM_SORTITEMSEX, $hWnd, $pFunction, 0, "hwnd", "ptr")
If $iRet <> 0 Then
If $__g_aListViewSortInfo[$iIndex][9] Then
$hHeader = $__g_aListViewSortInfo[$iIndex][10]
For $x = 0 To _GUICtrlHeader_GetItemCount($hHeader) - 1
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $x)
If BitAND($iFormat, $HDF_SORTDOWN) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTDOWN))
ElseIf BitAND($iFormat, $HDF_SORTUP) Then
_GUICtrlHeader_SetItemFormat($hHeader, $x, BitXOR($iFormat, $HDF_SORTUP))
EndIf
Next
$iFormat = _GUICtrlHeader_GetItemFormat($hHeader, $iCol)
If $__g_aListViewSortInfo[$iIndex][5] = 1 Then
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTUP))
Else
_GUICtrlHeader_SetItemFormat($hHeader, $iCol, BitOR($iFormat, $HDF_SORTDOWN))
EndIf
EndIf
EndIf
Return $iRet <> 0
EndFunc
Func __GUICtrlListView_StateImageMaskToIndex($iMask)
Return BitShift(BitAND($iMask, $LVIS_STATEIMAGEMASK), 12)
EndFunc
Func _GUICtrlListView_SubItemHitTest($hWnd, $iX = -1, $iY = -1)
Local $iTest, $tTest, $pMemory, $tMemMap, $iFlags, $aTest[11]
If $iX = -1 Then $iX = _WinAPI_GetMousePosX(True, $hWnd)
If $iY = -1 Then $iY = _WinAPI_GetMousePosY(True, $hWnd)
$tTest = DllStructCreate($tagLVHITTESTINFO)
DllStructSetData($tTest, "X", $iX)
DllStructSetData($tTest, "Y", $iY)
If IsHWnd($hWnd) Then
If _WinAPI_InProcess($hWnd, $__g_hLVLastWnd) Then
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $tTest, 0, "wparam", "struct*")
Else
$iTest = DllStructGetSize($tTest)
$pMemory = _MemInit($hWnd, $iTest, $tMemMap)
_MemWrite($tMemMap, $tTest)
_SendMessage($hWnd, $LVM_SUBITEMHITTEST, 0, $pMemory, 0, "wparam", "ptr")
_MemRead($tMemMap, $pMemory, $tTest, $iTest)
_MemFree($tMemMap)
EndIf
Else
GUICtrlSendMsg($hWnd, $LVM_SUBITEMHITTEST, 0, DllStructGetPtr($tTest))
EndIf
$iFlags = DllStructGetData($tTest, "Flags")
$aTest[0] = DllStructGetData($tTest, "Item")
$aTest[1] = DllStructGetData($tTest, "SubItem")
$aTest[2] = BitAND($iFlags, $LVHT_NOWHERE) <> 0
$aTest[3] = BitAND($iFlags, $LVHT_ONITEMICON) <> 0
$aTest[4] = BitAND($iFlags, $LVHT_ONITEMLABEL) <> 0
$aTest[5] = BitAND($iFlags, $LVHT_ONITEMSTATEICON) <> 0
$aTest[6] = BitAND($iFlags, $LVHT_ONITEM) <> 0
$aTest[7] = BitAND($iFlags, $LVHT_ABOVE) <> 0
$aTest[8] = BitAND($iFlags, $LVHT_BELOW) <> 0
$aTest[9] = BitAND($iFlags, $LVHT_TOLEFT) <> 0
$aTest[10] = BitAND($iFlags, $LVHT_TORIGHT) <> 0
Return $aTest
EndFunc
Func _GUICtrlListView_UnRegisterSortCallBack($hWnd)
If Not IsHWnd($hWnd) Then $hWnd = GUICtrlGetHandle($hWnd)
For $x = 1 To $__g_aListViewSortInfo[0][0]
If $hWnd = $__g_aListViewSortInfo[$x][1] Then
DllCallbackFree($__g_aListViewSortInfo[$x][2])
__GUICtrlListView_ArrayDelete($__g_aListViewSortInfo, $x)
$__g_aListViewSortInfo[0][0] -= 1
ExitLoop
EndIf
Next
EndFunc
Global Const $COLOR_AQUA = 0x00FFFF
Global Const $COLOR_BLACK = 0x000000
Global Const $COLOR_BLUE = 0x0000FF
Global Const $COLOR_CREAM = 0xFFFBF0
Global Const $COLOR_FUCHSIA = 0xFF00FF
Global Const $COLOR_GRAY = 0x808080
Global Const $COLOR_GREEN = 0x008000
Global Const $COLOR_LIME = 0x00FF00
Global Const $COLOR_MAROON = 0x8B1C62
Global Const $COLOR_MEDBLUE = 0x0002C4
Global Const $COLOR_MEDGRAY = 0xA0A0A4
Global Const $COLOR_MONEYGREEN = 0xC0DCC0
Global Const $COLOR_NAVY = 0x000080
Global Const $COLOR_OLIVE = 0x808000
Global Const $COLOR_PURPLE = 0x800080
Global Const $COLOR_RED = 0xFF0000
Global Const $COLOR_SILVER = 0xC0C0C0
Global Const $COLOR_SKYBLUE = 0xA6CAF0
Global Const $COLOR_TEAL = 0x008080
Global Const $COLOR_WHITE = 0xFFFFFF
Global Const $COLOR_YELLOW = 0xFFFF00
Global Const $CLR_NONE = 0xFFFFFFFF
Global Const $CLR_DEFAULT = 0xFF000000
Global Const $CLR_AQUA = 0xFFFF00
Global Const $CLR_BLACK = 0x000000
Global Const $CLR_BLUE = 0xFF0000
Global Const $CLR_CREAM = 0xF0FBFF
Global Const $CLR_FUCHSIA = 0xFF00FF
Global Const $CLR_GRAY = 0x808080
Global Const $CLR_GREEN = 0x008000
Global Const $CLR_LIME = 0x00FF00
Global Const $CLR_MAROON = 0x621C8B
Global Const $CLR_MEDBLUE = 0xC40200
Global Const $CLR_MEDGRAY = 0xA4A0A0
Global Const $CLR_MONEYGREEN = 0xC0DCC0
Global Const $CLR_NAVY = 0x800000
Global Const $CLR_OLIVE = 0x008080
Global Const $CLR_PURPLE = 0x800080
Global Const $CLR_RED = 0x0000FF
Global Const $CLR_SILVER = 0xC0C0C0
Global Const $CLR_SKYBLUE = 0xF0CAA6
Global Const $CLR_TEAL = 0x808000
Global Const $CLR_WHITE = 0xFFFFFF
Global Const $CLR_YELLOW = 0x00FFFF
Global Const $CC_ANYCOLOR = 0x0100
Global Const $CC_FULLOPEN = 0x0002
Global Const $CC_RGBINIT = 0x0001
Global Const $ILC_MASK = 0x00000001
Global Const $ILC_COLOR = 0x00000000
Global Const $ILC_COLORDDB = 0x000000FE
Global Const $ILC_COLOR4 = 0x00000004
Global Const $ILC_COLOR8 = 0x00000008
Global Const $ILC_COLOR16 = 0x00000010
Global Const $ILC_COLOR24 = 0x00000018
Global Const $ILC_COLOR32 = 0x00000020
Global Const $ILC_PALETTE = 0x00000800
Global Const $ILC_MIRROR = 0x00002000
Global Const $ILC_PERITEMMIRROR = 0x00008000
Global Const $ILCF_MOVE = 0x0
Global Const $ILCF_SWAP = 0x1
Global Const $ILD_NORMAL = 0x00000000
Global Const $ILD_TRANSPARENT = 0x00000001
Global Const $ILD_BLEND25 = 0x00000002
Global Const $ILD_BLEND50 = 0x00000004
Global Const $ILD_MASK = 0x00000010
Global Const $ILD_IMAGE = 0x00000020
Global Const $ILD_ROP = 0x00000040
Global Const $ILD_OVERLAYMASK = 0x00000F00
Global Const $ILS_NORMAL = 0x00000000
Global Const $ILS_GLOW = 0x00000001
Global Const $ILS_SHADOW = 0x00000002
Global Const $ILS_SATURATE = 0x00000004
Global Const $ILS_ALPHA = 0x00000008
Global Const $HGDI_ERROR = Ptr(-1)
Global Const $INVALID_HANDLE_VALUE = Ptr(-1)
Global Const $CLR_INVALID = -1
Global Const $MB_PRECOMPOSED = 0x01
Global Const $MB_COMPOSITE = 0x02
Global Const $MB_USEGLYPHCHARS = 0x04
Global Const $ULW_ALPHA = 0x02
Global Const $ULW_COLORKEY = 0x01
Global Const $ULW_OPAQUE = 0x04
Global Const $ULW_EX_NORESIZE = 0x08
Global Const $WH_CALLWNDPROC = 4
Global Const $WH_CALLWNDPROCRET = 12
Global Const $WH_CBT = 5
Global Const $WH_DEBUG = 9
Global Const $WH_FOREGROUNDIDLE = 11
Global Const $WH_GETMESSAGE = 3
Global Const $WH_JOURNALPLAYBACK = 1
Global Const $WH_JOURNALRECORD = 0
Global Const $WH_KEYBOARD = 2
Global Const $WH_KEYBOARD_LL = 13
Global Const $WH_MOUSE = 7
Global Const $WH_MOUSE_LL = 14
Global Const $WH_MSGFILTER = -1
Global Const $WH_SHELL = 10
Global Const $WH_SYSMSGFILTER = 6
Global Const $WPF_ASYNCWINDOWPLACEMENT = 0x04
Global Const $WPF_RESTORETOMAXIMIZED = 0x02
Global Const $WPF_SETMINPOSITION = 0x01
Global Const $KF_EXTENDED = 0x0100
Global Const $KF_ALTDOWN = 0x2000
Global Const $KF_UP = 0x8000
Global Const $LLKHF_EXTENDED = BitShift($KF_EXTENDED, 8)
Global Const $LLKHF_INJECTED = 0x10
Global Const $LLKHF_ALTDOWN = BitShift($KF_ALTDOWN, 8)
Global Const $LLKHF_UP = BitShift($KF_UP, 8)
Global Const $OFN_ALLOWMULTISELECT = 0x00000200
Global Const $OFN_CREATEPROMPT = 0x00002000
Global Const $OFN_DONTADDTORECENT = 0x02000000
Global Const $OFN_ENABLEHOOK = 0x00000020
Global Const $OFN_ENABLEINCLUDENOTIFY = 0x00400000
Global Const $OFN_ENABLESIZING = 0x00800000
Global Const $OFN_ENABLETEMPLATE = 0x00000040
Global Const $OFN_ENABLETEMPLATEHANDLE = 0x00000080
Global Const $OFN_EXPLORER = 0x00080000
Global Const $OFN_EXTENSIONDIFFERENT = 0x00000400
Global Const $OFN_FILEMUSTEXIST = 0x00001000
Global Const $OFN_FORCESHOWHIDDEN = 0x10000000
Global Const $OFN_HIDEREADONLY = 0x00000004
Global Const $OFN_LONGNAMES = 0x00200000
Global Const $OFN_NOCHANGEDIR = 0x00000008
Global Const $OFN_NODEREFERENCELINKS = 0x00100000
Global Const $OFN_NOLONGNAMES = 0x00040000
Global Const $OFN_NONETWORKBUTTON = 0x00020000
Global Const $OFN_NOREADONLYRETURN = 0x00008000
Global Const $OFN_NOTESTFILECREATE = 0x00010000
Global Const $OFN_NOVALIDATE = 0x00000100
Global Const $OFN_OVERWRITEPROMPT = 0x00000002
Global Const $OFN_PATHMUSTEXIST = 0x00000800
Global Const $OFN_READONLY = 0x00000001
Global Const $OFN_SHAREAWARE = 0x00004000
Global Const $OFN_SHOWHELP = 0x00000010
Global Const $OFN_EX_NOPLACESBAR = 0x00000001
Global Const $STD_CUT = 0
Global Const $STD_COPY = 1
Global Const $STD_PASTE = 2
Global Const $STD_UNDO = 3
Global Const $STD_REDOW = 4
Global Const $STD_DELETE = 5
Global Const $STD_FILENEW = 6
Global Const $STD_FILEOPEN = 7
Global Const $STD_FILESAVE = 8
Global Const $STD_PRINTPRE = 9
Global Const $STD_PROPERTIES = 10
Global Const $STD_HELP = 11
Global Const $STD_FIND = 12
Global Const $STD_REPLACE = 13
Global Const $STD_PRINT = 14
Global Const $KB_SENDSPECIAL = 0
Global Const $KB_SENDRAW = 1
Global Const $KB_CAPSOFF = 0
Global Const $KB_CAPSON = 1
Global Const $S_OK = 0x00000000
Global Const $E_ABORT = 0x80004004
Global Const $E_ACCESSDENIED = 0x80070005
Global Const $E_FAIL = 0x80004005
Global Const $E_HANDLE = 0x80070006
Global Const $E_INVALIDARG = 0x80070057
Global Const $E_NOINTERFACE = 0x80004002
Global Const $E_NOTIMPL = 0x80004001
Global Const $E_OUTOFMEMORY = 0x8007000E
Global Const $E_POINTER = 0x80004003
Global Const $E_UNEXPECTED = 0x8000FFFF
Global Const $__IMAGELISTCONSTANT_IMAGE_BITMAP = 0
Func _GUIImageList_Add($hWnd, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_Add", "handle", $hWnd, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddMasked($hWnd, $hImage, $iMask = 0)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_AddMasked", "handle", $hWnd, "handle", $hImage, "dword", $iMask)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_AddBitmap($hWnd, $sImage, $sMask = "")
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Local $hImage = _WinAPI_LoadImage(0, $sImage, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hImage = 0 Then Return SetError(_WinAPI_GetLastError(), 1, -1)
Local $hMask = 0
If $sMask <> "" Then
$hMask = _WinAPI_LoadImage(0, $sMask, $__IMAGELISTCONSTANT_IMAGE_BITMAP, $aSize[0], $aSize[1], $LR_LOADFROMFILE)
If $hMask = 0 Then Return SetError(_WinAPI_GetLastError(), 2, -1)
EndIf
Local $iRet = _GUIImageList_Add($hWnd, $hImage, $hMask)
_WinAPI_DeleteObject($hImage)
If $hMask <> 0 Then _WinAPI_DeleteObject($hMask)
Return $iRet
EndFunc
Func _GUIImageList_AddIcon($hWnd, $sFilePath, $iIndex = 0, $bLarge = False)
Local $iRet, $tIcon = DllStructCreate("handle Handle")
If $bLarge Then
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, $tIcon, 0, 1)
Else
$iRet = _WinAPI_ExtractIconEx($sFilePath, $iIndex, 0, $tIcon, 1)
EndIf
If $iRet <= 0 Then Return SetError(-1, $iRet, -1)
Local $hIcon = DllStructGetData($tIcon, "Handle")
$iRet = _GUIImageList_ReplaceIcon($hWnd, -1, $hIcon)
_WinAPI_DestroyIcon($hIcon)
If $iRet = -1 Then Return SetError(-2, $iRet, -1)
Return $iRet
EndFunc
Func _GUIImageList_BeginDrag($hWnd, $iTrack, $iXHotSpot, $iYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_BeginDrag", "handle", $hWnd, "int", $iTrack, "int", $iXHotSpot, "int", $iYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Copy($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_MOVE)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Create($iCX = 16, $iCY = 16, $iColor = 4, $iOptions = 0, $iInitial = 4, $iGrow = 4)
Local Const $aColor[7] = [$ILC_COLOR, $ILC_COLOR4, $ILC_COLOR8, $ILC_COLOR16, $ILC_COLOR24, $ILC_COLOR32, $ILC_COLORDDB]
Local $iFlags = 0
If BitAND($iOptions, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MASK)
If BitAND($iOptions, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILC_MIRROR)
If BitAND($iOptions, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILC_PERITEMMIRROR)
$iFlags = BitOR($iFlags, $aColor[$iColor])
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Create", "int", $iCX, "int", $iCY, "uint", $iFlags, "int", $iInitial, "int", $iGrow)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Destroy($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Destroy", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DestroyIcon($hIcon)
Return _WinAPI_DestroyIcon($hIcon)
EndFunc
Func _GUIImageList_DragEnter($hWnd, $iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragEnter", "hwnd", $hWnd, "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragLeave($hWnd)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragLeave", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragMove($iX, $iY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragMove", "int", $iX, "int", $iY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DragShowNolock($bShow)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DragShowNolock", "bool", $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Draw($hWnd, $iIndex, $hDC, $iX, $iY, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Draw", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_DrawEx($hWnd, $iIndex, $hDC, $iX, $iY, $iDX = 0, $iDY = 0, $iRGBBk = 0xFFFFFFFF, $iRGBFg = 0xFFFFFFFF, $iStyle = 0)
If $iDX = -1 Then $iDX = 0
If $iDY = -1 Then $iDY = 0
If $iRGBBk = -1 Then $iRGBBk = 0xFFFFFFFF
If $iRGBFg = -1 Then $iRGBFg = 0xFFFFFFFF
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_DrawEx", "handle", $hWnd, "int", $iIndex, "handle", $hDC, "int", $iX, "int", $iY,  "int", $iDX, "int", $iDY, "dword", $iRGBBk, "dword", $iRGBFg, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Duplicate($hWnd)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Duplicate", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_EndDrag()
DllCall("comctl32.dll", "none", "ImageList_EndDrag")
If @error Then Return SetError(@error, @extended)
EndFunc
Func _GUIImageList_GetBkColor($hWnd)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_GetBkColor", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIcon($hWnd, $iIndex, $iStyle = 0)
Local $iFlags = 0
If BitAND($iStyle, 1) <> 0 Then $iFlags = BitOR($iFlags, $ILD_TRANSPARENT)
If BitAND($iStyle, 2) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND25)
If BitAND($iStyle, 4) <> 0 Then $iFlags = BitOR($iFlags, $ILD_BLEND50)
If BitAND($iStyle, 8) <> 0 Then $iFlags = BitOR($iFlags, $ILD_MASK)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $hWnd, "int", $iIndex, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetIconHeight($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[1]
EndFunc
Func _GUIImageList_GetIconSize($hWnd)
Local $aSize[2]
Local $tPoint = _GUIImageList_GetIconSizeEx($hWnd)
$aSize[0] = DllStructGetData($tPoint, "X")
$aSize[1] = DllStructGetData($tPoint, "Y")
Return $aSize
EndFunc
Func _GUIImageList_GetIconSizeEx($hWnd)
Local $tPoint = DllStructCreate($tagPOINT)
Local $pPointX = DllStructGetPtr($tPoint, "X")
Local $pPointY = DllStructGetPtr($tPoint, "Y")
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetIconSize", "hwnd", $hWnd, "struct*", $pPointX, "struct*", $pPointY)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tPoint)
EndFunc
Func _GUIImageList_GetIconWidth($hWnd)
Local $aSize = _GUIImageList_GetIconSize($hWnd)
Return $aSize[0]
EndFunc
Func _GUIImageList_GetImageCount($hWnd)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_GetImageCount", "handle", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_GetImageInfoEx($hWnd, $iIndex)
Local $tImage = DllStructCreate($tagIMAGEINFO)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_GetImageInfo", "handle", $hWnd, "int", $iIndex, "struct*", $tImage)
If @error Then Return SetError(@error, @extended, 0)
Return SetExtended($aResult[0], $tImage)
EndFunc
Func _GUIImageList_Merge($hWnd1, $iIndex1, $hWnd2, $iIndex2, $iDX, $iDY)
Local $aResult = DllCall("comctl32.dll", "handle", "ImageList_Merge", "handle", $hWnd1, "int", $iIndex1,  "handle", $hWnd2, "int", $iIndex2, "int", $iDX, "int", $iDY)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _GUIImageList_Remove($hWnd, $iIndex = -1)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Remove", "handle", $hWnd, "int", $iIndex)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Replace($hWnd, $iIndex, $hImage, $hMask = 0)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Replace", "handle", $hWnd, "int", $iIndex, "handle", $hImage, "handle", $hMask)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_ReplaceIcon($hWnd, $iIndex, $hIcon)
Local $aResult = DllCall("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $hWnd, "int", $iIndex, "handle", $hIcon)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetBkColor($hWnd, $iClrBk)
Local $aResult = DllCall("comctl32.dll", "dword", "ImageList_SetBkColor", "handle", $hWnd, "dword", $iClrBk)
If @error Then Return SetError(@error, @extended, $CLR_NONE)
Return $aResult[0]
EndFunc
Func _GUIImageList_SetDragCursorImage($hWnd, $iDrag, $iDXHotSpot, $iDYHotSpot)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetDragCursorImage", "handle", $hWnd, "int", $iDrag, "int", $iDXHotSpot, "int", $iDYHotSpot)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetIconSize($hWnd, $iCX, $iCY)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetIconSize", "handle", $hWnd, "int", $iCX, "int", $iCY)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetImageCount($hWnd, $iNewCount)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetImageCount", "handle", $hWnd, "uint", $iNewCount)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_SetOverlayImage($hWnd, $iImage, $iOverlay)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $hWnd, "int", $iImage, "int", $iOverlay)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Func _GUIImageList_Swap($hWnd, $iSource, $iDestination)
Local $aResult = DllCall("comctl32.dll", "bool", "ImageList_Copy", "handle", $hWnd, "int", $iDestination, "handle", $hWnd, "int", $iSource, "uint", $ILCF_SWAP)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0] <> 0
EndFunc
Global Const $KLF_ACTIVATE = 0x00000001
Global Const $KLF_NOTELLSHELL = 0x00000080
Global Const $KLF_REORDER = 0x00000008
Global Const $KLF_REPLACELANG = 0x00000010
Global Const $KLF_RESET = 0x40000000
Global Const $KLF_SETFORPROCESS = 0x00000100
Global Const $KLF_SHIFTLOCK = 0x00010000
Global Const $KLF_SUBSTITUTE_OK = 0x00000002
Global Const $HKL_NEXT = 1
Global Const $HKL_PREV = 0
Global Const $AW_ACTIVATE = 0x00020000
Global Const $AW_BLEND = 0x00080000
Global Const $AW_CENTER = 0x00000010
Global Const $AW_HIDE = 0x00010000
Global Const $AW_HOR_NEGATIVE = 0x00000002
Global Const $AW_HOR_POSITIVE = 0x00000001
Global Const $AW_SLIDE = 0x00040000
Global Const $AW_VER_NEGATIVE = 0x00000008
Global Const $AW_VER_POSITIVE = 0x00000004
Global Const $BSF_ALLOWSFW = 0x0080
Global Const $BSF_FLUSHDISK = 0x0004
Global Const $BSF_FORCEIFHUNG = 0x0020
Global Const $BSF_IGNORECURRENTTASK = 0x0002
Global Const $BSF_NOHANG = 0x0008
Global Const $BSF_NOTIMEOUTIFNOTHUNG = 0x0040
Global Const $BSF_POSTMESSAGE = 0x0010
Global Const $BSF_QUERY = 0x0001
Global Const $BSF_SENDNOTIFYMESSAGE = 0x0100
Global Const $BSM_ALLCOMPONENTS = 0x00
Global Const $BSM_ALLDESKTOPS = 0x08
Global Const $BSM_APPLICATIONS = 0x10
Global Const $BSM_INSTALLABLEDRIVERS = 0x04
Global Const $BSM_NETDRIVER = 0x02
Global Const $BSM_VXDS = 0x01
Global Const $MDITILE_HORIZONTAL = 0x01
Global Const $MDITILE_SKIPDISABLED = 0x02
Global Const $MDITILE_VERTICAL = 0x00
Global Const $MDITILE_ZORDER = 0x04
Global Const $MSGFLT_ALLOW = 1
Global Const $MSGFLT_DISALLOW = 2
Global Const $MSGFLT_RESET = 0
Global Const $MSGFLTINFO_ALLOWED_HIGHER = 3
Global Const $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
Global Const $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
Global Const $MSGFLTINFO_NONE = 0
Global Const $CWP_ALL = 0x00
Global Const $CWP_SKIPINVISIBLE = 0x01
Global Const $CWP_SKIPDISABLED = 0x02
Global Const $CWP_SKIPTRANSPARENT = 0x04
Global Const $COMPRESSION_FORMAT_NONE = 0x0000
Global Const $COMPRESSION_FORMAT_DEFAULT = 0x0001
Global Const $COMPRESSION_FORMAT_LZNT1 = 0x0002
Global Const $COMPRESSION_FORMAT_XPRESS = 0x0003
Global Const $COMPRESSION_FORMAT_XPRESS_HUFF = 0x0004
Global Const $COMPRESSION_ENGINE_STANDARD = 0x0000
Global Const $COMPRESSION_ENGINE_MAXIMUM = 0x0100
Global Const $COMPRESSION_ENGINE_HIBER = 0x0200
Global Const $WINSTA_ACCESSCLIPBOARD = 0x0004
Global Const $WINSTA_ACCESSGLOBALATOMS = 0x0020
Global Const $WINSTA_CREATEDESKTOP = 0x0008
Global Const $WINSTA_ENUMDESKTOPS = 0x0001
Global Const $WINSTA_ENUMERATE = 0x0100
Global Const $WINSTA_EXITWINDOWS = 0x0040
Global Const $WINSTA_READATTRIBUTES = 0x0002
Global Const $WINSTA_READSCREEN = 0x0200
Global Const $WINSTA_WRITEATTRIBUTES = 0x0010
Global Const $WINSTA_ALL_ACCESS = BitOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
Global Const $CWF_CREATE_ONLY = 0x01
Global Const $GCL_CBCLSEXTRA = -20
Global Const $GCL_CBWNDEXTRA = -18
Global Const $GCL_HBRBACKGROUND = -10
Global Const $GCL_HCURSOR = -12
Global Const $GCL_HICON = -14
Global Const $GCL_HICONSM = -34
Global Const $GCL_HMODULE = -16
Global Const $GCL_MENUNAME = -8
Global Const $GCL_STYLE = -26
Global Const $GCL_WNDPROC = -24
Global Const $DOCKINFO_DOCKED = 0x02
Global Const $DOCKINFO_UNDOCKED = 0x01
Global Const $DOCKINFO_USER_SUPPLIED = 0x04
Global Const $DOCKINFO_USER_DOCKED = 0x05
Global Const $DOCKINFO_USER_UNDOCKED = 0x06
Global Const $GUI_CARETBLINKING = 0x0001
Global Const $GUI_INMENUMODE = 0x0004
Global Const $GUI_INMOVESIZE = 0x0002
Global Const $GUI_POPUPMENUMODE = 0x0010
Global Const $GUI_SYSTEMMENUMODE = 0x0008
Global Const $HANDLE_FLAG_INHERIT = 0x00000001
Global Const $HANDLE_FLAG_PROTECT_FROM_CLOSE = 0x00000002
Global Const $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 0x0004
Global Const $GET_MODULE_HANDLE_EX_FLAG_PIN = 0x0001
Global Const $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 0x0002
Global Const $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0x0000
Global Const $PROCESSOR_ARCHITECTURE_AMD64 = 9
Global Const $PROCESSOR_ARCHITECTURE_IA64 = 6
Global Const $PROCESSOR_ARCHITECTURE_INTEL = 0
Global Const $PROCESSOR_ARCHITECTURE_UNKNOWN = 0xFFFF
Global Const $PROCESSOR_INTEL_386 = 386
Global Const $PROCESSOR_INTEL_486 = 486
Global Const $PROCESSOR_INTEL_PENTIUM = 586
Global Const $PROCESSOR_INTEL_IA64 = 2200
Global Const $PROCESSOR_AMD_X8664 = 8664
Global Const $UOI_FLAGS = 1
Global Const $UOI_HEAPSIZE = 5
Global Const $UOI_IO = 6
Global Const $UOI_NAME = 2
Global Const $UOI_TYPE = 3
Global Const $UOI_USER_SID = 4
Global Const $DF_ALLOWOTHERACCOUNTHOOK = 0x01
Global Const $WSF_VISIBLE = 0x01
Global Const $VER_SUITE_BACKOFFICE = 0x00000004
Global Const $VER_SUITE_BLADE = 0x00000400
Global Const $VER_SUITE_COMPUTE_SERVER = 0x00004000
Global Const $VER_SUITE_DATACENTER = 0x00000080
Global Const $VER_SUITE_ENTERPRISE = 0x00000002
Global Const $VER_SUITE_EMBEDDEDNT = 0x00000040
Global Const $VER_SUITE_PERSONAL = 0x00000200
Global Const $VER_SUITE_SINGLEUSERTS = 0x00000100
Global Const $VER_SUITE_SMALLBUSINESS = 0x00000001
Global Const $VER_SUITE_SMALLBUSINESS_RESTRICTED = 0x00000020
Global Const $VER_SUITE_STORAGE_SERVER = 0x00002000
Global Const $VER_SUITE_TERMINAL = 0x00000010
Global Const $VER_SUITE_WH_SERVER = 0x00008000
Global Const $VER_NT_DOMAIN_CONTROLLER = 0x0000002
Global Const $VER_NT_SERVER = 0x0000003
Global Const $VER_NT_WORKSTATION = 0x0000001
Global Const $WDA_MONITOR = 0x01
Global Const $WDA_NONE = 0x00
Global Const $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
Global Const $PF_CHANNELS_ENABLED = 16
Global Const $PF_COMPARE_EXCHANGE_DOUBLE = 2
Global Const $PF_COMPARE_EXCHANGE128 = 14
Global Const $PF_COMPARE64_EXCHANGE128 = 15
Global Const $PF_FLOATING_POINT_EMULATED = 1
Global Const $PF_FLOATING_POINT_PRECISION_ERRATA = 0
Global Const $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
Global Const $PF_NX_ENABLED = 12
Global Const $PF_PAE_ENABLED = 9
Global Const $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
Global Const $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
Global Const $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
Global Const $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
Global Const $PF_XSAVE_ENABLED = 17
Global Const $KEYEVENTF_EXTENDEDKEY = 0x01
Global Const $KEYEVENTF_KEYUP = 0x02
Global Const $LIM_SMALL = 0
Global Const $LIM_LARGE = 1
Global Const $MAPVK_VK_TO_CHAR = 2
Global Const $MAPVK_VK_TO_VSC = 0
Global Const $MAPVK_VK_TO_VSC_EX = 4
Global Const $MAPVK_VSC_TO_VK = 1
Global Const $MAPVK_VSC_TO_VK_EX = 3
Global Const $MOD_ALT = 0x0001
Global Const $MOD_CONTROL = 0x0002
Global Const $MOD_NOREPEAT = 0x4000
Global Const $MOD_SHIFT = 0x0004
Global Const $MOD_WIN = 0x0008
Global Const $GUID_ACDC_POWER_SOURCE = '{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}'
Global Const $GUID_BATTERY_PERCENTAGE_REMAINING = '{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}'
Global Const $GUID_IDLE_BACKGROUND_TASK = '{515C31D8-F734-163D-A0FD-11A08C91E8F1}'
Global Const $GUID_MONITOR_POWER_ON = '{02731015-4510-4526-99E6-E5A17EBD1AEA}'
Global Const $GUID_POWERSCHEME_PERSONALITY = '{245D8541-3943-4422-B025-13A784F679B7}'
Global Const $GUID_SYSTEM_AWAYMODE = '{98A7F580-01F7-48AA-9C0F-44352C29E5C0}'
Global Const $GUID_MIN_POWER_SAVINGS = '{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}'
Global Const $GUID_MAX_POWER_SAVINGS = '{A1841308-3541-4FAB-BC81-F71556F20B4A}'
Global Const $GUID_TYPICAL_POWER_SAVINGS = '{381B4222-F694-41F0-9685-FF5BB260DF2E}'
Global Const $HSHELL_WINDOWCREATED = 1
Global Const $HSHELL_WINDOWDESTROYED = 2
Global Const $HSHELL_ACTIVATESHELLWINDOW = 3
Global Const $HSHELL_WINDOWACTIVATED = 4
Global Const $HSHELL_GETMINRECT = 5
Global Const $HSHELL_REDRAW = 6
Global Const $HSHELL_TASKMAN = 7
Global Const $HSHELL_LANGUAGE = 8
Global Const $HSHELL_SYSMENU = 9
Global Const $HSHELL_ENDTASK = 10
Global Const $HSHELL_ACCESSIBILITYSTATE = 11
Global Const $HSHELL_APPCOMMAND = 12
Global Const $HSHELL_WINDOWREPLACED = 13
Global Const $HSHELL_WINDOWREPLACING = 14
Global Const $HSHELL_RUDEAPPACTIVATED = 32772
Global Const $HSHELL_FLASH = 32774
Global Const $HWND_BROADCAST = 0xFFFF
Global Const $SMTO_BLOCK = 0x0001
Global Const $SMTO_NORMAL = 0x0000
Global Const $SMTO_ABORTIFHUNG = 0x0002
Global Const $SMTO_NOTIMEOUTIFNOTHUNG = 0x0008
Global Const $SMTO_ERRORONEXIT = 0x0020
Global Const $INPUTLANGCHANGE_BACKWARD = 0x0004
Global Const $INPUTLANGCHANGE_FORWARD = 0x0002
Global Const $INPUTLANGCHANGE_SYSCHARSET = 0x0001
Global Const $EVENT_MIN = 0x00000001
Global Const $EVENT_SYSTEM_SOUND = 0x00000001
Global Const $EVENT_SYSTEM_ALERT = 0x00000002
Global Const $EVENT_SYSTEM_FOREGROUND = 0x00000003
Global Const $EVENT_SYSTEM_MENUSTART = 0x00000004
Global Const $EVENT_SYSTEM_MENUEND = 0x00000005
Global Const $EVENT_SYSTEM_MENUPOPUPSTART = 0x00000006
Global Const $EVENT_SYSTEM_MENUPOPUPEND = 0x00000007
Global Const $EVENT_SYSTEM_CAPTURESTART = 0x00000008
Global Const $EVENT_SYSTEM_CAPTUREEND = 0x00000009
Global Const $EVENT_SYSTEM_MOVESIZESTART = 0x0000000A
Global Const $EVENT_SYSTEM_MOVESIZEEND = 0x0000000B
Global Const $EVENT_SYSTEM_CONTEXTHELPSTART = 0x0000000C
Global Const $EVENT_SYSTEM_CONTEXTHELPEND = 0x0000000D
Global Const $EVENT_SYSTEM_DRAGDROPSTART = 0x0000000E
Global Const $EVENT_SYSTEM_DRAGDROPEND = 0x0000000F
Global Const $EVENT_SYSTEM_DIALOGSTART = 0x00000010
Global Const $EVENT_SYSTEM_DIALOGEND = 0x00000011
Global Const $EVENT_SYSTEM_SCROLLINGSTART = 0x00000012
Global Const $EVENT_SYSTEM_SCROLLINGEND = 0x00000013
Global Const $EVENT_SYSTEM_SWITCHSTART = 0x00000014
Global Const $EVENT_SYSTEM_SWITCHEND = 0x00000015
Global Const $EVENT_SYSTEM_MINIMIZESTART = 0x00000016
Global Const $EVENT_SYSTEM_MINIMIZEEND = 0x00000017
Global Const $EVENT_SYSTEM_DESKTOPSWITCH = 0x00000020
Global Const $EVENT_OBJECT_CREATE = 0x00008000
Global Const $EVENT_OBJECT_DESTROY = 0x00008001
Global Const $EVENT_OBJECT_SHOW = 0x00008002
Global Const $EVENT_OBJECT_HIDE = 0x00008003
Global Const $EVENT_OBJECT_REORDER = 0x00008004
Global Const $EVENT_OBJECT_FOCUS = 0x00008005
Global Const $EVENT_OBJECT_SELECTION = 0x00008006
Global Const $EVENT_OBJECT_SELECTIONADD = 0x00008007
Global Const $EVENT_OBJECT_SELECTIONREMOVE = 0x00008008
Global Const $EVENT_OBJECT_SELECTIONWITHIN = 0x00008009
Global Const $EVENT_OBJECT_STATECHANGE = 0x0000800A
Global Const $EVENT_OBJECT_LOCATIONCHANGE = 0x0000800B
Global Const $EVENT_OBJECT_NAMECHANGE = 0x0000800C
Global Const $EVENT_OBJECT_DESCRIPTIONCHANGE = 0x0000800D
Global Const $EVENT_OBJECT_VALUECHANGE = 0x0000800E
Global Const $EVENT_OBJECT_PARENTCHANGE = 0x0000800F
Global Const $EVENT_OBJECT_HELPCHANGE = 0x00008010
Global Const $EVENT_OBJECT_DEFACTIONCHANGE = 0x00008011
Global Const $EVENT_OBJECT_ACCELERATORCHANGE = 0x00008012
Global Const $EVENT_OBJECT_INVOKED = 0x00008013
Global Const $EVENT_OBJECT_TEXTSELECTIONCHANGED = 0x00008014
Global Const $EVENT_OBJECT_CONTENTSCROLLED = 0x00008015
Global Const $EVENT_MAX = 0x7FFFFFFF
Global Const $WINEVENT_INCONTEXT = 0x04
Global Const $WINEVENT_OUTOFCONTEXT = 0x00
Global Const $WINEVENT_SKIPOWNPROCESS = 0x02
Global Const $WINEVENT_SKIPOWNTHREAD = 0x01
Global Const $TME_CANCEL = 0x80000000
Global Const $TME_HOVER = 0x00000001
Global Const $TME_LEAVE = 0x00000002
Global Const $TME_NONCLIENT = 0x00000010
Global Const $TME_QUERY = 0x40000000
Global Const $DESKTOP_CREATEMENU = 0x0004
Global Const $DESKTOP_CREATEWINDOW = 0x0002
Global Const $DESKTOP_ENUMERATE = 0x0040
Global Const $DESKTOP_HOOKCONTROL = 0x0008
Global Const $DESKTOP_JOURNALPLAYBACK = 0x0020
Global Const $DESKTOP_JOURNALRECORD = 0x0010
Global Const $DESKTOP_READOBJECTS = 0x0001
Global Const $DESKTOP_SWITCHDESKTOP = 0x0100
Global Const $DESKTOP_WRITEOBJECTS = 0x0080
Global Const $DESKTOP_ALL_ACCESS = BitOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
Global Const $RIDEV_APPKEYS = 0x00000400
Global Const $RIDEV_CAPTUREMOUSE = 0x00000200
Global Const $RIDEV_DEVNOTIFY = 0x00002000
Global Const $RIDEV_EXCLUDE = 0x00000010
Global Const $RIDEV_EXINPUTSINK = 0x00001000
Global Const $RIDEV_INPUTSINK = 0x00000100
Global Const $RIDEV_NOHOTKEYS = 0x00000200
Global Const $RIDEV_NOLEGACY = 0x00000030
Global Const $RIDEV_PAGEONLY = 0x00000020
Global Const $RIDEV_REMOVE = 0x00000001
Global Const $RID_HEADER = 0x10000005
Global Const $RID_INPUT = 0x10000003
Global Const $RIM_TYPEHID = 2
Global Const $RIM_TYPEKEYBOARD = 1
Global Const $RIM_TYPEMOUSE = 0
Global Const $RIDI_DEVICENAME = 0x20000007
Global Const $RIDI_DEVICEINFO = 0x2000000B
Global Const $RIDI_PREPARSEDDATA = 0x20000005
Global Const $MOUSE_ATTRIBUTES_CHANGED = 0x04
Global Const $MOUSE_MOVE_ABSOLUTE = 0x01
Global Const $MOUSE_MOVE_RELATIVE = 0x00
Global Const $MOUSE_VIRTUAL_DESKTOP = 0x02
Global Const $RI_MOUSE_LEFT_BUTTON_DOWN = 0x0001
Global Const $RI_MOUSE_LEFT_BUTTON_UP = 0x0002
Global Const $RI_MOUSE_MIDDLE_BUTTON_DOWN = 0x0010
Global Const $RI_MOUSE_MIDDLE_BUTTON_UP = 0x0020
Global Const $RI_MOUSE_RIGHT_BUTTON_DOWN = 0x0004
Global Const $RI_MOUSE_RIGHT_BUTTON_UP = 0x0008
Global Const $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
Global Const $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
Global Const $RI_MOUSE_BUTTON_4_DOWN = 0x0040
Global Const $RI_MOUSE_BUTTON_4_UP = 0x0080
Global Const $RI_MOUSE_BUTTON_5_DOWN = 0x0100
Global Const $RI_MOUSE_BUTTON_5_UP = 0x0200
Global Const $RI_MOUSE_WHEEL = 0x0400
Global Const $RI_KEY_BREAK = 1
Global Const $RI_KEY_E0 = 2
Global Const $RI_KEY_E1 = 4
Global Const $RI_KEY_MAKE = 0
Global Const $FLASHW_CAPTION = 0x00000001
Global Const $FLASHW_TRAY = 0x00000002
Global Const $FLASHW_TIMER = 0x00000004
Global Const $FLASHW_TIMERNOFG = 0x0000000C
Global Const $tagUPDATELAYEREDWINDOWINFO = 'dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom'
Global Const $tagWINDOWINFO = 'dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion'
Global Const $tagWNDCLASS = 'uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName'
Global Const $tagWNDCLASSEX = 'uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm'
Global Const $tagFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
Func _WinAPI_AdjustWindowRectEx(ByRef $tRECT, $iStyle, $iExStyle = 0, $bMenu = False)
Local $aRet = DllCall('user32.dll', 'bool', 'AdjustWindowRectEx', 'struct*', $tRECT, 'dword', $iStyle, 'bool', $bMenu,  'dword', $iExStyle)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_AnimateWindow($hWnd, $iFlags, $iDuration = 1000)
Local $aRet = DllCall('user32.dll', 'bool', 'AnimateWindow', 'hwnd', $hWnd, 'dword', $iDuration, 'dword', $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BeginDeferWindowPos($iAmount = 1)
Local $aRet = DllCall('user32.dll', 'handle', 'BeginDeferWindowPos', 'int', $iAmount)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_BringWindowToTop($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'BringWindowToTop', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_BroadcastSystemMessage($iMsg, $wParam = 0, $lParam = 0, $iFlags = 0, $iRecipients = 0)
Local $aRet = DllCall('user32.dll', 'long', 'BroadcastSystemMessageW', 'dword', $iFlags, 'dword*', $iRecipients,  'uint', $iMsg, 'wparam', $wParam, 'lparam', $lParam)
If @error Or ($aRet[0] = -1) Then Return SetError(@error, @extended, -1)
Return SetExtended($aRet[2], $aRet[0])
EndFunc
Func _WinAPI_CallWindowProc($pPrevWndFunc, $hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallWindowProc", "ptr", $pPrevWndFunc, "hwnd", $hWnd, "uint", $iMsg,  "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CallWindowProcW($pPrevWndProc, $hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'CallWindowProcW', 'ptr', $pPrevWndProc, 'hwnd', $hWnd, 'uint', $iMsg,  'wparam', $wParam, 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CascadeWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'CascadeWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ChangeWindowMessageFilterEx($hWnd, $iMsg, $iAction)
Local $tCFS, $aRet
If $hWnd And ($__WINVER > 0x0600) Then
Local Const $tagCHANGEFILTERSTRUCT = 'dword cbSize; dword ExtStatus'
$tCFS = DllStructCreate($tagCHANGEFILTERSTRUCT)
DllStructSetData($tCFS, 1, DllStructGetSize($tCFS))
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilterEx', 'hwnd', $hWnd, 'uint', $iMsg, 'dword', $iAction,  'struct*', $tCFS)
Else
$tCFS = 0
$aRet = DllCall('user32.dll', 'bool', 'ChangeWindowMessageFilter', 'uint', $iMsg, 'dword', $iAction)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(DllStructGetData($tCFS, 2), 1)
EndFunc
Func _WinAPI_ChildWindowFromPointEx($hWnd, $tPOINT, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'hwnd', 'ChildWindowFromPointEx', 'hwnd', $hWnd, 'struct', $tPOINT, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DeferWindowPos($hInfo, $hWnd, $hAfter, $iX, $iY, $iWidth, $iHeight, $iFlags)
Local $aRet = DllCall('user32.dll', 'handle', 'DeferWindowPos', 'handle', $hInfo, 'hwnd', $hWnd, 'hwnd', $hAfter,  'int', $iX, 'int', $iY, 'int', $iWidth, 'int', $iHeight, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DefWindowProc($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "DefWindowProc", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_DefWindowProcW($hWnd, $iMsg, $wParam, $lParam)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefWindowProcW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DeregisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'DeregisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_DragAcceptFiles($hWnd, $bAccept = True)
DllCall('shell32.dll', 'none', 'DragAcceptFiles', 'hwnd', $hWnd, 'bool', $bAccept)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragFinish($hDrop)
DllCall('shell32.dll', 'none', 'DragFinish', 'handle', $hDrop)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_DragQueryFileEx($hDrop, $iFlag = 0)
Local $aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', -1, 'ptr', 0, 'uint', 0)
If @error Then Return SetError(@error, @extended, 0)
If Not $aRet[0] Then Return SetError(10, 0, 0)
Local $iCount = $aRet[0]
Local $aResult[$iCount + 1]
For $i = 0 To $iCount - 1
$aRet = DllCall('shell32.dll', 'uint', 'DragQueryFileW', 'handle', $hDrop, 'uint', $i, 'wstr', '', 'uint', 4096)
If Not $aRet[0] Then Return SetError(11, 0, 0)
If $iFlag Then
Local $bDir = _WinAPI_PathIsDirectory($aRet[3])
If (($iFlag = 1) And $bDir) Or (($iFlag = 2) And Not $bDir) Then
ContinueLoop
EndIf
EndIf
$aResult[$i + 1] = $aRet[3]
$aResult[0] += 1
Next
If Not $aResult[0] Then Return SetError(12, 0, 0)
__Inc($aResult, -1)
Return $aResult
EndFunc
Func _WinAPI_DragQueryPoint($hDrop)
Local $tPOINT = DllStructCreate($tagPOINT)
Local $aRet = DllCall('shell32.dll', 'bool', 'DragQueryPoint', 'handle', $hDrop, 'struct*', $tPOINT)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tPOINT
EndFunc
Func _WinAPI_EndDeferWindowPos($hInfo)
Local $aRet = DllCall('user32.dll', 'bool', 'EndDeferWindowPos', 'handle', $hInfo)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_EnumChildWindows($hWnd, $bVisible = True)
If Not _WinAPI_GetWindow($hWnd, 5) Then Return SetError(2, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
DllCall('user32.dll', 'bool', 'EnumChildWindows', 'hwnd', $hWnd, 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $bVisible)
If @error Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_FindWindow($sClassName, $sWindowName)
Local $aResult = DllCall("user32.dll", "hwnd", "FindWindowW", "wstr", $sClassName, "wstr", $sWindowName)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindow($hWnd, $bInvert = True)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindow", "hwnd", $hWnd, "bool", $bInvert)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_FlashWindowEx($hWnd, $iFlags = 3, $iCount = 3, $iTimeout = 0)
Local $tFlash = DllStructCreate($tagFLASHWINFO)
Local $iFlash = DllStructGetSize($tFlash)
Local $iMode = 0
If BitAND($iFlags, 1) <> 0 Then $iMode = BitOR($iMode, $FLASHW_CAPTION)
If BitAND($iFlags, 2) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TRAY)
If BitAND($iFlags, 4) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMER)
If BitAND($iFlags, 8) <> 0 Then $iMode = BitOR($iMode, $FLASHW_TIMERNOFG)
DllStructSetData($tFlash, "Size", $iFlash)
DllStructSetData($tFlash, "hWnd", $hWnd)
DllStructSetData($tFlash, "Flags", $iMode)
DllStructSetData($tFlash, "Count", $iCount)
DllStructSetData($tFlash, "Timeout", $iTimeout)
Local $aResult = DllCall("user32.dll", "bool", "FlashWindowEx", "struct*", $tFlash)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_GetAncestor($hWnd, $iFlags = 1)
Local $aResult = DllCall("user32.dll", "hwnd", "GetAncestor", "hwnd", $hWnd, "uint", $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClassInfoEx($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $tWNDCLASSEX = DllStructCreate($tagWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'bool', 'GetClassInfoExW', 'handle', $hInstance, $sTypeOfClass, $sClass,  'struct*', $tWNDCLASSEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWNDCLASSEX
EndFunc
Func _WinAPI_GetClassLongEx($hWnd, $iIndex)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'GetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex)
Else
$aRet = DllCall('user32.dll', 'dword', 'GetClassLongW', 'hwnd', $hWnd, 'int', $iIndex)
EndIf
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetClientHeight($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Bottom") - DllStructGetData($tRECT, "Top")
EndFunc
Func _WinAPI_GetClientWidth($hWnd)
Local $tRECT = _WinAPI_GetClientRect($hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return DllStructGetData($tRECT, "Right") - DllStructGetData($tRECT, "Left")
EndFunc
Func _WinAPI_GetDlgItem($hWnd, $iItemID)
Local $aResult = DllCall("user32.dll", "hwnd", "GetDlgItem", "hwnd", $hWnd, "int", $iItemID)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetForegroundWindow()
Local $aResult = DllCall("user32.dll", "hwnd", "GetForegroundWindow")
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetGUIThreadInfo($iThreadId)
Local Const $tagGUITHREADINFO = 'dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct'
Local $tGTI = DllStructCreate($tagGUITHREADINFO)
DllStructSetData($tGTI, 1, DllStructGetSize($tGTI))
Local $aRet = DllCall('user32.dll', 'bool', 'GetGUIThreadInfo', 'dword', $iThreadId, 'struct*', $tGTI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[11]
For $i = 0 To 10
$aResult[$i] = DllStructGetData($tGTI, $i + 2)
Next
For $i = 9 To 10
$aResult[$i] -= $aResult[$i - 2]
Next
Return $aResult
EndFunc
Func _WinAPI_GetLastActivePopup($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetLastActivePopup', 'hwnd', $hWnd)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
If $aRet[0] = $hWnd Then Return SetError(1, 0, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetLayeredWindowAttributes($hWnd, ByRef $iTransColor, ByRef $iTransGUI, $bColorRef = False)
$iTransColor = -1
$iTransGUI = -1
Local $aResult = DllCall("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $hWnd, "INT*", $iTransColor,  "byte*", $iTransGUI, "dword*", 0)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
If Not $bColorRef Then
$aResult[2] = Int(BinaryMid($aResult[2], 3, 1) & BinaryMid($aResult[2], 2, 1) & BinaryMid($aResult[2], 1, 1))
EndIf
$iTransColor = $aResult[2]
$iTransGUI = $aResult[3]
Return $aResult[4]
EndFunc
Func _WinAPI_GetMessageExtraInfo()
Local $aRet = DllCall('user32.dll', 'lparam', 'GetMessageExtraInfo')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetShellWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetShellWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTopWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetTopWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetWindowDisplayAffinity($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetWindowInfo($hWnd)
Local $tWINDOWINFO = DllStructCreate($tagWINDOWINFO)
DllStructSetData($tWINDOWINFO, 'Size', DllStructGetSize($tWINDOWINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetWindowInfo', 'hwnd', $hWnd, 'struct*', $tWINDOWINFO)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWINDOWINFO
EndFunc
Func _WinAPI_GetWindowPlacement($hWnd)
Local $tWindowPlacement = DllStructCreate($tagWINDOWPLACEMENT)
DllStructSetData($tWindowPlacement, "length", DllStructGetSize($tWindowPlacement))
Local $aRet = DllCall("user32.dll", "bool", "GetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tWindowPlacement
EndFunc
Func _WinAPI_IsChild($hWnd, $hWndParent)
Local $aRet = DllCall('user32.dll', 'bool', 'IsChild', 'hwnd', $hWndParent, 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsHungAppWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsHungAppWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsIconic($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsIconic', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowUnicode($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowUnicode', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsZoomed($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsZoomed', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_KillTimer($hWnd, $iTimerID)
Local $aRet = DllCall('user32.dll', 'bool', 'KillTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenIcon($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'OpenIcon', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_PostMessage($hWnd, $iMsg, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "bool", "PostMessage", "hwnd", $hWnd, "uint", $iMsg, "wparam", $wParam,  "lparam", $lParam)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RegisterClass($tWNDCLASS)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassW', 'struct*', $tWNDCLASS)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterClassEx($tWNDCLASSEX)
Local $aRet = DllCall('user32.dll', 'word', 'RegisterClassExW', 'struct*', $tWNDCLASSEX)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterShellHookWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterShellHookWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterWindowMessage($sMessage)
Local $aResult = DllCall("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $sMessage)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SendMessageTimeout($hWnd, $iMsg, $wParam = 0, $lParam = 0, $iTimeout = 1000, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'lresult', 'SendMessageTimeoutW', 'hwnd', $hWnd, 'uint', $iMsg, 'wparam', $wParam,  'lparam', $lParam, 'uint', $iFlags, 'uint', $iTimeout, 'dword_ptr*', 0)
If @error Then Return SetError(@error, @extended, -1)
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), -1)
Return $aRet[7]
EndFunc
Func _WinAPI_SetClassLongEx($hWnd, $iIndex, $iNewLong)
Local $aRet
If @AutoItX64 Then
$aRet = DllCall('user32.dll', 'ulong_ptr', 'SetClassLongPtrW', 'hwnd', $hWnd, 'int', $iIndex, 'long_ptr', $iNewLong)
Else
$aRet = DllCall('user32.dll', 'dword', 'SetClassLongW', 'hwnd', $hWnd, 'int', $iIndex, 'long', $iNewLong)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetForegroundWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'SetForegroundWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetLayeredWindowAttributes($hWnd, $iTransColor, $iTransGUI = 255, $iFlags = 0x03, $bColorRef = False)
If $iFlags = Default Or $iFlags = "" Or $iFlags < 0 Then $iFlags = 0x03
If Not $bColorRef Then
$iTransColor = Int(BinaryMid($iTransColor, 3, 1) & BinaryMid($iTransColor, 2, 1) & BinaryMid($iTransColor, 1, 1))
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $hWnd, "INT", $iTransColor,  "byte", $iTransGUI, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetMessageExtraInfo($lParam)
Local $aRet = DllCall('user32.dll', 'lparam', 'SetMessageExtraInfo', 'lparam', $lParam)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetSysColors($vElements, $vColors)
Local $bIsEArray = IsArray($vElements), $bIsCArray = IsArray($vColors)
Local $iElementNum
If Not $bIsCArray And Not $bIsEArray Then
$iElementNum = 1
ElseIf $bIsCArray Or $bIsEArray Then
If Not $bIsCArray Or Not $bIsEArray Then Return SetError(-1, -1, False)
If UBound($vElements) <> UBound($vColors) Then Return SetError(-1, -1, False)
$iElementNum = UBound($vElements)
EndIf
Local $tElements = DllStructCreate("int Element[" & $iElementNum & "]")
Local $tColors = DllStructCreate("INT NewColor[" & $iElementNum & "]")
If Not $bIsEArray Then
DllStructSetData($tElements, "Element", $vElements, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tElements, "Element", $vElements[$x], $x + 1)
Next
EndIf
If Not $bIsCArray Then
DllStructSetData($tColors, "NewColor", $vColors, 1)
Else
For $x = 0 To $iElementNum - 1
DllStructSetData($tColors, "NewColor", $vColors[$x], $x + 1)
Next
EndIf
Local $aResult = DllCall("user32.dll", "bool", "SetSysColors", "int", $iElementNum, "struct*", $tElements, "struct*", $tColors)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetTimer($hWnd, $iTimerID, $iElapse, $pTimerFunc)
Local $aRet = DllCall('user32.dll', 'uint_ptr', 'SetTimer', 'hwnd', $hWnd, 'uint_ptr', $iTimerID, 'uint', $iElapse,  'ptr', $pTimerFunc)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowDisplayAffinity($hWnd, $iAffinity)
Local $aRet = DllCall('user32.dll', 'bool', 'SetWindowDisplayAffinity', 'hwnd', $hWnd, 'dword', $iAffinity)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowLong($hWnd, $iIndex, $iValue)
_WinAPI_SetLastError(0)
Local $sFuncName = "SetWindowLongW"
If @AutoItX64 Then $sFuncName = "SetWindowLongPtrW"
Local $aResult = DllCall("user32.dll", "long_ptr", $sFuncName, "hwnd", $hWnd, "int", $iIndex, "long_ptr", $iValue)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWindowPlacement($hWnd, $tWindowPlacement)
Local $aResult = DllCall("user32.dll", "bool", "SetWindowPlacement", "hwnd", $hWnd, "struct*", $tWindowPlacement)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_ShowOwnedPopups($hWnd, $bShow)
Local $aRet = DllCall('user32.dll', 'bool', 'ShowOwnedPopups', 'hwnd', $hWnd, 'bool', $bShow)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SwitchToThisWindow($hWnd, $bAltTab = False)
DllCall('user32.dll', 'none', 'SwitchToThisWindow', 'hwnd', $hWnd, 'bool', $bAltTab)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_TileWindows($aWnds, $tRECT = 0, $hParent = 0, $iFlags = 0, $iStart = 0, $iEnd = -1)
If __CheckErrorArrayBounds($aWnds, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tWnds = DllStructCreate('hwnd[' & $iCount & ']')
$iCount = 1
For $i = $iStart To $iEnd
DllStructSetData($tWnds, 1, $aWnds[$i], $iCount)
$iCount += 1
Next
Local $aRet = DllCall('user32.dll', 'word', 'TileWindows', 'hwnd', $hParent, 'uint', $iFlags, 'struct*', $tRECT,  'uint', $iCount - 1, 'struct*', $tWnds)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterClass($sClass, $hInstance = 0)
Local $sTypeOfClass = 'ptr'
If IsString($sClass) Then
$sTypeOfClass = 'wstr'
EndIf
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterClassW', $sTypeOfClass, $sClass, 'handle', $hInstance)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindow($hWnd, $hDestDC, $tPTDest, $tSize, $hSrcDC, $tPTSrce, $iRGB, $tBlend, $iFlags)
Local $aResult = DllCall("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $hWnd, "handle", $hDestDC, "struct*", $tPTDest,  "struct*", $tSize, "handle", $hSrcDC, "struct*", $tPTSrce, "dword", $iRGB, "struct*", $tBlend, "dword", $iFlags)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowEx($hWnd, $iX, $iY, $hBitmap, $iOpacity = 255, $bDelete = False)
Local $aRet = DllCall('user32.dll', 'handle', 'GetDC', 'hwnd', $hWnd)
Local $hDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'CreateCompatibleDC', 'handle', $hDC)
Local $hDestDC = $aRet[0]
$aRet = DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hBitmap)
Local $hDestSv = $aRet[0]
Local $tPOINT
If ($iX = -1) And ($iY = -1) Then
$tPOINT = DllStructCreate('int;int')
Else
$tPOINT = DllStructCreate('int;int;int;int')
DllStructSetData($tPOINT, 3, $iX)
DllStructSetData($tPOINT, 4, $iY)
EndIf
DllStructSetData($tPOINT, 1, 0)
DllStructSetData($tPOINT, 2, 0)
Local $tBLENDFUNCTION = DllStructCreate($tagBLENDFUNCTION)
DllStructSetData($tBLENDFUNCTION, 1, 0)
DllStructSetData($tBLENDFUNCTION, 2, 0)
DllStructSetData($tBLENDFUNCTION, 3, $iOpacity)
DllStructSetData($tBLENDFUNCTION, 4, 1)
Local Const $tagBITMAP = 'struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct'
Local $tObj = DllStructCreate($tagBITMAP)
DllCall('gdi32.dll', 'int', 'GetObject', 'handle', $hBitmap, 'int', DllStructGetSize($tObj), 'struct*', $tObj)
Local $tSize = DllStructCreate($tagSIZE, DllStructGetPtr($tObj, "bmWidth"))
$aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindow', 'hwnd', $hWnd, 'handle', $hDC, 'ptr', DllStructGetPtr($tPOINT, 3),  'struct*', $tSIZE, 'handle', $hDestDC, 'struct*', $tPOINT, 'dword', 0, 'struct*', $tBLENDFUNCTION, 'dword', 0x02)
Local $iError = @error
DllCall('user32.dll', 'bool', 'ReleaseDC', 'hwnd', $hWnd, 'handle', $hDC)
DllCall('gdi32.dll', 'handle', 'SelectObject', 'handle', $hDestDC, 'handle', $hDestSv)
DllCall('gdi32.dll', 'bool', 'DeleteDC', 'handle', $hDestDC)
If $iError Then Return SetError($iError, 0, False)
If $bDelete Then
DllCall("gdi32.dll", "bool", "DeleteObject", "handle", $hBitmap)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_UpdateLayeredWindowIndirect($hWnd, $tULWINFO)
Local $aRet = DllCall('user32.dll', 'bool', 'UpdateLayeredWindowIndirect', 'hwnd', $hWnd, 'struct*', $tULWINFO)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_WindowFromPoint(ByRef $tPoint)
Local $aResult = DllCall("user32.dll", "hwnd", "WindowFromPoint", "struct", $tPoint)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
#EndRegion Public Functions
#Region Internal Functions
Func __EnumDefaultProc($pData, $lParam)
#forceref $lParam
Local $iLength = _WinAPI_StrLen($pData)
__Inc($__g_vEnum)
If $iLength Then
$__g_vEnum[$__g_vEnum[0]] = DllStructGetData(DllStructCreate('wchar[' & ($iLength + 1) & ']', $pData), 1)
Else
$__g_vEnum[$__g_vEnum[0]] = ''
EndIf
Return 1
EndFunc
#EndRegion Internal Functions
#Region Global Variables and Constants
Global Const $tagOSVERSIONINFOEX = $tagOSVERSIONINFO & ';ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved'
Global Const $tagRAWINPUTDEVICE = 'struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct'
Global Const $tagRAWINPUTHEADER = 'struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct'
Global Const $tagRAWMOUSE = 'ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;'
Global Const $tagRAWKEYBOARD = 'ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;'
Global Const $tagRAWHID = 'dword SizeHid;dword Count;'
Global Const $tagRAWINPUTMOUSE = $tagRAWINPUTHEADER & ';' & $tagRAWMOUSE
Global Const $tagRAWINPUTKEYBOARD = $tagRAWINPUTHEADER & ';' & $tagRAWKEYBOARD
Global Const $tagRAWINPUTHID = $tagRAWINPUTHEADER & ';' & $tagRAWHID
Global Const $tagRID_DEVICE_INFO_MOUSE = 'struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc'
Global Const $tagRID_DEVICE_INFO_KEYBOARD = 'struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruc'
Global Const $tagRID_DEVICE_INFO_HID = 'struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc'
Global Const $tagRID_INFO_MOUSE = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_MOUSE & ';dword Unused[2];'
Global Const $tagRID_INFO_KEYBOARD = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_KEYBOARD
Global Const $tagRID_INFO_HID = 'dword Size;dword Type;' & $tagRID_DEVICE_INFO_HID & ';dword Unused[2]'
Global Const $tagUSEROBJECTFLAGS = 'int Inherit;int Reserved;dword Flags'
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
Func _WinAPI_ActivateKeyboardLayout($hLocale, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'ActivateKeyboardLayout', 'handle', $hLocale, 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_AddClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'AddClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CallNextHookEx($hHook, $iCode, $wParam, $lParam)
Local $aResult = DllCall("user32.dll", "lresult", "CallNextHookEx", "handle", $hHook, "int", $iCode, "wparam", $wParam, "lparam", $lParam)
If @error Then Return SetError(@error, @extended, -1)
Return $aResult[0]
EndFunc
Func _WinAPI_CloseDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CloseWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'CloseWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_CompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormatAndEngine = 0x0002)
Local $aRet, $pWorkSpace = 0, $iError = 0
Do
$aRet = DllCall('ntdll.dll', 'uint', 'RtlGetCompressionWorkSpaceSize', 'ushort', $iFormatAndEngine, 'ulong*', 0, 'ulong*', 0)
If @error Or $aRet[0] Then
$iError = @error + 20
ExitLoop
EndIf
$pWorkSpace = __HeapAlloc($aRet[2])
If @error Then
$iError = @error + 100
ExitLoop
EndIf
$aRet = DllCall('ntdll.dll', 'uint', 'RtlCompressBuffer', 'ushort', $iFormatAndEngine, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong', 4096,  'ulong*', 0, 'ptr', $pWorkSpace)
If @error Or $aRet[0] Or Not $aRet[7] Then
$iError = @error + 30
ExitLoop
EndIf
Until 1
__HeapFree($pWorkSpace)
If $iError Then
If IsArray($aRet) Then
Return SetError(10, $aRet[0], 0)
Else
Return SetError($iError, 0, 0)
EndIf
EndIf
Return $aRet[7]
EndFunc
Func _WinAPI_ComputeCrc32($pMemory, $iLength)
If _WinAPI_IsBadReadPtr($pMemory, $iLength) Then Return SetError(1, @extended, 0)
Local $aRet = DllCall('ntdll.dll', 'dword', 'RtlComputeCrc32', 'dword', 0, 'struct*', $pMemory, 'int', $iLength)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateDesktop($sName, $iAccess = 0x0002, $iFlags = 0, $iHeap = 0, $tSecurity = 0)
Local $aRet
If $iHeap Then
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopExW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity, 'ulong', $iHeap, 'ptr', 0)
Else
$aRet = DllCall('user32.dll', 'handle', 'CreateDesktopW', 'wstr', $sName, 'ptr', 0, 'ptr', 0, 'dword', $iFlags,  'dword', $iAccess, 'struct*', $tSecurity)
EndIf
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_CreateWindowStation($sName = '', $iAccess = 0, $iFlags = 0, $tSecurity = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'CreateWindowStationW', 'wstr', $sName, 'dword', $iFlags, 'dword', $iAccess,  'struct*', $tSecurity)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_DecompressBuffer($pUncompressedBuffer, $iUncompressedSize, $pCompressedBuffer, $iCompressedSize, $iFormat = 0x0002)
Local $aRet = DllCall('ntdll.dll', 'long', 'RtlDecompressBuffer', 'ushort', $iFormat, 'struct*', $pUncompressedBuffer,  'ulong', $iUncompressedSize, 'struct*', $pCompressedBuffer, 'ulong', $iCompressedSize, 'ulong*', 0)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return $aRet[6]
EndFunc
Func _WinAPI_DefRawInputProc($paRawInput, $iInput)
Local $aRet = DllCall('user32.dll', 'lresult', 'DefRawInputProc', 'ptr', $paRawInput, 'int', $iInput,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] Then Return SetError(10, $aRet[0], 0)
Return 1
EndFunc
Func _WinAPI_EnumDesktops($hStation)
If StringCompare(_WinAPI_GetUserObjectInformation($hStation, 3), 'WindowStation') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopsW', 'handle', $hStation, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumDesktopWindows($hDesktop, $bVisible = True)
If StringCompare(_WinAPI_GetUserObjectInformation($hDesktop, 3), 'Desktop') Then Return SetError(1, 0, 0)
Local $hEnumProc = DllCallbackRegister('__EnumWindowsProc', 'bool', 'hwnd;lparam')
Dim $__g_vEnum[101][2] = [[0]]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumDesktopWindows', 'handle', $hDesktop, 'ptr', DllCallbackGetPtr($hEnumProc),  'lparam', $bVisible)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumPageFiles()
Local $aInfo = _WinAPI_GetSystemInfo()
Local $hEnumProc = DllCallbackRegister('__EnumPageFilesProc', 'bool', 'lparam;ptr;ptr')
Dim $__g_vEnum[101][4] = [[0]]
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'EnumPageFilesW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', $aInfo[1])
If @error Or Not $aRet[0] Or Not $__g_vEnum[0][0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_EnumRawInputDevices()
Local Const $tagRAWINPUTDEVICELIST = 'struct;handle hDevice;dword Type;endstruct'
Local $tRIDL, $iLength = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICELIST))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', 0, 'uint*', 0, 'uint', $iLength)
If @error Then Return SetError(@error + 10, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[2]) Then Return SetError(10, -1, 0)
Local $tData = DllStructCreate('byte[' & ($aRet[2] * $iLength) & ']')
Local $pData = DllStructGetPtr($tData)
If @error Then Return SetError(@error + 20, 0, 0)
$aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceList', 'ptr', $pData, 'uint*', $aRet[2], 'uint', $iLength)
If ($aRet[0] = 4294967295) Or (Not $aRet[0]) Then Return SetError(1, -1, 0)
Local $aResult[$aRet[2] + 1][2] = [[$aRet[2]]]
For $i = 1 To $aRet[2]
$tRIDL = DllStructCreate('ptr;dword', $pData + $iLength * ($i - 1))
For $j = 0 To 1
$aResult[$i][$j] = DllStructGetData($tRIDL, $j + 1)
Next
Next
Return $aResult
EndFunc
Func _WinAPI_EnumWindowStations()
Local $hEnumProc = DllCallbackRegister('__EnumDefaultProc', 'bool', 'ptr;lparam')
Dim $__g_vEnum[101] = [0]
Local $aRet = DllCall('user32.dll', 'bool', 'EnumWindowStationsW', 'ptr', DllCallbackGetPtr($hEnumProc), 'lparam', 0)
If @error Or Not $aRet[0] Or Not $__g_vEnum[0] Then
$__g_vEnum = @error + 10
EndIf
DllCallbackFree($hEnumProc)
If $__g_vEnum Then Return SetError($__g_vEnum, 0, 0)
__Inc($__g_vEnum, -1)
Return $__g_vEnum
EndFunc
Func _WinAPI_ExpandEnvironmentStrings($sString)
Local $aResult = DllCall("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $sString, "wstr", "", "dword", 4096)
If @error Or Not $aResult[0] Then Return SetError(@error + 10, @extended, "")
Return $aResult[2]
EndFunc
Func _WinAPI_GetActiveWindow()
Local $aRet = DllCall('user32.dll', 'hwnd', 'GetActiveWindow')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetAsyncKeyState($iKey)
Local $aResult = DllCall("user32.dll", "short", "GetAsyncKeyState", "int", $iKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetClipboardSequenceNumber()
Local $aRet = DllCall('user32.dll', 'dword', 'GetClipboardSequenceNumber')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetCurrentHwProfile()
Local $tagHW_PROFILE_INFO = 'dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]'
Local $tHWPI = DllStructCreate($tagHW_PROFILE_INFO)
Local $aRet = DllCall('advapi32.dll', 'bool', 'GetCurrentHwProfileW', 'struct*', $tHWPI)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = DllStructGetData($tHWPI, $i + 1)
Next
Return $aResult
EndFunc
Func _WinAPI_GetDefaultPrinter()
Local $aRet = DllCall('winspool.drv', 'bool', 'GetDefaultPrinterW', 'wstr', '', 'dword*', 2048)
If @error Then Return SetError(@error, @extended, '')
If Not $aRet[0] Then Return SetError(10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetDllDirectory()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetDllDirectoryW', 'dword', 4096, 'wstr', '')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetEffectiveClientRect($hWnd, $aCtrl, $iStart = 0, $iEnd = -1)
If Not IsArray($aCtrl) Then
Local $iCtrl = $aCtrl
Dim $aCtrl[1] = [$iCtrl]
$iStart = 0
$iEnd = 0
EndIf
If __CheckErrorArrayBounds($aCtrl, $iStart, $iEnd) Then Return SetError(@error + 10, @extended, 0)
Local $iCount = $iEnd - $iStart + 1
Local $tCtrl = DllStructCreate('uint64[' & ($iCount + 2) & ']')
$iCount = 2
For $i = $iStart To $iEnd
If IsHWnd($aCtrl[$i]) Then
$aCtrl[$i] = _WinAPI_GetDlgCtrlID($aCtrl[$i])
EndIf
DllStructSetData($tCtrl, 1, _WinAPI_MakeQWord(1, $aCtrl[$i]), $iCount)
$iCount += 1
Next
Local $tRECT = DllStructCreate($tagRECT)
DllCall('comctl32.dll', 'none', 'GetEffectiveClientRect', 'hwnd', $hWnd, 'struct*', $tRECT, 'struct*', $tCtrl)
If @error Then Return SetError(@error, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_GetHandleInformation($hObject)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetHandleInformation', 'handle', $hObject, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[2]
EndFunc
Func _WinAPI_GetIdleTime()
Local $tLASTINPUTINFO = DllStructCreate('uint;dword')
DllStructSetData($tLASTINPUTINFO, 1, DllStructGetSize($tLASTINPUTINFO))
Local $aRet = DllCall('user32.dll', 'bool', 'GetLastInputInfo', 'struct*', $tLASTINPUTINFO)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return _WinAPI_GetTickCount() - DllStructGetData($tLASTINPUTINFO, 2)
EndFunc
Func _WinAPI_GetKeyboardLayout($hWnd)
Local $aRet = DllCall('user32.dll', 'dword', 'GetWindowThreadProcessId', 'hwnd', $hWnd, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'GetKeyboardLayout', 'dword', $aRet[0])
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyboardLayoutList()
Local $aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', 0, 'ptr', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 20, @extended, 0)
Local $tData = DllStructCreate('handle[' & $aRet[0] & ']')
$aRet = DllCall('user32.dll', 'uint', 'GetKeyboardLayoutList', 'int', $aRet[0], 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aList[$aRet[0] + 1] = [$aRet[0]]
For $i = 1 To $aList[0]
$aList[$i] = DllStructGetData($tData, 1, $i)
Next
Return $aList
EndFunc
Func _WinAPI_GetKeyboardState()
Local $tData = DllStructCreate('byte[256]')
Local $aRet = DllCall('user32.dll', 'bool', 'GetKeyboardState', 'struct*', $tData)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tData
EndFunc
Func _WinAPI_GetKeyboardType($iType)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyboardType', 'int', $iType)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetKeyNameText($lParam)
Local $aRet = DllCall('user32.dll', 'int', 'GetKeyNameTextW', 'long', $lParam, 'wstr', '', 'int', 128)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_GetKeyState($vKey)
Local $aRet = DllCall('user32.dll', 'short', 'GetKeyState', 'int', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetModuleHandleEx($sModule, $iFlags = 0)
Local $sTypeOfModule = 'ptr'
If IsString($sModule) Then
If StringStripWS($sModule, $STR_STRIPLEADING + $STR_STRIPTRAILING) Then
$sTypeOfModule = 'wstr'
Else
$sModule = 0
EndIf
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetModuleHandleExW', 'dword', $iFlags, $sTypeOfModule, $sModule, 'ptr*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[3]
EndFunc
Func _WinAPI_GetMUILanguage()
Local $aRet = DllCall('comctl32.dll', 'word', 'GetMUILanguage')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPerformanceInfo()
Local $tPI = DllStructCreate('dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword')
Local $aRet = DllCall(@SystemDir & '\psapi.dll', 'bool', 'GetPerformanceInfo', 'struct*', $tPI, 'dword', DllStructGetSize($tPI))
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[13]
For $i = 0 To 12
$aResult[$i] = DllStructGetData($tPI, $i + 2)
Next
For $i = 0 To 8
$aResult[$i] *= $aResult[9]
Next
Return $aResult
EndFunc
Func _WinAPI_GetProcAddress($hModule, $vName)
Local $sType = "str"
If IsNumber($vName) Then $sType = "word"
Local $aResult = DllCall("kernel32.dll", "ptr", "GetProcAddress", "handle", $hModule, $sType, $vName)
If @error Or Not $aResult[0] Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_GetPhysicallyInstalledSystemMemory()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetPhysicallyInstalledSystemMemory', 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_GetProcessShutdownParameters()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetProcessShutdownParameters', 'dword*', 0, 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return SetExtended(Number(Not $aRet[2]), $aRet[1])
EndFunc
Func _WinAPI_GetProcessWindowStation()
Local $aRet = DllCall('user32.dll', 'handle', 'GetProcessWindowStation')
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetPwrCapabilities()
If Not __DLL('powrprof.dll') Then Return SetError(103, 0, 0)
Local $tSPC = DllStructCreate('byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]')
Local $aRet = DllCall('powrprof.dll', 'boolean', 'GetPwrCapabilities', 'struct*', $tSPC)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[25]
For $i = 0 To 17
$aResult[$i] = DllStructGetData($tSPC, 1, $i + 1)
Next
$aResult[18] = DllStructGetData($tSPC, 3)
For $i = 19 To 20
$aResult[$i] = DllStructGetData($tSPC, 5, $i - 18)
Next
For $i = 21 To 24
$aResult[$i] = DllStructGetData($tSPC, 7, $i - 20)
Next
Return $aResult
EndFunc
Func _WinAPI_GetRawInputBuffer($pBuffer, $iLength)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'struct*', $pBuffer, 'uint*', $iLength,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If ($aRet[0] = 4294967295) Or (Not $aRet[1]) Then Return SetError(10, -1, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetRawInputBufferLength()
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputBuffer', 'ptr', 0, 'uint*', 0,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return $aRet[2] * 8
EndFunc
Func _WinAPI_GetRawInputData($hRawInput, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputData', 'handle', $hRawInput, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength, 'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTHEADER)))
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aRet[3] ? $aRet[0] : $aRet[4])
EndFunc
Func _WinAPI_GetRawInputDeviceInfo($hDevice, $pBuffer, $iLength, $iFlag)
Local $aRet = DllCall('user32.dll', 'uint', 'GetRawInputDeviceInfoW', 'handle', $hDevice, 'uint', $iFlag, 'struct*', $pBuffer,  'uint*', $iLength)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then Return SetError(10, -1, 0)
Return ($aRet[3] ? $aRet[0] : $aRet[4])
EndFunc
Func _WinAPI_GetRegisteredRawInputDevices($pBuffer, $iLength)
Local $iLengthRAW = DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE))
Local $aRet = DllCall('user32.dll', 'uint', 'GetRegisteredRawInputDevices', 'struct*', $pBuffer,  'uint*', Floor($iLength / $iLengthRAW), 'uint', $iLengthRAW)
If @error Then Return SetError(@error, @extended, 0)
If $aRet[0] = 4294967295 Then
Local $iLastError = _WinAPI_GetLastError()
If $iLastError = 122 Then Return SetExtended($iLastError, $aRet[2] * $iLengthRAW)
Return SetError(10, $iLastError, 0)
EndIf
Return $aRet[0]
EndFunc
Func _WinAPI_GetStartupInfo()
Local $tSI = DllStructCreate($tagSTARTUPINFO)
DllCall('kernel32.dll', 'none', 'GetStartupInfoW', 'struct*', $tSI)
If @error Then Return SetError(@error, @extended, 0)
Return $tSI
EndFunc
Func _WinAPI_GetSystemDEPPolicy()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemDEPPolicy')
If @error Then Return SetError(@error, @extended, -1)
Return $aRet[0]
EndFunc
Func _WinAPI_GetSystemInfo()
Local $sProc
If _WinAPI_IsWow64Process() Then
$sProc = 'GetNativeSystemInfo'
Else
$sProc = 'GetSystemInfo'
EndIf
Local Const $tagSYSTEMINFO = 'struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;' &  'ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;' &  'dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision'
Local $tSystemInfo = DllStructCreate($tagSYSTEMINFO)
DllCall('kernel32.dll', 'none', $sProc, 'struct*', $tSystemInfo)
If @error Then Return SetError(@error, @extended, 0)
Local $aResult[10]
$aResult[0] = DllStructGetData($tSystemInfo, 1)
For $i = 1 To 9
$aResult[$i] = DllStructGetData($tSystemInfo, $i + 2)
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemPowerStatus()
Local $tagSYSTEM_POWER_STATUS = 'byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;' &  'int BatteryLifeTime;int BatteryFullLifeTime'
Local $tSYSTEM_POWER_STATUS = DllStructCreate($tagSYSTEM_POWER_STATUS)
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemPowerStatus', 'struct*', $tSYSTEM_POWER_STATUS)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[5]
$aResult[0] = DllStructGetData($tSYSTEM_POWER_STATUS, 1)
$aResult[1] = DllStructGetData($tSYSTEM_POWER_STATUS, 2)
$aResult[2] = DllStructGetData($tSYSTEM_POWER_STATUS, 3)
$aResult[3] = DllStructGetData($tSYSTEM_POWER_STATUS, 5)
$aResult[4] = DllStructGetData($tSYSTEM_POWER_STATUS, 6)
Return $aResult
EndFunc
Func _WinAPI_GetSystemTimes()
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetSystemTimes', 'uint64*', 0, 'uint64*', 0, 'uint64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Local $aResult[3]
For $i = 0 To 2
$aResult[$i] = $aRet[$i + 1]
Next
Return $aResult
EndFunc
Func _WinAPI_GetSystemWow64Directory()
Local $aRet = DllCall('kernel32.dll', 'uint', 'GetSystemWow64DirectoryW', 'wstr', '', 'uint', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, _WinAPI_GetLastError(), '')
Return $aRet[1]
EndFunc
Func _WinAPI_GetTickCount()
Local $aRet = DllCall('kernel32.dll', 'dword', 'GetTickCount')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetTickCount64()
Local $aRet = DllCall('kernel32.dll', 'uint64', 'GetTickCount64')
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_GetUserObjectInformation($hObject, $iIndex)
Local $aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'ptr', 0,  'dword', 0, 'dword*', 0)
If @error Or Not $aRet[5] Then Return SetError(@error + 10, @extended, 0)
Local $tData
Switch $iIndex
Case 1
$tData = DllStructCreate($tagUSEROBJECTFLAGS)
Case 5, 6
$tData = DllStructCreate('uint')
Case 2, 3
$tData = DllStructCreate('wchar[' & $aRet[5] & ']')
Case 4
$tData = DllStructCreate('byte[' & $aRet[5] & ']')
Case Else
Return SetError(20, 0, 0)
EndSwitch
$aRet = DllCall('user32.dll', 'bool', 'GetUserObjectInformationW', 'handle', $hObject, 'int', $iIndex, 'struct*', $tData,  'dword', DllStructGetSize($tData), 'dword*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 30, @extended, 0)
Switch $iIndex
Case 1, 4
Return $tData
Case Else
Return DllStructGetData($tData, 1)
EndSwitch
EndFunc
Func _WinAPI_GetVersion()
Return Number(BitAND(BitShift($__WINVER, 8), 0xFF) & '.' & BitAND($__WINVER, 0xFF), $NUMBER_DOUBLE)
EndFunc
Func _WinAPI_GetVersionEx()
Local $tOSVERSIONINFOEX = DllStructCreate($tagOSVERSIONINFOEX)
DllStructSetData($tOSVERSIONINFOEX, 'OSVersionInfoSize', DllStructGetSize($tOSVERSIONINFOEX))
Local $aRet = DllCall('kernel32.dll', 'bool', 'GetVersionExW', 'struct*', $tOSVERSIONINFOEX)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tOSVERSIONINFOEX
EndFunc
Func _WinAPI_GetWorkArea()
Local $tRECT = DllStructCreate($tagRECT)
Local $aRet = DllCall('user32.dll', 'int', 'SystemParametersInfo', 'uint', 48, 'uint', 0, 'struct*', $tRECT, 'uint', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $tRECT
EndFunc
Func _WinAPI_InitMUILanguage($iLanguage)
DllCall('comctl32.dll', 'none', 'InitMUILanguage', 'word', $iLanguage)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_IsLoadKBLayout($iLanguage)
Local $aLayout = _WinAPI_GetKeyboardLayoutList()
If @error Then Return SetError(@error, @extended, False)
For $i = 1 To $aLayout[0]
If $aLayout[$i] = $iLanguage Then Return True
Next
Return False
EndFunc
Func _WinAPI_IsProcessorFeaturePresent($iFeature)
Local $aRet = DllCall('kernel32.dll', 'bool', 'IsProcessorFeaturePresent', 'dword', $iFeature)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_IsWindowEnabled($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'IsWindowEnabled', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_Keybd_Event($vKey, $iFlags, $iScanCode = 0, $iExtraInfo = 0)
DllCall('user32.dll', 'none', 'keybd_event', 'byte', $vKey, 'byte', $iScanCode, 'dword', $iFlags, 'ulong_ptr', $iExtraInfo)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_LoadKeyboardLayout($iLanguage, $iFlag = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'LoadKeyboardLayoutW', 'wstr', Hex($iLanguage, 8), 'uint', $iFlag)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_LockWorkStation()
Local $aRet = DllCall('user32.dll', 'bool', 'LockWorkStation')
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_MapVirtualKey($iCode, $iType, $hLocale = 0)
Local $aRet = DllCall('user32.dll', 'INT', 'MapVirtualKeyExW', 'uint', $iCode, 'uint', $iType, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_Mouse_Event($iFlags, $iX = 0, $iY = 0, $iData = 0, $iExtraInfo = 0)
DllCall("user32.dll", "none", "mouse_event", "dword", $iFlags, "dword", $iX, "dword", $iY, "dword", $iData,  "ulong_ptr", $iExtraInfo)
If @error Then Return SetError(@error, @extended)
EndFunc
Func _WinAPI_OpenDesktop($sName, $iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenDesktopW', 'wstr', $sName, 'dword', $iFlags, 'bool', $bInherit,  'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenInputDesktop($iAccess = 0, $iFlags = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenInputDesktop', 'dword', $iFlags, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_OpenWindowStation($sName, $iAccess = 0, $bInherit = False)
Local $aRet = DllCall('user32.dll', 'handle', 'OpenWindowStationW', 'wstr', $sName, 'bool', $bInherit, 'dword', $iAccess)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_QueryPerformanceCounter()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceCounter', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_QueryPerformanceFrequency()
Local $aRet = DllCall('kernel32.dll', 'bool', 'QueryPerformanceFrequency', 'int64*', 0)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, 0)
Return $aRet[1]
EndFunc
Func _WinAPI_RegisterHotKey($hWnd, $iID, $iModifiers, $vKey)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterHotKey', 'hwnd', $hWnd, 'int', $iID, 'uint', $iModifiers, 'uint', $vKey)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterPowerSettingNotification($hWnd, $sGUID)
Local $tGUID = DllStructCreate($tagGUID)
Local $aRet = DllCall('ole32.dll', 'long', 'CLSIDFromString', 'wstr', $sGUID, 'struct*', $tGUID)
If @error Or $aRet[0] Then Return SetError(@error + 20, @extended, 0)
$aRet = DllCall('user32.dll', 'handle', 'RegisterPowerSettingNotification', 'handle', $hWnd, 'struct*', $tGUID, 'dword', 0)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_RegisterRawInputDevices($paDevice, $iCount = 1)
Local $aRet = DllCall('user32.dll', 'bool', 'RegisterRawInputDevices', 'struct*', $paDevice, 'uint', $iCount,  'uint', DllStructGetSize(DllStructCreate($tagRAWINPUTDEVICE)) * $iCount)
If @error Or Not $aRet[0] Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ReleaseCapture()
Local $aResult = DllCall("user32.dll", "bool", "ReleaseCapture")
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_RemoveClipboardFormatListener($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'RemoveClipboardFormatListener', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetActiveWindow($hWnd)
Local $aRet = DllCall('user32.dll', 'int', 'SetActiveWindow', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetCapture($hWnd)
Local $aResult = DllCall("user32.dll", "hwnd", "SetCapture", "hwnd", $hWnd)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDefaultPrinter($sPrinter)
Local $aResult = DllCall("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $sPrinter)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_SetDllDirectory($sDirPath = Default)
Local $sTypeOfPath = 'wstr'
If $sDirPath = Default Then
$sTypeOfPath = 'ptr'
$sDirPath = 0
EndIf
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetDllDirectoryW', $sTypeOfPath, $sDirPath)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_SetKeyboardLayout($hWnd, $iLanguage, $iFlags = 0)
If Not _WinAPI_IsWindow($hWnd) Then Return SetError(@error + 10, @extended, 0)
Local $hLocale = 0
If $iLanguage Then
$hLocale = _WinAPI_LoadKeyboardLayout($iLanguage)
If Not $hLocale Then Return SetError(10, 0, 0)
EndIf
Local Const $WM_INPUTLANGCHANGEREQUEST = 0x0050
DllCall('user32.dll', 'none', 'SendMessage', 'hwnd', $hWnd, 'uint', $WM_INPUTLANGCHANGEREQUEST, 'uint', $iFlags, 'uint_ptr', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return 1
EndFunc
Func _WinAPI_SetKeyboardState(ByRef $tState)
Local $aRet = DllCall('user32.dll', 'int', 'SetKeyboardState', 'struct*', $tState)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessShutdownParameters($iLevel, $bDialog = False)
Local $aRet = DllCall('kernel32.dll', 'bool', 'SetProcessShutdownParameters', 'dword', $iLevel, 'dword', Not $bDialog)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetProcessWindowStation($hStation)
Local $aRet = DllCall('user32.dll', 'bool', 'SetProcessWindowStation', 'handle', $hStation)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetUserObjectInformation($hObject, $iIndex, ByRef $tData)
If $iIndex <> 1 Then Return SetError(10, 0, False)
Local $aRet = DllCall('user32.dll', 'bool', 'SetUserObjectInformationW', 'handle', $hObject, 'int', 1, 'struct*', $tData,  'dword', DllStructGetSize($tData))
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SetWindowsHookEx($iHook, $pProc, $hDll, $iThreadId = 0)
Local $aResult = DllCall("user32.dll", "handle", "SetWindowsHookEx", "int", $iHook, "ptr", $pProc, "handle", $hDll,  "dword", $iThreadId)
If @error Then Return SetError(@error, @extended, 0)
Return $aResult[0]
EndFunc
Func _WinAPI_SetWinEventHook($iEventMin, $iEventMax, $pEventProc, $iPID = 0, $iThreadId = 0, $iFlags = 0)
Local $aRet = DllCall('user32.dll', 'handle', 'SetWinEventHook', 'uint', $iEventMin, 'uint', $iEventMax, 'ptr', 0,  'ptr', $pEventProc, 'dword', $iPID, 'dword', $iThreadId, 'uint', $iFlags)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonCreate($hWnd, $sText)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonCreate', 'hwnd', $hWnd, 'wstr', $sText)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonDestroy($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonDestroy', 'hwnd', $hWnd)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_ShutdownBlockReasonQuery($hWnd)
Local $aRet = DllCall('user32.dll', 'bool', 'ShutdownBlockReasonQuery', 'hwnd', $hWnd, 'wstr', '', 'dword*', 4096)
If @error Or Not $aRet[0] Then Return SetError(@error + 10, @extended, '')
Return $aRet[2]
EndFunc
Func _WinAPI_SwitchDesktop($hDesktop)
Local $aRet = DllCall('user32.dll', 'bool', 'SwitchDesktop', 'handle', $hDesktop)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_SystemParametersInfo($iAction, $iParam = 0, $vParam = 0, $iWinIni = 0)
Local $aResult = DllCall("user32.dll", "bool", "SystemParametersInfoW", "uint", $iAction, "uint", $iParam, "struct*", $vParam,  "uint", $iWinIni)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_TrackMouseEvent($hWnd, $iFlags, $iTime = -1)
Local $tTME = DllStructCreate('dword;dword;hwnd;dword')
DllStructSetData($tTME, 1, DllStructGetSize($tTME))
DllStructSetData($tTME, 2, $iFlags)
DllStructSetData($tTME, 3, $hWnd)
DllStructSetData($tTME, 4, $iTime)
Local $aRet = DllCall('user32.dll', 'bool', 'TrackMouseEvent', 'struct*', $tTME)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnhookWindowsHookEx($hHook)
Local $aResult = DllCall("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $hHook)
If @error Then Return SetError(@error, @extended, False)
Return $aResult[0]
EndFunc
Func _WinAPI_UnhookWinEvent($hEventHook)
Local $aRet = DllCall('user32.dll', 'bool', 'UnhookWinEvent', 'handle', $hEventHook)
If @error Then Return SetError(@error, @extended, False)
Return $aRet[0]
EndFunc
Func _WinAPI_UnloadKeyboardLayout($hLocale)
Local $aRet = DllCall('user32.dll', 'bool', 'UnloadKeyboardLayout', 'handle', $hLocale)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterHotKey($hWnd, $iID)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterHotKey', 'hwnd', $hWnd, 'int', $iID)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func _WinAPI_UnregisterPowerSettingNotification($hNotify)
Local $aRet = DllCall('user32.dll', 'bool', 'UnregisterPowerSettingNotification', 'handle', $hNotify)
If @error Then Return SetError(@error, @extended, 0)
Return $aRet[0]
EndFunc
Func __EnumPageFilesProc($iSize, $pInfo, $pFile)
Local $tEPFI = DllStructCreate('dword;dword;ulong_ptr;ulong_ptr;ulong_ptr', $pInfo)
__Inc($__g_vEnum)
$__g_vEnum[$__g_vEnum[0][0]][0] = DllStructGetData(DllStructCreate('wchar[' & (_WinAPI_StrLen($pFile) + 1) & ']', $pFile), 1)
For $i = 1 To 3
$__g_vEnum[$__g_vEnum[0][0]][$i] = DllStructGetData($tEPFI, $i + 2) * $iSize
Next
Return 1
EndFunc
#EndRegion Internal Functions
Global $aGLVEx_Data[1][27] = [[0, 0, -1, "", -1, -1, -1, -1, _WinAPI_GetSystemMetrics(2), False,  -1, -1, False, "", 0, True, 0, -1, -1, 0, 0, 0, 0, "08"]]
Global $hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_SrcIndex, $aGLVEx_SrcArray, $aGLVEx_SrcColArray
Global $hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_TgtIndex, $aGLVEx_TgtArray, $aGLVEx_TgtColArray
Global $iGLVEx_Dragging = 0, $iGLVEx_DraggedIndex, $hGLVEx_DraggedImage = 0, $sGLVEx_DragEvent
Global $iGLVEx_InsertIndex = -1, $iGLVEx_LastY, $fGLVEx_BarUnder, $fGVLEx_Resized = -1
Global $hGLVEx_Editing, $cGLVEx_EditID = 9999, $fGLVEx_EditClickFlag = 0, $fGLVEx_HeaderEdit = False
Global $fGLVEx_SelChangeFlag = 0, $fGLVEx_UserSelFlag = 0
Global $aGLVEx_DefColours[4] = ["0x000000", "0xFEFEFE", "0xFFFFFF", "0xCC6600"]
Func _GUIListViewEx_Init($hLV, $aArray = "", $iStart = 0, $iColour = 0, $fImage = False, $iAdded = 0)
Local $iLV_Index = 0
For $i = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$i][0] = 0 Then
$iLV_Index = $i
ExitLoop
EndIf
Next
If $iLV_Index = 0 Then
$aGLVEx_Data[0][0] += 1
ReDim $aGLVEx_Data[$aGLVEx_Data[0][0] + 1][UBound($aGLVEx_Data, 2)]
$iLV_Index = $aGLVEx_Data[0][0]
EndIf
If IsHWnd($hLV) Then
$aGLVEx_Data[$iLV_Index][0] = $hLV
$aGLVEx_Data[$iLV_Index][1] = 0
Else
$aGLVEx_Data[$iLV_Index][0] = GUICtrlGetHandle($hLV)
$aGLVEx_Data[$iLV_Index][1] = $hLV
EndIf
$aGLVEx_Data[0][24] = Opt("GUIDataSeparatorChar")
$aGLVEx_Data[$iLV_Index][2] =  _GUIListViewEx_ReadToArray($hLV, 1)
$aGLVEx_Data[$iLV_Index][20] = -1
$aGLVEx_Data[$iLV_Index][21] = -1
$aGLVEx_Data[$iLV_Index][3] = $iStart
If IsArray($aArray) Then
If UBound($aArray, 0) = 2 Then $aGLVEx_Data[$iLV_Index][3] += 2
EndIf
Local $aEditable[4][UBound($aGLVEx_Data[$iLV_Index][2], 2)]
$aGLVEx_Data[$iLV_Index][7] = $aEditable
_GUICtrlListView_SetInsertMarkColor($hLV, BitOR(BitShift(BitAND($iColour, 0x000000FF), -16), BitAND($iColour, 0x0000FF00), BitShift(BitAND($iColour, 0x00FF0000), 16)))
If $fImage Then
$aGLVEx_Data[$iLV_Index][5] = 1
EndIf
If BitAND($iAdded, 1) Then
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hLV)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Else
$aGLVEx_Data[$iLV_Index][4] = 0
EndIf
If BitAND($iAdded, 2) Then
$aGLVEx_Data[$iLV_Index][11] = 1
EndIf
If BitAND($iAdded, 4) Then
$aGLVEx_Data[$iLV_Index][9] = 1
EndIf
If BitAND($iAdded, 8) Then
$aGLVEx_Data[$iLV_Index][8] = 1
EndIf
Local $iCols = _GUICtrlListView_GetColumnCount($hLV)
Local $aHdrData[4][$iCols], $aRet
If BitAND($iAdded, 16) Then
Local $hHeader = _GUICtrlListView_GetHeader($hLV)
$aGLVEx_Data[$iLV_Index][24] = $hHeader
For $i = 0 To $iCols - 1
$aRet = _GUICtrlListView_GetColumn($hLV, $i)
$aHdrData[0][$i] = $aRet[5]
Next
EndIf
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
$aGLVEx_Data[$iLV_Index][23] = $aGLVEx_DefColours
$aGLVEx_Data[$iLV_Index][26] = $aGLVEx_DefColours[1]
If BitAND($iAdded, 32) Then
Local $aColArray = $aGLVEx_Data[$iLV_Index][2]
For $i = 1 To UBound($aColArray, 1) - 1
For $j = 0 To UBound($aColArray, 2) - 1
$aColArray[$i][$j] = ";"
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColArray
$aGLVEx_Data[$iLV_Index][19] = 1
EndIf
If BitAND($iAdded, 64) Then
$aGLVEx_Data[$iLV_Index][12] = 1
EndIf
If BitAND($iAdded, 128) Then
$aGLVEx_Data[$iLV_Index][12] += 2
EndIf
If BitAND($iAdded, 256) Then
$aGLVEx_Data[$iLV_Index][12] += 4
EndIf
If BitAND($iAdded, 512) Then
$aGLVEx_Data[$iLV_Index][12] += 8
EndIf
If BitAND($aGLVEx_Data[$iLV_Index][12], 8) And BitAND($aGLVEx_Data[$iLV_Index][12], 2) And BitAND($aGLVEx_Data[$iLV_Index][12], 1) Then
$aGLVEx_Data[$iLV_Index][12] += 16
EndIf
If BitAND($iAdded, 1024) Then
Local $iStyle = _WinAPI_GetWindowLong($aGLVEx_Data[$iLV_Index][0], $GWL_STYLE)
_WinAPI_SetWindowLong($aGLVEx_Data[$iLV_Index][0], $GWL_STYLE, BitOR($iStyle, $LVS_SINGLESEL))
$aGLVEx_Data[$iLV_Index][22] = 1
$aGLVEx_Data[$iLV_Index][23] = $aGLVEx_DefColours
EndIf
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hLV), 4) Then
$aGLVEx_Data[$iLV_Index][6] = 1
EndIf
If BitAND(_GUICtrlListView_GetExtendedListViewStyle($hLV), 0x00000010) Then
$aGLVEx_Data[$iLV_Index][13] = 1
EndIf
Local $aRect = _GUICtrlListView_GetItemRect($aGLVEx_Data[$iLV_Index][0], 0)
$aGLVEx_Data[$iLV_Index][10] = $aRect[3] - $aRect[1]
Local $iListView_Count = 0
For $i = 1 To $iLV_Index
If $aGLVEx_Data[$i][0] Then $iListView_Count += 1
Next
If $iListView_Count = 1 Then _GUIListViewEx_SetActive($iLV_Index)
Return $iLV_Index
EndFunc
Func _GUIListViewEx_Close($iLV_Index = 0)
Local $iEditKeyCode
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If $iLV_Index = 0 Then
$iEditKeyCode = $aGLVEx_Data[0][23]
Global $aGLVEx_Data[1][UBound($aGLVEx_Data, 2)] = [[0, 0, -1, "", -1, -1, -1, -1, _WinAPI_GetSystemMetrics(2), False,  -1, -1, False, "", 0, True, 0, -1, -1, 0, 0, 0, 0, $iEditKeyCode]]
Else
For $i = 0 To UBound($aGLVEx_Data, 2) - 1
$aGLVEx_Data[$iLV_Index][$i] = 0
Next
If $aGLVEx_Data[0][1] = $iLV_Index Then
$aGLVEx_Data[0][1] = 0
EndIf
EndIf
Return 1
EndFunc
Func _GUIListViewEx_SetActive($iLV_Index)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, -1)
Local $iCurr_Index = $aGLVEx_Data[0][1]
If $iLV_Index Then
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Else
$aGLVEx_Data[0][1] = 0
$hGLVEx_SrcHandle = 0
$cGLVEx_SrcID = 0
EndIf
Return $iCurr_Index
EndFunc
Func _GUIListViewEx_GetActive()
Return $aGLVEx_Data[0][1]
EndFunc
Func _GUIListViewEx_ReadToArray($hLV, $iStart = 0)
Local $aLVArray = "", $aRow
If Not IsHWnd($hLV) Then
$hLV = GUICtrlGetHandle($hLV)
If Not IsHWnd($hLV) Then
Return SetError(1, 0, "")
EndIf
EndIf
Local $iRows = _GUICtrlListView_GetItemCount($hLV)
Local $iCols = _GUICtrlListView_GetColumnCount($hLV)
If ($iRows + $iStart <> 0) And $iCols <> 0 Then
Local $aLVArray[$iRows + $iStart][$iCols] = [[$iRows]]
For $i = 0 To $iRows - 1
$aRow = _GUICtrlListView_GetItemTextArray($hLV, $i)
For $j = 1 To $aRow[0]
$aLVArray[$i + $iStart][$j - 1] = $aRow[$j]
Next
Next
Else
Local $aLVArray[1][1]
If $iStart = 1 Then $aLVArray[0][0] = 0
EndIf
Return $aLVArray
EndFunc
Func _GUIListViewEx_ReturnArray($iLV_Index, $iMode = 0)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
Local $hLV = $aGLVEx_Data[$iLV_Index][0]
Local $sOrder = _GUICtrlListView_GetColumnOrder($hLV)
Local $aColOrder[1]
If $sOrder = "" Then
$aColOrder[0] = 0
Else
$aColOrder = StringSplit($sOrder, $aGLVEx_Data[0][24])
EndIf
Local $aData_Colour = $aGLVEx_Data[$iLV_Index][2]
If $aColOrder[0] = 0 Then
$aData_Colour = ""
Return SetError(2, 0, "")
EndIf
Local $iDim_1 = UBound($aData_Colour, 1), $iDim_2 = UBound($aData_Colour, 2)
Local $aCheck[$iDim_1], $aHeader[$iDim_2], $aHdrData
Switch $iMode
Case 0, 3
Case 1
If $aGLVEx_Data[$iLV_Index][6] Then
For $i = 1 To $iDim_1 - 1
$aCheck[$i] = _GUICtrlListView_GetItemChecked($hLV, $i - 1)
Next
If BitAND($aGLVEx_Data[$iLV_Index][3], 1) = 0 Then
__GUIListViewEx_Array_Delete($aCheck, 0, True)
EndIf
Return $aCheck
Else
Return SetError(3, 0, "")
EndIf
Case 2
If $aGLVEx_Data[$iLV_Index][19] Then
$aData_Colour = $aGLVEx_Data[$iLV_Index][18]
For $i = 0 To UBound($aData_Colour, 1) - 1
For $j = 0 To UBound($aData_Colour, 2) - 1
$aData_Colour[$i][$j] = StringRegExpReplace($aData_Colour[$i][$j], "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
Next
Next
$aData_Colour[0][0] = $iDim_1 - 1
Else
Return SetError(4, 0, "")
EndIf
Case 4
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To $iDim_2 - 1
$aHeader[$i] = $aHdrData[0][$i]
Next
Else
Local $aRet
For $i = 0 To $iDim_2 - 1
$aRet = _GUICtrlListView_GetColumn($hLV, $i)
$aHeader[$i] = $aRet[5]
Next
EndIf
Case 5
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To $iDim_2 - 1
$aHeader[$i] = $aHdrData[1][$i]
Next
Else
Return SetError(5, 0, "")
EndIf
Case Else
Return SetError(6, 0, "")
EndSwitch
If $aGLVEx_Data[$iLV_Index][13] And UBound($aData_Colour, 2) Then
Switch $iMode
Case 0, 2, 3
Local $aData_Colour_Ordered[$iDim_1][$iDim_2]
If $iDim_1 <> 1 Or $iDim_2 <> 0 Then
$aData_Colour_Ordered[0][0] = $aData_Colour[0][0]
For $i = 1 To $iDim_1 - 1
For $j = 0 To $iDim_2 - 1
$aData_Colour_Ordered[$i][$j] = $aData_Colour[$i][$aColOrder[$j + 1]]
Next
Next
EndIf
$aData_Colour = $aData_Colour_Ordered
$aData_Colour_Ordered = ""
Case 4, 5
Local $aHeader_Ordered[$iDim_2]
If $iDim_1 <> 1 Or $iDim_2 <> 0 Then
For $i = 0 To $iDim_2 - 1
$aHeader_Ordered[$i] = $aHeader[$aColOrder[$i + 1]]
Next
EndIf
Return $aHeader_Ordered
EndSwitch
Else
If $iMode = 4 Then
Return $aHeader
EndIf
EndIf
Local $iCount = 1
If BitAND($aGLVEx_Data[$iLV_Index][3], 1) = 0 Or $iMode = 2 Then
$iCount = 0
__GUIListViewEx_Array_Delete($aData_Colour, 0, True)
EndIf
If BitAND($aGLVEx_Data[$iLV_Index][3], 2) = 0 And $iMode < 2 Then
If UBound($aData_Colour, 1) = 0 Then
Local $aData_Colour[0]
Else
Local $iCols = UBound($aData_Colour, 2)
Local $aData_Colour_1D[UBound($aData_Colour)] = [$aData_Colour[0][0]]
For $i = $iCount To UBound($aData_Colour_1D) - 1
Local $aLine = ""
For $j = 0 To $iCols - 1
$aLine &= $aData_Colour[$i][$j] & $aGLVEx_Data[0][24]
Next
$aData_Colour_1D[$i] = StringTrimRight($aLine, 1)
Next
$aData_Colour = $aData_Colour_1D
EndIf
EndIf
Return $aData_Colour
EndFunc
Func _GUIListViewEx_SaveListView($iLV_Index, $sFileName)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $iStart = BitAND($aGLVEx_Data[$iLV_Index][3], 1)
Local $sHeader = "", $aRet
If $aGLVEx_Data[$iLV_Index][24] Then
Local $aHdrData = $aGLVEx_Data[$iLV_Index][25]
For $i = 0 To _GUICtrlListView_GetColumnCount($hLV_Handle) - 1
$aRet = _GUICtrlListView_GetColumn($hLV_Handle, $i)
$sHeader &= $aHdrData[0][$i] & @CR & $aRet[4] & @CR & $aHdrData[1][$i] & @CR & $aHdrData[2][$i] & @CR & $aHdrData[3][$i] & @LF
Next
Else
For $i = 0 To _GUICtrlListView_GetColumnCount($hLV_Handle) - 1
$aRet = _GUICtrlListView_GetColumn($hLV_Handle, $i)
$sHeader &= $aRet[5] & @CR & $aRet[4] & @CR & @CR & @CR & @LF
Next
EndIf
$sHeader = StringTrimRight($sHeader, 1)
Local $aData = _GUIListViewEx_ReturnArray($iLV_Index, 3)
If $iStart Then
_ArrayDelete($aData, 0)
EndIf
Local $aCheck = _GUIListViewEx_ReturnArray($iLV_Index, 1)
If $iStart Then
_ArrayDelete($aCheck, 0)
EndIf
Local $aColour = _GUIListViewEx_ReturnArray($iLV_Index, 2)
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aSortable = $aGLVEx_Data[$iLV_Index][4]
Local $sData = "", $sCheck = "", $sColour = "", $sEditable = "", $sSortable = ""
If IsArray($aData) Then
$sData = __GUIListViewEx_MakeString($aData)
EndIf
If IsArray($aCheck) Then
$sCheck = __GUIListViewEx_MakeString($aCheck)
EndIf
If IsArray($aColour) Then
$sColour = __GUIListViewEx_MakeString($aColour)
EndIf
If IsArray($aEditable) Then
$sEditable = __GUIListViewEx_MakeString($aEditable)
EndIf
If IsArray($aSortable) Then
$sSortable = __GUIListViewEx_MakeString($aSortable)
EndIf
Local $iError = 0
Local $hFile = FileOpen($sFileName, $FO_OVERWRITE)
If @error Then
$iError = 1
Else
FileWrite($hFile, $sHeader & ChrW(0xEF0F) & $sData & ChrW(0xEF0F) & $sCheck & ChrW(0xEF0F) & $sColour & ChrW(0xEF0F) & $sEditable & ChrW(0xEF0F) & $sSortable)
If @error Then
$iError = 2
EndIf
EndIf
FileClose($hFile)
If $iError Then Return SetError(2, $iError, 0)
Return 1
EndFunc
Func _GUIListViewEx_LoadListView($iLV_Index, $sFileName, $iDims = 2)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Switch $iDims
Case 1, 2
Case Else
Return SetError(2, 0, 0)
EndSwitch
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
Local $iStart = BitAND($aGLVEx_Data[$iLV_Index][3], 1)
Local $sContent = FileRead($sFileName)
If @error Then Return SetError(3, 0, 0)
Local $aSplit = StringSplit($sContent, ChrW(0xEF0F), $STR_ENTIRESPLIT)
Local $aHeader = __GUIListViewEx_MakeArray($aSplit[1])
If Not IsArray($aHeader) Then Return SetError(4, 0, 0)
Local $aData = __GUIListViewEx_MakeArray($aSplit[2])
If Not IsArray($aData) Then Return SetError(4, 0, 0)
Local $aCheck = __GUIListViewEx_MakeArray($aSplit[3])
Local $aColour = __GUIListViewEx_MakeArray($aSplit[4])
Local $aEditable = __GUIListViewEx_MakeArray($aSplit[5])
Local $aSortable = __GUIListViewEx_MakeArray($aSplit[6])
If UBound($aData, 0) = 1 Then
Local $aTempData[UBound($aData)][1]
Local $aTempCol[UBound($aData)][1]
For $i = 0 To UBound($aData) - 1
$aTempData[$i][0] = $aData[$i]
$aTempCol[$i][0] = $aColour[$i]
Next
$aData = $aTempData
$aColour = $aTempCol
EndIf
Local $aHdrData[4][UBound($aHeader)]
For $i = 0 To UBound($aHeader) - 1
$aHdrData[0][$i] = $aHeader[$i][0]
$aHdrData[1][$i] = $aHeader[$i][2]
$aHdrData[2][$i] = $aHeader[$i][3]
$aHdrData[3][$i] = $aHeader[$i][4]
Next
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
$aGLVEx_Data[0][12] = 1
$aGLVEx_Data[0][15] = False
_GUICtrlListView_BeginUpdate($hLV_Handle)
_GUICtrlListView_DeleteAllItems($hLV_Handle)
Local $iCol_Count = _GUICtrlListView_GetColumnCount($hLV_Handle)
If $iCol_Count < UBound($aHeader) Then
For $i = $iCol_Count To UBound($aHeader) - 1
_GUICtrlListView_AddColumn($hLV_Handle, "", 100)
Next
EndIf
If $iCol_Count > UBound($aHeader) Then
For $i = $iCol_Count To UBound($aHeader) Step -1
_GUICtrlListView_DeleteColumn($hLV_Handle, $i)
Next
EndIf
For $i = 0 To UBound($aHeader) - 1
_GUICtrlListView_SetColumn($hLV_Handle, $i, $aHeader[$i][0], $aHeader[$i][1])
Next
If $cLV_CID Then
Local $sLine, $iLastCol = UBound($aData, 2) - 1
For $i = 0 To UBound($aData) - 1
$sLine = ""
For $j = 0 To $iLastCol
$sLine &= $aData[$i][$j] & $aGLVEx_Data[0][24]
Next
GUICtrlCreateListViewItem(StringTrimRight($sLine, 1), $cLV_CID)
Next
Else
_GUICtrlListView_AddArray($hLV_Handle, $aData)
EndIf
_GUICtrlListView_EndUpdate($hLV_Handle)
_ArrayInsert($aData, 0, UBound($aData))
$aGLVEx_Data[$iLV_Index][2] = $aData
$aGLVEx_Data[$iLV_Index][7] = $aEditable
$aGLVEx_Data[$iLV_Index][4] = $aSortable
$aGLVEx_Data[$iLV_Index][3] = $iStart + (($iDims = 2) ? (2) : (0))
If IsArray($aCheck) Then
For $i = 0 To UBound($aCheck) - 1
If $aCheck[$i] = "True" Then
_GUICtrlListView_SetItemChecked($hLV_Handle, $i, True)
EndIf
Next
EndIf
$aGLVEx_Data[0][12] = 0
$aGLVEx_Data[0][15] = True
If $aGLVEx_Data[$iLV_Index][19] Then
If IsArray($aColour) Then
_GUIListViewEx_LoadColour($iLV_Index, $aColour)
Else
$aColour = $aData
For $i = 0 To UBound($aData) - 1
For $j = 0 To UBound($aData, 2) - 1
$aColour[$i][$j] = ";"
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColour
EndIf
EndIf
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_Data[0][1] = $iLV_Index
Return 1
EndFunc
Func _GUIListViewEx_Up()
Local $iGLVExMove_Index, $iGLVEx_Moving = 0
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, 0)
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $aGLVEx_SrcArray[0][0] = 0 Then
$aGLVEx_SrcArray = 0
Return SetError(4, 0, "")
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
Local $aIndex = StringSplit($iIndex, "|")
$iGLVExMove_Index = $aIndex[1]
If $aIndex[0] > 1 Then
For $i = 1 To $aIndex[0] - 1
If $aIndex[$i + 1] = $aIndex[1] + $i Then
$iGLVEx_Moving += 1
Else
ExitLoop
EndIf
Next
Else
$iGLVExMove_Index = $aIndex[1]
EndIf
If $iGLVExMove_Index < 1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, 0)
Return SetError(3, 0, "")
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
$aGLVEx_Data[0][12] = True
For $iIndex = $iGLVExMove_Index To $iGLVExMove_Index + $iGLVEx_Moving
__GUIListViewEx_Array_Swap($aGLVEx_SrcArray, $iIndex, $iIndex + 1)
__GUIListViewEx_Array_Swap($aCheck_Array, $iIndex, $iIndex + 1)
__GUIListViewEx_Array_Swap($aGLVEx_SrcColArray, $iIndex, $iIndex + 1)
Next
$aGLVEx_Data[$iLV_Index][20] -= 1
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
For $i = 0 To $iGLVEx_Moving
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVExMove_Index + $i - 1)
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Down()
Local $iGLVExMove_Index, $iGLVEx_Moving = 0
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, 0)
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $aGLVEx_SrcArray[0][0] = 0 Then
$aGLVEx_SrcArray = 0
Return SetError(4, 0, "")
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
If $iIndex = -1 Then $iIndex = 0
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
Local $aIndex = StringSplit($iIndex, "|")
If $aIndex[0] > 1 Then
$iGLVExMove_Index = $aIndex[$aIndex[0]]
For $i = 1 To $aIndex[0] - 1
If $aIndex[$aIndex[0] - $i] = $aIndex[$aIndex[0]] - $i Then
$iGLVEx_Moving += 1
Else
ExitLoop
EndIf
Next
Else
$iGLVExMove_Index = $aIndex[1]
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
If $iGLVExMove_Index = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle) - 1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iIndex)
Return SetError(3, 0, "")
EndIf
$aGLVEx_Data[0][12] = True
For $iIndex = $iGLVExMove_Index To $iGLVExMove_Index - $iGLVEx_Moving Step -1
__GUIListViewEx_Array_Swap($aGLVEx_SrcArray, $iIndex + 1, $iIndex + 2)
__GUIListViewEx_Array_Swap($aCheck_Array, $iIndex + 1, $iIndex + 2)
__GUIListViewEx_Array_Swap($aGLVEx_SrcColArray, $iIndex + 1, $iIndex + 2)
Next
$aGLVEx_Data[$iLV_Index][20] += 1
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
For $i = 0 To $iGLVEx_Moving
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVExMove_Index - $iGLVEx_Moving + $i + 1)
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Insert($vData, $fMultiRow = False, $fRetainWidth = False)
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
Local $iInsert_Index = $iIndex
If $iIndex == "" Then $iInsert_Index = -1
If StringInStr($iIndex, "|") Then
Local $aIndex = StringSplit($iIndex, "|")
$iIndex = $aIndex[1]
For $i = 2 To $aIndex[0]
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $aIndex[$i], False)
Next
EndIf
Local $vRet = _GUIListViewEx_InsertSpec($iLV_Index, $iInsert_Index + 1, $vData, $fMultiRow, $fRetainWidth)
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_InsertSpec($iLV_Index, $iRow, $vData, $fMultiRow = False, $fRetainWidth = False)
Local $vInsert, $iMax_Row
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $aHdrData = $aGLVEx_Data[$iLV_Index][25]
If UBound($aHdrData, 2) = 0 Then
$aGLVEx_SrcArray = ""
Return SetError(2, 0, "")
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
If Not IsArray($aGLVEx_SrcArray) Or UBound($aGLVEx_SrcArray) = 0 Then
$iMax_Row = 0
Else
$iMax_Row = $aGLVEx_SrcArray[0][0]
If $iRow = -1 Then $iRow = $iMax_Row
If $iRow < 0 Or $iRow > $iMax_Row Then Return SetError(3, 0, "")
EndIf
If IsArray($vData) Then
$vInsert = $vData
Else
Local $aData = StringSplit($vData, $aGLVEx_Data[0][24])
Switch $aData[0]
Case 1
$vInsert = $aData[1]
Case Else
Local $vInsert[$aData[0]]
For $i = 0 To $aData[0] - 1
$vInsert[$i] = $aData[$i + 1]
Next
EndSwitch
EndIf
$aGLVEx_Data[0][12] = True
If $iRow = -1 Then
__GUIListViewEx_Array_Add($aGLVEx_SrcArray, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Add($aCheck_Array, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Add($aGLVEx_SrcColArray, ";", $fMultiRow)
Else
__GUIListViewEx_Array_Insert($aGLVEx_SrcArray, $iRow + 1, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Insert($aCheck_Array, $iRow + 1, $vInsert, $fMultiRow)
__GUIListViewEx_Array_Insert($aGLVEx_SrcColArray, $iRow + 1, ";", $fMultiRow)
EndIf
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox, $fRetainWidth)
EndIf
If $iRow = -1 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle) - 1)
Else
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iRow)
EndIf
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_Delete($vRange = "")
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $vRet = _GUIListViewEx_DeleteSpec($iLV_Index, $vRange)
Local $iError = @error
Local $bEmpty = False
If UBound($vRet) = 0 Then
$bEmpty = True
Else
If UBound($vRet, 2) <> 0 Then
If $vRet[0][0] = 0 Then
$bEmpty = True
EndIf
Else
If $vRet[0] = 0 Then
$bEmpty = True
EndIf
EndIf
EndIf
If $bEmpty Then
$aGLVEx_Data[$iLV_Index][20] = -1
EndIf
Return SetError($iError, 0, $vRet)
EndFunc
Func _GUIListViewEx_DeleteSpec($iLV_Index, $vRange = "")
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If UBound($aGLVEx_SrcArray) = 1 Then
Return SetError(3, 0, "")
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
If $vRange = "-1" Then
$vRange = UBound($aGLVEx_SrcArray) - 2
EndIf
Local $iIndex, $aIndex
If String($vRange) <> "" Then
$aIndex = __GUIListViewEx_ExpandRange($vRange, $iLV_Index, 0)
If @error Then Return SetError(4, 0, 0)
Else
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If $iIndex == "" Then
Return SetError(2, 0, "")
EndIf
$aIndex = StringSplit($iIndex, $aGLVEx_Data[0][24])
EndIf
For $i = 1 To $aIndex[0]
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $i, False)
Next
$aGLVEx_Data[0][12] = True
For $i = $aIndex[0] To 1 Step -1
If $aIndex[$i] <= UBound($aGLVEx_SrcArray) - 2 Then
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $aIndex[$i] + 1)
__GUIListViewEx_Array_Delete($aCheck_Array, $aIndex[$i] + 1)
__GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $aIndex[$i] + 1)
EndIf
Next
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
If $aIndex[1] = 0 Then
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, 0)
Else
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $aIndex[1] - 1)
EndIf
EndIf
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_InsertCol($sTitle = "", $iWidth = 50)
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $vRet = _GUIListViewEx_InsertColSpec($iLV_Index, $aGLVEx_Data[$iLV_Index][21] + 1, $sTitle, $iWidth)
Return SetError(@error, 0, $vRet)
EndFunc
Func _GUIListViewEx_InsertColSpec($iLV_Index, $iCol = -1, $sTitle = "", $iWidth = 75)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
Local $fColourEnabled = $aGLVEx_Data[$iLV_Index][19]
Local $aHdrData
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $fColourEnabled Then
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then $iCol = $iMax_Col + 1
If $iCol < 0 Or $iCol > $iMax_Col Then Return SetError(2, 0, "")
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
$aGLVEx_Data[0][12] = True
If UBound($aHdrData, 2) = 0 Then
Else
ReDim $aGLVEx_SrcArray[UBound($aGLVEx_SrcArray)][UBound($aGLVEx_SrcArray, 2) + 1]
If $fColourEnabled Then
ReDim $aGLVEx_SrcColArray[UBound($aGLVEx_SrcColArray)][UBound($aGLVEx_SrcColArray, 2) + 1]
EndIf
For $i = 0 To UBound($aGLVEx_SrcArray) - 1
For $j = UBound($aGLVEx_SrcArray, 2) - 2 To $iCol Step -1
$aGLVEx_SrcArray[$i][$j + 1] = $aGLVEx_SrcArray[$i][$j]
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$j + 1] = $aGLVEx_SrcColArray[$i][$j]
EndIf
Next
$aGLVEx_SrcArray[$i][$iCol] = ""
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$iCol] = ";"
EndIf
Next
EndIf
ReDim $aEditable[4][UBound($aEditable, 2) + 1]
ReDim $aHdrData[4][UBound($aHdrData, 2) + 1]
For $i = 0 To 3
For $j = UBound($aEditable, 2) - 2 To $iCol Step -1
$aEditable[$i][$j + 1] = $aEditable[$i][$j]
$aHdrData[$i][$j + 1] = $aHdrData[$i][$j]
Next
$aEditable[$i][$iCol] = ""
Next
$aHdrData[0][$iCol] = $sTitle
$aHdrData[1][$iCol] = ";"
$aHdrData[2][$iCol] = ""
$aHdrData[3][$iCol] = 0
$aGLVEx_SrcArray[0][0] = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
If $fColourEnabled Then
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
EndIf
$aGLVEx_Data[$iLV_Index][7] = $aEditable
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
_GUICtrlListView_InsertColumn($hGLVEx_SrcHandle, $iCol, $sTitle, $iWidth)
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
EndIf
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_DeleteCol()
Local $iLV_Index = $aGLVEx_Data[0][1]
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Local $iCol = $aGLVEx_Data[$iLV_Index][21]
If $iCol = -1 Then $iCol = 0
Local $vRet = _GUIListViewEx_DeleteColSpec($iLV_Index, $iCol)
Local $iError = @error
If Not @error Then
If UBound($vRet, 2) <= $aGLVEx_Data[0][2]  Then
$aGLVEx_Data[$iLV_Index][21] = -1
EndIf
EndIf
Return SetError($iError, 0, $vRet)
EndFunc
Func _GUIListViewEx_DeleteColSpec($iLV_Index, $iCol = -1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, "")
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
Local $fCheckBox = $aGLVEx_Data[$iLV_Index][6]
Local $fColourEnabled = $aGLVEx_Data[$iLV_Index][19]
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
If $fColourEnabled Then
$aGLVEx_SrcColArray = $aGLVEx_Data[$iLV_Index][18]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aHdrData[4][UBound($aGLVEx_SrcArray, 2)]
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then $iCol = $iMax_Col
If $iCol < 0 Or $iCol > $iMax_Col Then Return SetError(2, 0, "")
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
$aGLVEx_Data[0][12] = True
If UBound($aGLVEx_SrcArray, 2) = 1 Then
ReDim $aGLVEx_SrcArray[1][1]
$aGLVEx_SrcArray[0][0] = 0
ReDim $aGLVEx_SrcColArray[1][1]
ReDim $aEditable[4][0]
ReDim $aHdrData[4][0]
Else
For $i = 0 To UBound($aGLVEx_SrcArray) - 1
For $j = $iCol To UBound($aGLVEx_SrcArray, 2) - 2
$aGLVEx_SrcArray[$i][$j] = $aGLVEx_SrcArray[$i][$j + 1]
If $fColourEnabled Then
$aGLVEx_SrcColArray[$i][$j] = $aGLVEx_SrcColArray[$i][$j + 1]
EndIf
Next
Next
ReDim $aGLVEx_SrcArray[UBound($aGLVEx_SrcArray)][UBound($aGLVEx_SrcArray, 2) - 1]
If $fColourEnabled Then
ReDim $aGLVEx_SrcColArray[UBound($aGLVEx_SrcColArray)][UBound($aGLVEx_SrcColArray, 2) - 1]
EndIf
For $i = 0 To 3
For $j = $iCol To UBound($aEditable, 2) - 2
$aEditable[$i][$j] = $aEditable[$i][$j + 1]
$aHdrData[$i][$j] = $aHdrData[$i][$j + 1]
Next
Next
ReDim $aEditable[4][UBound($aEditable, 2) - 1]
ReDim $aHdrData[4][UBound($aHdrData, 2) - 1]
$aGLVEx_SrcArray[0][0] = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
EndIf
_GUICtrlListView_DeleteColumn($hGLVEx_SrcHandle, $iCol)
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
If $fColourEnabled Then
$aGLVEx_Data[$iLV_Index][18] = $aGLVEx_SrcColArray
EndIf
$aGLVEx_Data[$iLV_Index][7] = $aEditable
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
If $aGLVEx_Data[0][15] Then
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iLV_Index, $fCheckBox)
EndIf
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iLV_Index)
$aGLVEx_SrcArray = 0
$aGLVEx_SrcColArray = 0
Local $aLVSortState[_GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)]
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_SortCol($iLV_Index, $iCol = -1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $iMax_Col = UBound($aGLVEx_SrcArray, 2) - 1
If $iCol = -1 Then
$iCol = $aGLVEx_Data[$iLV_Index][21]
EndIf
If $iCol < 0 Or $iCol > $iMax_Col Then Return SetError(2, 0, 0)
Local $aLVSortState = $aGLVEx_Data[$iLV_Index][4]
__GUIListViewEx_ColSort($aGLVEx_Data[$iLV_Index][0], $iLV_Index, $aLVSortState, $iCol)
Return 1
EndFunc
Func _GUIListViewEx_SetEditStatus($iLV_Index, $vCol, $iMode = 1, $vParam1 = Default, $vParam2 = Default)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
Local $aRange = __GUIListViewEx_ExpandRange($vCol, $iLV_Index)
If @error Then Return SetError(2, 0, 0)
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Switch $iMode
Case 0, 1
If $vParam1 = Default Then $vParam1 = 0
If $vParam2 = Default Then $vParam2 = ""
Switch $vParam1
Case 0
If $vParam2 Then
Return SetError(4, 12, 0)
EndIf
Case 1
If $vParam2 And Not StringRegExp($vParam2, "^\d+\|\d+\|(0|1)$") Then
Return SetError(4, 12, 0)
EndIf
Case Else
Return SetError(4, 11, 0)
EndSwitch
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = $iMode
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 2
If Not (IsArray($vParam1) Or IsString($vParam1)) Then
Return SetError(4, 21, 0)
EndIf
If $vParam2 = Default Then $vParam2 = 0
Switch $vParam2
Case 0 To 3
Case Else
Return SetError(4, 22, 0)
EndSwitch
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 2
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 3
If $vParam1 = Default Then
$vParam1 = ""
EndIf
If Not StringRegExp($vParam1, "^(\d{4}\/\d{2}\/\d{2})?#?$") Then
Return SetError(4, 31, 0)
EndIf
If $vParam2 = Default Then
$vParam2 = ""
EndIf
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 3
$aEditable[1][$aRange[$i]] = $vParam1
$aEditable[2][$aRange[$i]] = $vParam2
Next
Case 9
If Not IsFunc($vParam1) Then
Return SetError(4, 91, 0)
EndIf
For $i = 1 To $aRange[0]
$aEditable[0][$aRange[$i]] = 9
$aEditable[1][$aRange[$i]] = $vParam1
Next
Case Else
Return SetError(3, 0, 0)
EndSwitch
$aGLVEx_Data[$iLV_Index][7] = $aEditable
Return 1
EndFunc
Func _GUIListViewEx_SetEditKey($sKey = Default)
If $sKey = Default Then
$aGLVEx_Data[0][23] = "08"
Return 1
EndIf
If Not StringRegExp($sKey, "(?i)^([!^]){0,2}([0-9a-f]{2})$") Then
Return SetError(1, 0, 0)
EndIf
$aGLVEx_Data[0][23] = StringReplace(StringReplace($sKey, "^", "11;"), "!", "12;")
Return 1
EndFunc
Func _GUIListViewEx_EditItem($iLV_Index, $iRow, $iCol, $iEditMode = 0, $iDelta_X = 0, $iDelta_Y = 0)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, "")
EndIf
Local $iMax = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
If $iRow < 0 Or $iRow > $iMax - 1 Then
Return SetError(3, 0, "")
EndIf
$iMax = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(4, 0, "")
EndIf
Switch Abs($iEditMode)
Case 0, 11, 12, 13, 21, 22, 23, 31, 32, 33
Case Else
Return SetError(5, 0, "")
EndSwitch
Local $aLocation[2] = [$iRow, $iCol]
Local $aEdited = __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode, True)
If $aEdited[0][0] = 0 Then
$aEdited = ""
EndIf
Local $iKeyCode = @extended
_WinAPI_GetAsyncKeyState($iKeyCode)
While _WinAPI_GetAsyncKeyState($iKeyCode)
Sleep(10)
WEnd
_GUICtrlListView_SetItemSelected($aGLVEx_Data[$iLV_Index][0], -1, False)
SetExtended(($iKeyCode = 0x0D) ? (True) : (False))
Return $aEdited
EndFunc
Func _GUIListViewEx_EditWidth($iLV_Index, $aWidth)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
If (Not IsArray($aWidth)) Or (UBound($aWidth, 0) <> 1) Then Return SetError(2, 0, 0)
ReDim $aWidth[_GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])]
$aGLVEx_Data[$iLV_Index][14] = $aWidth
EndFunc
Func _GUIListViewEx_ChangeItem($iLV_Index, $iRow, $iCol, $vValue)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, "")
EndIf
Local $iMax = _GUICtrlListView_GetItemCount($hGLVEx_SrcHandle)
If $iRow < 0 Or $iRow > $iMax - 1 Then
Return SetError(3, 0, "")
EndIf
$iMax = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(4, 0, "")
EndIf
Local $aData_Array = $aGLVEx_Data[$iLV_Index][2]
_GUICtrlListView_SetItemText($hGLVEx_SrcHandle, $iRow, $vValue, $iCol)
$aData_Array[$iRow + 1][$iCol] = $vValue
$aGLVEx_Data[$iLV_Index][2] = $aData_Array
__GUIListViewEx_RedrawWindow($iLV_Index)
Return _GUIListViewEx_ReturnArray($iLV_Index)
EndFunc
Func _GUIListViewEx_LoadHdrData($iLV_Index, $aHdrData)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If UBound($aHdrData, 0) <> 2 Then
Return SetError(2, 0, 0)
EndIf
If UBound($aHdrData) <> 4 Then
Return SetError(2, 1, 0)
EndIf
If UBound($aHdrData, 2) <> UBound($aGLVEx_Data[$iLV_Index][2], 2) Then
Return SetError(2, 2, 0)
EndIf
Local $sColSet, $aColSplit
For $i = 0 To UBound($aHdrData, 2) - 1
If $aHdrData[0][$i] = Default Then
$aHdrData[0][$i] = ""
EndIf
$sColSet = $aHdrData[1][$i]
If $sColSet = "" Or $sColSet = Default Then
$sColSet = ";"
EndIf
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(4, 0, 0)
EndIf
$aColSplit = StringSplit($sColSet, ";")
For $j = 1 To 2
If $aColSplit[$j] And Not $aGLVEx_Data[$iLV_Index][24] Then
Return SetError(3, 0, 0)
Else
$aColSplit[$j] = StringRegExpReplace($aColSplit[$j], "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
EndIf
Next
$aHdrData[1][$i] = $aColSplit[1] & ";" & $aColSplit[2]
If $aHdrData[2][$i] = Default Then
$aHdrData[2][$i] = ""
EndIf
If $aHdrData[3][$i] = Default Then
$aHdrData[3][$i] = _GUICtrlListView_GetColumnWidth($aGLVEx_Data[$iLV_Index][0], $i)
Else
$aHdrData[3][$i] = Abs(Number($aHdrData[3][$i]))
EndIf
Next
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
__GUIListViewEx_RedrawWindow($iLV_Index, True)
Return 1
EndFunc
Func _GUIListViewEx_EditHeader($iLV_Index = Default, $iCol = Default, $iDelta_X = 0, $iDelta_Y = 0)
Local $aRet = ""
If $iLV_Index = Default Then
$iLV_Index = $aGLVEx_Data[0][1]
EndIf
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, $aRet)
EndIf
Local $hLV_Handle = $aGLVEx_Data[$iLV_Index][0]
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $aGLVEx_Data[$iLV_Index][8] = "" Then
Return SetError(2, 0, $aRet)
EndIf
If $iCol = Default Then
$iCol = $aGLVEx_Data[0][2]
EndIf
Local $iMax = _GUICtrlListView_GetColumnCount($hLV_Handle)
If $iCol < 0 Or $iCol > $iMax - 1 Then
Return SetError(3, 0, $aRet)
EndIf
Local $tLVPos = DllStructCreate("struct;long X;long Y;endstruct")
__GUIListViewEx_GetLVCoords($hLV_Handle, $tLVPos)
Local $aLVClient = WinGetClientSize($hLV_Handle)
Local $aLV_FontDetails = __GUIListViewEx_GetLVFont($hLV_Handle)
WinSetState($hLV_Handle, "", @SW_DISABLE)
Local $aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $aColData, $sHeaderOrgText
If $aGLVEx_Data[$iLV_Index][24] Then
$sHeaderOrgText = $aHdrData[0][$iCol]
Else
$aColData = _GUICtrlListView_GetColumn($hLV_Handle, $iCol)
$sHeaderOrgText = $aColData[5]
EndIf
Local $aLocation[2] = [0, $iCol]
Local $aEdit_Coords = __GUIListViewEx_EditCoords($hLV_Handle, $cLV_CID, $aLocation, $tLVPos, $aLVClient[0] - 5, $iDelta_X, $iDelta_Y)
Local $hHeader = _GUICtrlListView_GetHeader($hLV_Handle)
Local $aHeader_Pos = WinGetPos($hHeader)
$aEdit_Coords[0] -= 2
$aEdit_Coords[1] -= $aHeader_Pos[3]
$aEdit_Coords[3] = $aHeader_Pos[3]
Local $hCombo, $hTemp_Edit, $hTemp_List, $hTemp_Combo, $sCombo_Data
If $aHdrData[2][$iCol] Then
$sCombo_Data = $aHdrData[2][$iCol]
If StringLeft($sCombo_Data, 1) = @TAB Then
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0x00200043)
$sCombo_Data = StringTrimLeft($sCombo_Data, 1)
Else
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0x00200042)
EndIf
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data)
$hCombo = GUICtrlGetHandle($cGLVEx_EditID)
Local $tInfo = DllStructCreate("dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" &  "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList")
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
_SendMessage($hCombo, 0x164, 0, $tInfo, 0, "wparam", "struct*")
$hTemp_Edit = DllStructGetData($tInfo, "hEdit")
$hTemp_List = DllStructGetData($tInfo, "hList")
$hTemp_Combo = DllStructGetData($tInfo, "hCombo")
Else
$cGLVEx_EditID = GUICtrlCreateEdit($sHeaderOrgText, $aEdit_Coords[0], $aEdit_Coords[1], $aEdit_Coords[2], $aEdit_Coords[3], 0)
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
EndIf
GUICtrlSetFont($cGLVEx_EditID, $aLV_FontDetails[0], Default, Default, $aLV_FontDetails[1])
_WinAPI_SetFocus($hTemp_Edit)
If Not $aGLVEx_Data[$iLV_Index][11] Then
GUICtrlSendMsg($cGLVEx_EditID, 0xB1, 0, -1)
EndIf
Local $tMouseClick = DllStructCreate($tagPOINT)
Local $aKeys[2] = [0x0D, 0x1B]
Local $iKey_Code = 0
Local $fCombo_State = False
Local $iOldESC = Opt("GUICloseOnESC", 0)
While 1
If $aGLVEx_Data[0][9] Then
$aGLVEx_Data[0][9] = False
ExitLoop
EndIf
For $i = 0 To 1
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
If _WinAPI_GetFocus() <> $hTemp_Edit Then
ExitLoop
EndIf
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
DllStructSetData($tMouseClick, "x", MouseGetPos(0))
DllStructSetData($tMouseClick, "y", MouseGetPos(1))
Switch _WinAPI_WindowFromPoint($tMouseClick)
Case $hTemp_Combo, $hTemp_Edit, $hTemp_List
Case Else
ExitLoop
EndSwitch
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
EndIf
If $hCombo Then
Switch _SendMessage($hCombo, 0x157)
Case 0
If $fCombo_State = True Then
If GUICtrlRead($cGLVEx_EditID) = "" Then
$fCombo_State = False
Else
$iKey_Code = 0x0D
ExitLoop
EndIf
EndIf
Case 1
If Not $fCombo_State Then
$fCombo_State = True
EndIf
EndSwitch
EndIf
Sleep(10)
WEnd
Switch $iKey_Code
Case 0x0D
Local $sHeaderNewText = GUICtrlRead($cGLVEx_EditID)
If $sHeaderNewText <> $sHeaderOrgText Then
If $aGLVEx_Data[$iLV_Index][24] Then
$aHdrData[0][$iCol] = $sHeaderNewText
Else
_GUICtrlListView_SetColumn($hLV_Handle, $iCol, $sHeaderNewText)
EndIf
$aGLVEx_Data[$iLV_Index][25] = $aHdrData
Local $aRet[1][3] = [[$iCol, $sHeaderOrgText, $sHeaderNewText]]
EndIf
Case Else
$aRet = ""
EndSwitch
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
Opt("GUICloseOnESC", $iOldESC)
GUICtrlDelete($cGLVEx_EditID)
WinSetState($hLV_Handle, "", @SW_ENABLE)
Return $aRet
EndFunc
Func _GUIListViewEx_LoadColour($iLV_Index, $aColArray)
Local $sColSet
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If Not $aGLVEx_Data[$iLV_Index][19] Then
Return SetError(2, 0, 0)
EndIf
If UBound($aColArray, 0) <> 2 Then
Return SetError(3, 0, 0)
EndIf
_ArrayInsert($aColArray, 0)
If (UBound($aColArray) <> UBound($aGLVEx_Data[$iLV_Index][2])) Or (UBound($aColArray, 2) <> UBound($aGLVEx_Data[$iLV_Index][2], 2)) Then
Return SetError(3, 1, 0)
EndIf
For $i = 1 To UBound($aColArray, 1) - 1
For $j = 0 To UBound($aColArray, 2) - 1
$sColSet = $aColArray[$i][$j]
If $sColSet = "" Then
$sColSet = ";"
$aColArray[$i][$j] = ";"
EndIf
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(4, 0, 0)
EndIf
$aColArray[$i][$j] = StringRegExpReplace($sColSet, "0x(.{2})(.{2})(.{2})", "0x$3$2$1")
Next
Next
$aGLVEx_Data[$iLV_Index][18] = $aColArray
Return 1
EndFunc
Func _GUIListViewEx_SetDefColours($iLV_Index, $aDefCols)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
If Not ($aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22]) Then Return SetError(2, 0, 0)
If Not IsArray($aDefCols) Or UBound($aDefCols) <> 5 Or UBound($aDefCols, 0) <> 1 Then Return SetError(3, 0, 0)
Local $aCurCols = $aGLVEx_Data[$iLV_Index][23]
Local $sCol
For $i = 0 To 3
If $aDefCols[$i] = Default Then
$aDefCols[$i] = $aGLVEx_DefColours[$i]
ElseIf $aDefCols[$i] = "" Then
$aDefCols[$i] = $aCurCols[$i]
Else
Switch Number($aDefCols[$i])
Case 0 To 0xFFFFFF
$sCol = '0x' & StringMid($aDefCols[$i], 7, 2) & StringMid($aDefCols[$i], 5, 2) & StringMid($aDefCols[$i], 3, 2)
$aDefCols[$i] = $sCol
Case Else
Return SetError(4, 0, 0)
EndSwitch
EndIf
Next
Switch $aDefCols[4]
Case Default
$aGLVEx_Data[$iLV_Index][26] = $aGLVEx_DefColours[1]
Case ""
Case 0 To 0xFFFFFF
$aGLVEx_Data[$iLV_Index][26] = $aDefCols[4]
Case Else
Return SetError(5, 0, 0)
EndSwitch
ReDim $aDefCols[4]
$aGLVEx_Data[$iLV_Index][23] = $aDefCols
__GUIListViewEx_RedrawWindow($iLV_Index, True)
Return 1
EndFunc
Func _GUIListViewEx_SetColour($iLV_Index, $sColSet, $iRow, $iCol)
_GUIListViewEx_SetActive($iLV_Index)
If @error Then
Return SetError(1, 0, 0)
EndIf
If Not $aGLVEx_Data[$iLV_Index][19] Then
Return SetError(2, 0, 0)
EndIf
If $sColSet = "" Then
$sColSet = ";"
EndIf
Local $fDefCol = (($sColSet = ";") ? (True) : (False))
If Not StringRegExp($sColSet, "^(\Q0x\E[0-9A-Fa-f]{6})?;(\Q0x\E[0-9A-Fa-f]{6})?$") Then
Return SetError(3, 0, 0)
EndIf
Local $aColArray = $aGLVEx_Data[$iLV_Index][18]
If $iRow < 0 Or $iCol < 0 Or $iRow > UBound($aColArray) - 2 Or $iCol > UBound($aColArray, 2) - 1 Then
Return SetError(4, 0, 0)
EndIf
Local $aCurrSplit = StringSplit($aColArray[$iRow + 1][$iCol], ";")
Local $aNewSplit = StringSplit($sColSet, ";")
For $i = 1 To 2
If $aNewSplit[$i] Then
$aCurrSplit[$i] = '0x' & StringMid($aNewSplit[$i], 7, 2) & StringMid($aNewSplit[$i], 5, 2) & StringMid($aNewSplit[$i], 3, 2)
EndIf
If $fDefCol Then
$aCurrSplit[$i] = ""
EndIf
Next
$aColArray[$iRow + 1][$iCol] = $aCurrSplit[1] & ";" & $aCurrSplit[2]
$aGLVEx_Data[$iLV_Index][18] = $aColArray
$aGLVEx_Data[0][14] = 0
_GUICtrlListView_RedrawItems($aGLVEx_Data[$iLV_Index][0], $iRow, $iRow)
Return 1
EndFunc
Func _GUIListViewEx_BlockReDraw($iLV_Index, $bMode)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
Switch $bMode
Case True
$aGLVEx_Data[0][15] = False
Case False
$aGLVEx_Data[0][15] = True
Local $aData_Array = $aGLVEx_Data[$iLV_Index][2]
Local $aCheck_Array[UBound($aData_Array)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
__GUIListViewEx_ReWriteLV($aGLVEx_Data[$iLV_Index][0], $aData_Array, $aCheck_Array, $iLV_Index, $aGLVEx_Data[$iLV_Index][6])
Case Else
Return SetError(2, 0, 0)
EndSwitch
Return 1
EndFunc
Func _GUIListViewEx_UserSort($iLV_Index, $vCol, $hFunc = -1)
If $iLV_Index < 1 Or $iLV_Index > $aGLVEx_Data[0][0] Then
Return SetError(1, 0, 0)
EndIf
If Not (IsArray($aGLVEx_Data[$iLV_Index][4])) Then
Return SetError(2, 0, 0)
EndIf
Local $aRange = __GUIListViewEx_ExpandRange($vCol, $iLV_Index)
If @error Then Return SetError(3, 0, 0)
If Not ($hFunc = -1) And Not (IsFunc($hFunc)) Then
Return SetError(4, 0, 0)
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
For $i = 1 To $aRange[0]
$aEditable[3][$aRange[$i]] = $hFunc
Next
$aGLVEx_Data[$iLV_Index][7] = $aEditable
Return 1
EndFunc
Func _GUIListViewEx_SelectItem($iRow, $iCol = -1)
Local $hLVHandle = $aGLVEx_Data[$aGLVEx_Data[0][1]][0]
Local $cLV_CID = $aGLVEx_Data[$aGLVEx_Data[0][1]][1]
$iRow = Int($iRow)
If $iRow < 0 Then Return SetError(1, 0, 0)
If $iRow > _GUICtrlListView_GetItemCount($hLVHandle) - 1 Then Return SetError(1, 0, 0)
If $iCol <> -1 Then
$iCol = int($iCol)
If $iCol < 0 Then Return SetError(2, 0, 0)
If $iCol > _GUICtrlListView_GetColumnCount($hLVHandle) - 1 Then Return SetError(2, 0, 0)
EndIf
_GUICtrlListView_SetItemSelected($hLVHandle, -1, False)
__GUIListViewEx_HighLight($hLVHandle, $cLV_CID, $iRow)
$aGLVEx_Data[0][2] = $iRow
$aGLVEx_Data[0][17] = $iRow
$aGLVEx_Data[0][18] = (($iCol = -1) ? (0) : ($iCol))
$aGLVEx_Data[$aGLVEx_Data[0][1]][20] = $iRow
$aGLVEx_Data[$aGLVEx_Data[0][1]][21] = (($iCol = -1) ? (0) : ($iCol))
Return 1
EndFunc
Func _GUIListViewEx_GetLastSelItem($iLV_Index = 0)
Switch $iLV_Index
Case 1 To $aGLVEx_Data[0][0]
Case 0, Default
$iLV_Index = _GUIListViewEx_GetActive()
If $iLV_Index = 0 Then Return SetError(1, 0, "")
Case Else
Return SetError(2, 0, "")
EndSwitch
Local $iRow = $aGLVEx_Data[$iLV_Index][20]
Local $iCol = $aGLVEx_Data[$iLV_Index][21]
If $iRow = -1 Or $iCol = -1 Then Return SetError(3, 0, "")
Return $iLV_Index & "|" & $iRow & "|" & $iCol
EndFunc
Func _GUIListViewEx_ContextPos()
If $aGLVEx_Data[0][10] = -1 Then
Return SetError(1, 0, "")
Else
Local $aPos[3] = [$aGLVEx_Data[0][1], $aGLVEx_Data[0][10], $aGLVEx_Data[0][11]]
Return $aPos
EndIf
EndFunc
Func _GUIListViewEx_ToolTipInit($iLV_Index, $vRange, $iTime = 1000, $iMode = 1)
If $iLV_Index < 0 Or $iLV_Index > $aGLVEx_Data[0][0] Then Return SetError(1, 0, 0)
Local $aRange = __GUIListViewEx_ExpandRange($vRange, $iLV_Index)
If @error Then Return SetError(2, 0, 0)
If Not IsInt($iTime) Then Return SetError(3, 0, 0)
$aGLVEx_Data[$iLV_Index][15] = $aRange
$aGLVEx_Data[$iLV_Index][16] = $iTime
$aGLVEx_Data[$iLV_Index][17] = $iMode
Return 1
EndFunc
Func _GUIListViewEx_EventMonitor($iEditMode = 0, $iDelta_X = 0, $iDelta_Y = 0)
Local $aRet, $vRet, $iLV_Index, $iError
If $fGLVEx_EditClickFlag <> 0 Then
$iLV_Index = $fGLVEx_EditClickFlag
$aGLVEx_Data[0][1] = $iLV_Index
$fGLVEx_EditClickFlag = 0
Switch Abs($iEditMode)
Case 0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33
Case Else
Return SetError(1, 0, "")
EndSwitch
Local $aLocation[2] = [$aGLVEx_Data[0][17], $aGLVEx_Data[0][18]]
If $aLocation[0] = -1 Then
Return SetError(2, 0, "")
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
If $aLocation[1] = -1 Then
For $i = 0 To UBound($aEditable, 2) - 1
If $aEditable[0][$i] <> 0 Then
$aLocation[1] = $i
$aGLVEx_Data[0][18] = $i
ExitLoop
EndIf
Next
EndIf
Switch $aEditable[0][$aLocation[1]]
Case 0
Return SetError(3, 0, "")
Case 9
Local $hUserFunction = $aEditable[1][$aLocation[1]]
$vRet = $hUserFunction($hGLVEx_SrcHandle, $iLV_Index, $aLocation[0], $aLocation[1])
Return SetError(@error, @extended, $vRet)
Case Else
$aRet = __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode)
$iError = @error
If IsArray($aRet) And $aRet[0][0] Then
Return SetError($iError, 1, $aRet)
Else
Return SetError($iError, 1, "")
EndIf
EndSwitch
EndIf
If $fGLVEx_HeaderEdit Then
$fGLVEx_HeaderEdit = False
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01) Or _WinAPI_GetAsyncKeyState(0x11)
Sleep(10)
WEnd
$aRet = _GUIListViewEx_EditHeader()
$iError = @error
If IsArray($aRet) Then
Return SetError($iError, 2, $aRet)
Else
Return SetError($iError, 2, "")
EndIf
EndIf
If $aGLVEx_Data[0][19] Then
$vRet = $aGLVEx_Data[0][19]
$aGLVEx_Data[0][19] = ""
If $aGLVEx_Data[0][22] = 1 Then
__GUIListViewEx_RedrawWindow($vRet, True)
$aGLVEx_Data[0][22] = 0
EndIf
Return SetError(0, 3, $vRet)
EndIf
If $sGLVEx_DragEvent Then
$vRet = $sGLVEx_DragEvent
$sGLVEx_DragEvent = ""
If $aGLVEx_Data[0][22] Then
Local $aIndex = StringSplit($vRet, ":")
__GUIListViewEx_RedrawWindow($aIndex[1], True)
If $aIndex[2] <> $aIndex[1] Then
__GUIListViewEx_RedrawWindow($aIndex[2], True)
EndIf
$aGLVEx_Data[0][22] = 0
EndIf
Return SetError(0, 4, $vRet)
EndIf
Local $iMode = $aGLVEx_Data[$aGLVEx_Data[0][1]][17]
If $iMode Then
$iLV_Index = $aGLVEx_Data[0][1]
Local $fToolTipCol = False
If $aGLVEx_Data[$iLV_Index][21] Then
$aGLVEx_Data[0][4] = $aGLVEx_Data[0][17]
$aGLVEx_Data[0][5] = $aGLVEx_Data[0][18]
EndIf
If $aGLVEx_Data[0][4] <> $aGLVEx_Data[0][6] Or $aGLVEx_Data[0][5] <> $aGLVEx_Data[0][7] Then
If $aGLVEx_Data[$iLV_Index][15] = "*" Then
$fToolTipCol = True
Else
If IsArray($aGLVEx_Data[$iLV_Index][15]) Then
Local $vRange = $aGLVEx_Data[$iLV_Index][15]
For $i = 1 To $vRange[0]
If $aGLVEx_Data[0][2] = $vRange[$i] Then
$fToolTipCol = True
ExitLoop
EndIf
Next
EndIf
EndIf
EndIf
If $fToolTipCol Then
Local $aItemText = _GUICtrlListView_GetItemTextArray($aGLVEx_Data[$iLV_Index][0], $aGLVEx_Data[0][4])
If Not @error Then
Local $sText
Switch $iMode
Case 1
$sText = $aItemText[$aGLVEx_Data[0][5] + 1]
Case 2
$sText = $aItemText[1]
EndSwitch
ToolTip($sText)
AdlibRegister("__GUIListViewEx_ToolTipHide", $aGLVEx_Data[$iLV_Index][16])
$aGLVEx_Data[0][6] = $aGLVEx_Data[0][4]
$aGLVEx_Data[0][7] = $aGLVEx_Data[0][5]
EndIf
EndIf
EndIf
If $fGLVEx_SelChangeFlag Then
Local $aRetArray[3] = [$fGLVEx_SelChangeFlag, $aGLVEx_Data[0][17], $aGLVEx_Data[0][18]]
$fGLVEx_SelChangeFlag = 0
If $fGLVEx_UserSelFlag Then
$fGLVEx_UserSelFlag = 0
Return SetError(0, 9, $aRetArray)
EndIf
EndIf
If $fGVLEx_Resized <> -1 Then
Local $iCol = $fGVLEx_Resized
$fGVLEx_Resized = -1
Return SetError(0, 5, $iCol)
EndIf
Return SetError(0, 0, "")
EndFunc
Func _GUIListViewEx_MsgRegister($fNOTIFY = True, $fMOUSEMOVE = True, $fLBUTTONUP = True, $fSYSCOMMAND = True)
If $fNOTIFY Then GUIRegisterMsg(0x004E, "_GUIListViewEx_WM_NOTIFY_Handler")
If $fMOUSEMOVE Then GUIRegisterMsg(0x0200, "_GUIListViewEx_WM_MOUSEMOVE_Handler")
If $fLBUTTONUP Then GUIRegisterMsg(0x0202, "_GUIListViewEx_WM_LBUTTONUP_Handler")
If $fSYSCOMMAND Then GUIRegisterMsg(0x0112, "_GUIListViewEx_WM_SYSCOMMAND_Handler")
EndFunc
Func _GUIListViewEx_WM_NOTIFY_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
Local $dwDrawStage, $iCol, $aHdrData
Local $tStruct = DllStructCreate($tagNMLISTVIEW, $lParam)
If @error Then Return
Local $hLV = DllStructGetData($tStruct, 1)
Local $iItem = DllStructGetData($tStruct, 4)
Local $iCode = BitAND(DllStructGetData($tStruct, 3), 0xFFFFFFFF)
If $iCode = -12 Then
If $aGLVEx_Data[0][12] Then Return
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$iLV_Index][0] = DllStructGetData($tStruct, 1) Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local Static $aDefCols = $aGLVEx_DefColours
If $aGLVEx_Data[0][14] <> DllStructGetData($tStruct, 1) Then
$aGLVEx_Data[0][14] = DllStructGetData($tStruct, 1)
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$aGLVEx_Data[0][13] = $aGLVEx_Data[$iLV_Index][18]
$aDefCols = $aGLVEx_Data[$iLV_Index][23]
EndIf
EndIf
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
Local $tNMLVCUSTOMDRAW = DllStructCreate($tagNMLVCUSTOMDRAW, $lParam)
$dwDrawStage = DllStructGetData($tNMLVCUSTOMDRAW, "dwDrawStage")
Switch $dwDrawStage
Case 1
Return 32
Case 65537
Return 32
Case 196609
$iItem = DllStructGetData($tNMLVCUSTOMDRAW, "dwItemSpec")
Local $iSubItem = DllStructGetData($tNMLVCUSTOMDRAW, "iSubItem")
Local $bSelColour = False
If $iItem = $aGLVEx_Data[$iLV_Index][20] Then
If $aGLVEx_Data[$iLV_Index][22] Then
If $iSubItem = $aGLVEx_Data[$iLV_Index][21] Then
$bSelColour = True
EndIf
Else
$bSelColour = True
EndIf
EndIf
Local $iTextColour = $aDefCols[0]
Local $iBackColour = $aDefCols[1]
If $bSelColour Then
$iTextColour = $aDefCols[2]
$iBackColour = $aDefCols[3]
Else
If $aGLVEx_Data[$iLV_Index][19] Then
If StringInStr(($aGLVEx_Data[0][13])[$iItem + 1][$iSubItem], ";") Then
Local $aSplitColour = StringSplit(($aGLVEx_Data[0][13])[$iItem + 1][$iSubItem], ";")
If $aSplitColour[1] Then $iTextColour = $aSplitColour[1]
If $aSplitColour[2] Then $iBackColour = $aSplitColour[2]
EndIf
EndIf
EndIf
DllStructSetData($tNMLVCUSTOMDRAW, "ClrText", $iTextColour)
DllStructSetData($tNMLVCUSTOMDRAW, "ClrTextBk", $iBackColour)
Return 2
EndSwitch
EndIf
Else
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If DllStructGetData($tStruct, 1) = $aGLVEx_Data[$iLV_Index][24] Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local $tNMCustomDraw = DllStructCreate($tagNMLVCUSTOMDRAW, $lParam)
Local $hDC = DllStructGetData($tNMCustomDraw, "hdc")
If $aGLVEx_Data[0][20] <> DllStructGetData($tStruct, 1) Then
$aGLVEx_Data[0][20] = DllStructGetData($tStruct, 1)
Local $hFont = _SendMessage(DllStructGetData($tStruct, 1), 0x0031)
Local $hObject = _WinAPI_SelectObject($hDC, $hFont)
Local $tLogFont = DllStructCreate($tagLOGFONT)
_WinAPI_GetObject($hFont, DllStructGetSize($tLogFont), DllStructGetPtr($tLogFont))
_WinAPI_SelectObject($hDC, $hObject)
_WinAPI_ReleaseDC(DllStructGetData($tStruct, 1), $hDC)
DllStructSetData($tLogFont, "Weight", 600)
$aGLVEx_Data[0][21] = _WinAPI_CreateFontIndirect($tLogFont)
EndIf
$dwDrawStage = DllStructGetData($tNMCustomDraw, "dwDrawStage")
Switch $dwDrawStage
Case 1
Return 32
Case 65537
Return 0x00000010
Case 0x00010002
Local $iColumnIndex = DllStructGetData($tNMCustomDraw, "dwItemSpec")
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
Local $aColSplit = StringSplit($aHdrData[1][$iColumnIndex], ";")
Local $aHdrDefCols = $aGLVEx_Data[$iLV_Index][23]
Local $iHdrTextColour, $iHdrBackColour
If $aColSplit[1] == "" Then
$iHdrTextColour = $aHdrDefCols[0]
Else
$iHdrTextColour = $aColSplit[1]
EndIf
If $aColSplit[2] == "" Then
$iHdrBackColour = $aHdrDefCols[1]
Else
$iHdrBackColour = $aColSplit[2]
EndIf
Local $tRECT = DllStructCreate($tagRECT)
DllStructSetData($tRECT, 1, DllStructGetData($tNMCustomDraw, 6) + 1)
DllStructSetData($tRECT, 2, DllStructGetData($tNMCustomDraw, 7) + 1)
DllStructSetData($tRECT, 3, DllStructGetData($tNMCustomDraw, 8) - 2)
DllStructSetData($tRECT, 4, DllStructGetData($tNMCustomDraw, 9) - 2)
_WinAPI_SetBkMode($hDC, 1)
_WinAPI_SelectObject($hDC, $aGLVEx_Data[0][21])
_WinAPI_SetTextColor($hDC, $iHdrTextColour)
Local $hBrush = _WinAPI_CreateSolidBrush($iHdrBackColour)
_WinAPI_FillRect($hDC, $tRECT, $hBrush)
If $iColumnIndex < _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0]) Then
Local $aRet = _GUICtrlListView_GetColumn($aGLVEx_Data[$iLV_Index][0], $iColumnIndex)
Local $iColAlign = 2 * $aRet[0]
_WinAPI_DrawText($hDC, $aHdrData[0][$iColumnIndex], $tRECT, $iColAlign)
EndIf
Return 2
EndSwitch
EndIf
EndIf
Else
Local $fEditHotKey = False
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$iLV_Index][0] = DllStructGetData($tStruct, 1) Then
ExitLoop
EndIf
Next
Local $iRow
If $iLV_Index <= $aGLVEx_Data[0][0] Then
If $iLV_Index <> $aGLVEx_Data[0][1] Then
$aGLVEx_Data[0][1] = $iLV_Index
$aGLVEx_Data[0][17] = $aGLVEx_Data[$iLV_Index][20]
$aGLVEx_Data[0][18] = $aGLVEx_Data[$iLV_Index][21]
EndIf
Switch $iCode
Case $LVN_BEGINSCROLL
If $cGLVEx_EditID <> 9999 Then
GUICtrlDelete($cGLVEx_EditID)
$cGLVEx_EditID = 9999
WinSetState($hGLVEx_Editing, "", @SW_ENABLE)
EndIf
Case $LVN_BEGINDRAG
If Not BitAND($aGLVEx_Data[$iLV_Index][12], 16) Then
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$iGLVEx_SrcIndex = $iLV_Index
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$hGLVEx_TgtHandle = $hGLVEx_SrcHandle
$cGLVEx_TgtID = $cGLVEx_SrcID
$iGLVEx_TgtIndex = $iGLVEx_SrcIndex
$aGLVEx_TgtArray = $aGLVEx_SrcArray
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $fImage = $aGLVEx_Data[$iLV_Index][5]
If $cGLVEx_SrcID Then
GUICtrlSetState($cGLVEx_SrcID, 256)
Else
_WinAPI_SetFocus($hGLVEx_SrcHandle)
EndIf
$iGLVEx_DraggedIndex = DllStructGetData($tStruct, 4)
$iGLVEx_Dragging = 1
Local $iIndex
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$iIndex = $aGLVEx_Data[$iLV_Index][20]
Else
$iIndex = _GUICtrlListView_GetSelectedIndices($hGLVEx_SrcHandle)
EndIf
If StringInStr($iIndex, $iGLVEx_DraggedIndex) And StringInStr($iIndex, "|") Then
Local $aIndex = StringSplit($iIndex, "|")
For $i = 1 To $aIndex[0]
If $aIndex[$i] = $iGLVEx_DraggedIndex Then ExitLoop
Next
If $i <> 1 Then
For $j = $i - 1 To 1 Step -1
If $aIndex[$j] <> $aIndex[$j + 1] - 1 Then ExitLoop
$iGLVEx_DraggedIndex -= 1
$iGLVEx_Dragging += 1
Next
EndIf
If $i <> $aIndex[0] Then
For $j = $i + 1 To $aIndex[0]
If $aIndex[$j] <> $aIndex[$j - 1] + 1 Then ExitLoop
$iGLVEx_Dragging += 1
Next
EndIf
Else
$iGLVEx_Dragging = 1
EndIf
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, -1, False)
If $fImage Then
Local $aImageData = _GUICtrlListView_CreateDragImage($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
$hGLVEx_DraggedImage = $aImageData[0]
_GUIImageList_BeginDrag($hGLVEx_DraggedImage, 0, 0, 0)
EndIf
EndIf
Case $LVN_COLUMNCLICK, -2
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$iRow = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][4] = $iRow
$aGLVEx_Data[0][17] = $iRow
$aGLVEx_Data[$iLV_Index][20] = $iRow
$iCol = DllStructGetData($tStruct, 5)
$aGLVEx_Data[0][2] = $iCol
$aGLVEx_Data[0][5] = $iCol
$aGLVEx_Data[0][18] = $iCol
$aGLVEx_Data[$iLV_Index][21] = $iCol
If $iCode = $LVN_COLUMNCLICK Then
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
Local $aRect = _GUICtrlListView_GetSubItemRect($hGLVEx_SrcHandle, 0, $iCol)
Local $aLV_Pos = WinGetPos($hGLVEx_SrcHandle)
If $aRect[0] < 0 Or $aRect[2] > $aLV_Pos[2] - $aGLVEx_Data[0][8] Then
_GUICtrlListView_Scroll($hGLVEx_SrcHandle, $aRect[0], 0)
EndIf
_WinAPI_GetAsyncKeyState(0x11)
If _WinAPI_GetAsyncKeyState(0x11) Then
If $aEditable[0][$iCol] Then
$fGLVEx_HeaderEdit = True
EndIf
Else
If IsArray($aGLVEx_Data[$iLV_Index][4]) Then
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
Local $aLVSortState = $aGLVEx_Data[$iLV_Index][4]
__GUIListViewEx_ColSort($hGLVEx_SrcHandle, $iLV_Index, $aLVSortState, $iCol, $aEditable[3][$iCol])
$aGLVEx_Data[$iLV_Index][4] = $aLVSortState
Local $iDim2 = UBound($aGLVEx_SrcArray, 2) - 1
For $j = 1 To $aGLVEx_SrcArray[0][0]
For $k = 0 To $iDim2
$aGLVEx_SrcArray[$j][$k] = _GUICtrlListView_GetItemText($hGLVEx_SrcHandle, $j - 1, $k)
Next
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aGLVEx_SrcArray = 0
EndIf
EndIf
Else
$fGLVEx_UserSelFlag = 1
EndIf
Case $LVN_KEYDOWN
Local $tKey = DllStructCreate($tagNMHDR & ";WORD KeyCode", $lParam)
$aGLVEx_Data[0][16] = DllStructGetData($tKey, "KeyCode")
If __GUIListViewEx_CheckUserEditKey() Then
$fEditHotKey = True
ContinueCase
EndIf
If $aGLVEx_Data[$iLV_Index][22] Then
_GUICtrlListView_SetItemSelected($hLV, $aGLVEx_Data[0][17], False)
Switch $aGLVEx_Data[0][16]
Case 37
If $aGLVEx_Data[0][18] > 0 Then $aGLVEx_Data[0][18] -= 1
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$fGLVEx_UserSelFlag = 1
$fGLVEx_SelChangeFlag = $iLV_Index
Case 39
If $aGLVEx_Data[0][18] < _GUICtrlListView_GetColumnCount($hLV) - 1 Then $aGLVEx_Data[0][18] += 1
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$fGLVEx_UserSelFlag = 1
$fGLVEx_SelChangeFlag = $iLV_Index
EndSwitch
EndIf
Case -3
$aGLVEx_Data[0][1] = $iLV_Index
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
If Not $fEditHotKey Then
$iRow = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][17] = $iRow
$aGLVEx_Data[$iLV_Index][20] = $iRow
$iCol = DllStructGetData($tStruct, 5)
$aGLVEx_Data[0][18] = $iCol
$aGLVEx_Data[$iLV_Index][21] = $iCol
EndIf
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$fGLVEx_EditClickFlag = $iLV_Index
Case $LVN_ITEMCHANGED
If $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
_GUICtrlListView_SetItemSelected($hLV, $iItem, False)
EndIf
If $aGLVEx_Data[0][16] <> 0 Then
Switch $aGLVEx_Data[0][16]
Case 38
If $aGLVEx_Data[0][17] > 0 Then $aGLVEx_Data[0][17] -= 1
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$fGLVEx_UserSelFlag = 1
Case 40
If $aGLVEx_Data[0][17] < _GUICtrlListView_GetItemCount($hLV) - 1 Then $aGLVEx_Data[0][17] += 1
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$fGLVEx_UserSelFlag = 1
EndSwitch
$aGLVEx_Data[0][16] = 0
Else
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
Local $aMPos = MouseGetPos()
Local $tPoint = DllStructCreate("int X;int Y")
DllStructSetData($tPoint, "X", $aMPos[0])
DllStructSetData($tPoint, "Y", $aMPos[1])
_WinAPI_ScreenToClient($hLV, $tPoint)
Local $aCurPos[2] = [DllStructGetData($tPoint, "X"), DllStructGetData($tPoint, "Y")]
Local $aHitTest = _GUICtrlListView_SubItemHitTest($hLV, $aCurPos[0], $aCurPos[1])
If $aHitTest[0] > -1 And $aHitTest[1] > -1 And $aHitTest[0] = $iItem Then
If $aGLVEx_Data[0][17] <> $iItem Then _GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$aGLVEx_Data[0][17] = $aHitTest[0]
$aGLVEx_Data[0][18] = $aHitTest[1]
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $iItem, $iItem)
EndIf
$fGLVEx_UserSelFlag = 1
EndIf
EndIf
$fGLVEx_SelChangeFlag = $iLV_Index
Case -5
$aGLVEx_Data[0][1] = $iLV_Index
$aGLVEx_Data[0][10] = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][11] = DllStructGetData($tStruct, 5)
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
$aGLVEx_Data[0][17] = DllStructGetData($tStruct, 4)
$aGLVEx_Data[0][18] = DllStructGetData($tStruct, 5)
$aGLVEx_Data[$iLV_Index][20] = $aGLVEx_Data[0][17]
$aGLVEx_Data[$iLV_Index][21] = $aGLVEx_Data[0][18]
_GUICtrlListView_RedrawItems($hLV, $aGLVEx_Data[0][17], $aGLVEx_Data[0][17])
EndSwitch
Else
For $iLV_Index = 1 To $aGLVEx_Data[0][0]
If DllStructGetData($tStruct, 1) = _GUICtrlListView_GetHeader($aGLVEx_Data[$iLV_Index][0]) Then
ExitLoop
EndIf
Next
If $iLV_Index <= $aGLVEx_Data[0][0] Then
Local $tNMHEADER = DllStructCreate($tagNMHEADER, $lParam)
$iCol = DllStructGetData($tNMHEADER, "Item")
Switch $iCol
Case 0 To _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0]) - 1
$aHdrData = $aGLVEx_Data[$iLV_Index][25]
If IsArray($aHdrData) And UBound($aHdrData, 2) Then
Local $iHdrResize = $aHdrData[3][$iCol]
Switch $iCode
Case -306, -326
If $iHdrResize Then
Return True
Else
Return False
EndIf
Case -305, -325
If $iHdrResize Then
_GUICtrlListView_SetColumnWidth($aGLVEx_Data[$iLV_Index][0], $iCol, $iHdrResize)
_WinAPI_RedrawWindow(DllStructGetData($tStruct, 1))
EndIf
Case -307, -327
$fGVLEx_Resized = $iCol
EndSwitch
EndIf
EndSwitch
EndIf
EndIf
EndIf
Return "GUI_RUNDEFMSG"
EndFunc
Func _GUIListViewEx_WM_MOUSEMOVE_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam
Local $iVertScroll
If $iGLVEx_Dragging = 0 Then
Return "GUI_RUNDEFMSG"
EndIf
If $aGLVEx_Data[$aGLVEx_Data[0][1]][10] Then
$iVertScroll = $aGLVEx_Data[$aGLVEx_Data[0][1]][10]
Else
Local $aRect = _GUICtrlListView_GetItemRect($hGLVEx_SrcHandle, 0)
$iVertScroll = $aRect[3] - $aRect[1]
EndIf
Local $hCurrent_Wnd = __GUIListViewEx_GetCursorWnd()
If $hCurrent_Wnd <> $hGLVEx_TgtHandle Then
If BitAND($aGLVEx_Data[$iGLVEx_TgtIndex][12], 1) Then
Return "GUI_RUNDEFMSG"
EndIf
For $i = 1 To $aGLVEx_Data[0][0]
If $aGLVEx_Data[$i][0] = $hCurrent_Wnd Then
If _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle) = _GUICtrlListView_GetColumnCount($hCurrent_Wnd) Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
$hGLVEx_TgtHandle = $hCurrent_Wnd
$cGLVEx_TgtID = $aGLVEx_Data[$i][1]
$iGLVEx_TgtIndex = $i
$aGLVEx_TgtArray = $aGLVEx_Data[$i][2]
$aGLVEx_Data[0][3] = $aGLVEx_Data[$i][10]
ExitLoop
EndIf
EndIf
Next
EndIf
Local $iCurr_Y = BitShift($lParam, 16)
If $iGLVEx_InsertIndex <> -1 Then
If $iGLVEx_LastY = $iCurr_Y Then
Return "GUI_RUNDEFMSG"
ElseIf $iGLVEx_LastY > $iCurr_Y Then
$fGLVEx_BarUnder = False
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iGLVEx_InsertIndex, False)
Else
$fGLVEx_BarUnder = True
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iGLVEx_InsertIndex, True)
EndIf
EndIf
$iGLVEx_LastY = $iCurr_Y
Local $aLVHit = _GUICtrlListView_HitTest($hGLVEx_TgtHandle)
Local $iCurr_Index = $aLVHit[0]
If $iCurr_Index = -1 Then
If $fGLVEx_BarUnder Then
_GUICtrlListView_Scroll($hGLVEx_TgtHandle, 0, $iVertScroll)
Else
_GUICtrlListView_Scroll($hGLVEx_TgtHandle, 0, -$iVertScroll)
EndIf
Sleep(10)
EndIf
If $iGLVEx_InsertIndex <> $iCurr_Index Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, $iCurr_Index, $fGLVEx_BarUnder)
$iGLVEx_InsertIndex = $iCurr_Index
EndIf
Return "GUI_RUNDEFMSG"
EndFunc
Func _GUIListViewEx_WM_LBUTTONUP_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $wParam, $lParam
If Not $iGLVEx_Dragging Then
Return "GUI_RUNDEFMSG"
EndIf
Local $iMultipleItems = $iGLVEx_Dragging - 1
$iGLVEx_Dragging = 0
If $iGLVEx_InsertIndex = -1 Then
$iGLVEx_InsertIndex = _GUICtrlListView_GetItemCount($hGLVEx_TgtHandle) - 1
EndIf
Local $hCurrent_Wnd = __GUIListViewEx_GetCursorWnd()
If $hCurrent_Wnd <> $hGLVEx_TgtHandle Then
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_DraggedIndex + $i)
Next
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
Return
EndIf
_GUICtrlListView_SetInsertMark($hGLVEx_TgtHandle, -1, True)
If $hGLVEx_DraggedImage Then
_GUIImageList_DragLeave($hGLVEx_SrcHandle)
_GUIImageList_EndDrag()
_GUIImageList_Destroy($hGLVEx_DraggedImage)
$hGLVEx_DraggedImage = 0
EndIf
If $hGLVEx_SrcHandle = $hGLVEx_TgtHandle Then
If BitAND($aGLVEx_Data[$iGLVEx_SrcIndex][12], 8) Then
Return "GUI_RUNDEFMSG"
EndIf
If $fGLVEx_BarUnder Then
If $iGLVEx_DraggedIndex > $iGLVEx_InsertIndex Then $iGLVEx_InsertIndex += 1
Else
If $iGLVEx_DraggedIndex < $iGLVEx_InsertIndex Then $iGLVEx_InsertIndex -= 1
EndIf
Switch $iGLVEx_InsertIndex
Case $iGLVEx_DraggedIndex To $iGLVEx_DraggedIndex + $iMultipleItems
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_DraggedIndex + $i)
Next
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
Return
EndSwitch
Local $aCheck_Array[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_Array) - 1
$aCheck_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $aCheckDrag_Array[$iMultipleItems + 1]
$aGLVEx_SrcColArray = $aGLVEx_Data[$iGLVEx_SrcIndex][18]
Local $bUserCol = ((IsArray($aGLVEx_SrcColArray)) ? (True) : (False))
If $iMultipleItems Then
Local $aInsertData[$iMultipleItems + 1]
Local $aColData[$iMultipleItems + 1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To $iMultipleItems
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aInsertData[$i] = $aItemData
If $bUserCol Then
For $j = 0 To UBound($aGLVEx_SrcColArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aColData[$i] = $aItemData
EndIf
$aCheckDrag_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex + $i)
Next
Else
Local $aInsertData[1]
Local $aColData[1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aInsertData[0] = $aItemData
If $bUserCol Then
For $i = 0 To UBound($aGLVEx_SrcColArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aColData[0] = $aItemData
EndIf
$aCheckDrag_Array[0] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
EndIf
$aGLVEx_Data[0][12] = True
For $i = 0 To $iMultipleItems
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $iGLVEx_DraggedIndex + 1)
__GUIListViewEx_Array_Delete($aCheck_Array, $iGLVEx_DraggedIndex + 1)
If $bUserCol Then __GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $iGLVEx_DraggedIndex + 1)
Next
If $iGLVEx_DraggedIndex < $iGLVEx_InsertIndex Then
$iGLVEx_InsertIndex -= $iMultipleItems
EndIf
For $i = $iMultipleItems To 0 Step -1
__GUIListViewEx_Array_Insert($aGLVEx_SrcArray, $iGLVEx_InsertIndex + 1, $aInsertData[$i])
__GUIListViewEx_Array_Insert($aCheck_Array, $iGLVEx_InsertIndex + 1, $aCheckDrag_Array[$i])
If $bUserCol Then __GUIListViewEx_Array_Insert($aGLVEx_SrcColArray, $iGLVEx_InsertIndex + 1, $aColData[$i], False, False)
Next
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_Array, $iGLVEx_SrcIndex)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_SrcHandle, $cGLVEx_SrcID, $iGLVEx_InsertIndex + $i)
Next
$aGLVEx_Data[$aGLVEx_Data[0][1]][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iGLVEx_SrcIndex][18] = $aGLVEx_SrcColArray
Else
If BitAND($aGLVEx_Data[$iGLVEx_TgtIndex][12], 2) Then
Return "GUI_RUNDEFMSG"
EndIf
Local $bCheckbox = (($aGLVEx_Data[$iGLVEx_SrcIndex][6] And $aGLVEx_Data[$iGLVEx_TgtIndex][6]) ? (True) : (False))
If $fGLVEx_BarUnder Then
$iGLVEx_InsertIndex += 1
EndIf
$aGLVEx_SrcColArray = $aGLVEx_Data[$iGLVEx_SrcIndex][18]
Local $bUserColSrc = ((IsArray($aGLVEx_SrcColArray)) ? (True) : (False))
$aGLVEx_TgtColArray = $aGLVEx_Data[$iGLVEx_TgtIndex][18]
Local $bUserColTgt = ((IsArray($aGLVEx_TgtColArray)) ? (True) : (False))
Local $aCheck_SrcArray[UBound($aGLVEx_SrcArray)]
For $i = 1 To UBound($aCheck_SrcArray) - 1
$aCheck_SrcArray[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $i - 1)
Next
Local $aCheck_TgtArray[UBound($aGLVEx_TgtArray)]
For $i = 1 To UBound($aCheck_TgtArray) - 1
$aCheck_TgtArray[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_TgtHandle, $i - 1)
Next
Local $aCheckDrag_Array[$iMultipleItems + 1]
If $iMultipleItems Then
Local $aInsertData[$iMultipleItems + 1]
Local $aColData[$iMultipleItems + 1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To $iMultipleItems
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$j] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Next
$aInsertData[$i] = $aItemData
If $bUserColTgt Then
For $j = 0 To UBound($aGLVEx_SrcArray, 2) - 1
If $bUserColSrc Then
$aItemData[$j] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1 + $i][$j]
Else
$aItemData[$j] = ";"
EndIf
Next
$aColData[$i] = $aItemData
EndIf
$aCheckDrag_Array[$i] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex + $i)
Next
Else
Local $aInsertData[1]
Local $aColData[1]
Local $aItemData[UBound($aGLVEx_SrcArray, 2)]
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
$aItemData[$i] = $aGLVEx_SrcArray[$iGLVEx_DraggedIndex + 1][$i]
Next
$aInsertData[0] = $aItemData
If $bUserColTgt Then
For $i = 0 To UBound($aGLVEx_SrcArray, 2) - 1
If $bUserColSrc Then
$aItemData[$i] = $aGLVEx_SrcColArray[$iGLVEx_DraggedIndex + 1][$i]
Else
$aItemData[$i] = ";"
EndIf
Next
$aColData[0] = $aItemData
EndIf
$aCheckDrag_Array[0] = _GUICtrlListView_GetItemChecked($hGLVEx_SrcHandle, $iGLVEx_DraggedIndex)
EndIf
$aGLVEx_Data[0][12] = True
If Not BitAND($aGLVEx_Data[$iGLVEx_SrcIndex][12], 4) Then
For $i = 0 To $iMultipleItems
__GUIListViewEx_Array_Delete($aGLVEx_SrcArray, $iGLVEx_DraggedIndex + 1)
__GUIListViewEx_Array_Delete($aCheck_SrcArray, $iGLVEx_DraggedIndex + 1, $aCheckDrag_Array[$i])
If $bUserColSrc Then __GUIListViewEx_Array_Delete($aGLVEx_SrcColArray, $iGLVEx_DraggedIndex + 1)
Next
EndIf
If $iGLVEx_InsertIndex < 0 Then
$iGLVEx_InsertIndex = _GUICtrlListView_GetItemCount($hGLVEx_TgtHandle)
EndIf
For $i = $iMultipleItems To 0 Step -1
__GUIListViewEx_Array_Insert($aGLVEx_TgtArray, $iGLVEx_InsertIndex + 1, $aInsertData[$i])
__GUIListViewEx_Array_Insert($aCheck_TgtArray, $iGLVEx_InsertIndex + 1, $aCheckDrag_Array[$i])
If $bUserColTgt Then __GUIListViewEx_Array_Insert($aGLVEx_TgtColArray, $iGLVEx_InsertIndex + 1, $aColData[$i], False, False)
Next
__GUIListViewEx_ReWriteLV($hGLVEx_SrcHandle, $aGLVEx_SrcArray, $aCheck_SrcArray, $iGLVEx_SrcIndex, $bCheckbox)
__GUIListViewEx_ReWriteLV($hGLVEx_TgtHandle, $aGLVEx_TgtArray, $aCheck_TgtArray, $iGLVEx_TgtIndex, $bCheckbox)
_GUIListViewEx_SetActive($iGLVEx_TgtIndex)
For $i = 0 To $iMultipleItems
__GUIListViewEx_HighLight($hGLVEx_TgtHandle, $cGLVEx_TgtID, $iGLVEx_InsertIndex + $i)
Next
$aGLVEx_Data[$iGLVEx_SrcIndex][2] = $aGLVEx_SrcArray
$aGLVEx_Data[$iGLVEx_SrcIndex][18] = $aGLVEx_SrcColArray
$aGLVEx_Data[$iGLVEx_TgtIndex][2] = $aGLVEx_TgtArray
$aGLVEx_Data[$iGLVEx_TgtIndex][18] = $aGLVEx_TgtColArray
EndIf
$aGLVEx_SrcArray = 0
$aGLVEx_TgtArray = 0
$aGLVEx_SrcColArray = 0
$aGLVEx_TgtColArray = 0
$sGLVEx_DragEvent = $iGLVEx_SrcIndex & ":" & $iGLVEx_TgtIndex
$aGLVEx_Data[0][22] = 1
$aGLVEx_Data[0][12] = False
__GUIListViewEx_RedrawWindow($iGLVEx_SrcIndex)
If $hGLVEx_TgtHandle <> $hGLVEx_SrcHandle Then
__GUIListViewEx_RedrawWindow($iGLVEx_TgtIndex)
EndIf
EndFunc
Func _GUIListViewEx_WM_SYSCOMMAND_Handler($hWnd, $iMsg, $wParam, $lParam)
#forceref $hWnd, $iMsg, $lParam, $lParam
If $hWnd = _WinAPI_GetParent($hGLVEx_SrcHandle) And $wParam = 0xF060 Then
$aGLVEx_Data[0][9] = True
EndIf
EndFunc
Func __GUIListViewEx_ExpandRange($vRange, $iLV_Index, $iMode = 1)
If StringRegExp($vRange, "[^*0-9-;]") <> 0 Then
Return SetError(1, 0, 0)
EndIf
Local $iCount
If $iMode = 1 Then
$iCount = _GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])
Else
$iCount = _GUICtrlListView_GetItemCount($aGLVEx_Data[$iLV_Index][0])
EndIf
Local $aRet[$iCount + 1]
$vRange = StringStripWS($vRange, 8)
If $vRange = "*" Then
$aRet[0] = $iCount
For $i = 1 To $iCount
$aRet[$i] = $i - 1
Next
Else
If StringInStr($vRange, "-") Then
Local $aSplit_1, $aSplit_2, $iNumber
$aSplit_1 = StringSplit($vRange, ";")
$vRange = ""
For $i = 1 To $aSplit_1[0]
$aSplit_2 = StringSplit($aSplit_1[$i], "-")
$vRange &= $aSplit_2[1] & ";"
If ($aSplit_2[0]) > 1 Then
If (Number($aSplit_2[2]) > Number($aSplit_2[1])) Then
$iNumber = $aSplit_2[1]
Do
$iNumber += 1
$vRange &= $iNumber & ";"
Until $iNumber = $aSplit_2[2]
Else
Return SetError(1, 0, 0)
EndIf
EndIf
Next
EndIf
Local $aSplit = StringSplit($vRange, ";")
For $i = 1 To $aSplit[0]
If $aSplit[$i] Then
$aRet[0] += 1
$aRet[$aRet[0]] = $aSplit[$i]
EndIf
Next
ReDim $aRet[$aRet[0] + 1]
EndIf
Return $aRet
EndFunc
Func __GUIListViewEx_HighLight($hLVHandle, $cLV_CID, $iIndexA, $iIndexB = -1)
If $cLV_CID Then
GUICtrlSetState($cLV_CID, 256)
Else
_WinAPI_SetFocus($hLVHandle)
EndIf
If $iIndexB <> -1 Then _GUICtrlListView_SetItemSelected($hLVHandle, $iIndexB, False)
_GUICtrlListView_SetItemState($hLVHandle, $iIndexA, $LVIS_SELECTED, $LVIS_SELECTED)
_GUICtrlListView_EnsureVisible($hLVHandle, $iIndexA)
EndFunc
Func __GUIListViewEx_GetLVFont($hLVHandle)
Local $iError = 0, $aFontDetails[2] = [Default, Default]
If Not IsHWnd($hLVHandle) Then
$hLVHandle = GUICtrlGetHandle($hLVHandle)
EndIf
If Not IsHWnd($hLVHandle) Then
$iError = 1
Else
Local $hFont = _SendMessage($hLVHandle, 0x0031)
If Not $hFont Then
$iError = 2
Else
Local $hDC = _WinAPI_GetDC($hLVHandle)
Local $hObjOrg = _WinAPI_SelectObject($hDC, $hFont)
Local $tFONT = DllStructCreate($tagLOGFONT)
Local $aRet = DllCall('gdi32.dll', 'int', 'GetObjectW', 'ptr', $hFont, 'int', DllStructGetSize($tFONT), 'ptr', DllStructGetPtr($tFONT))
If @error Or $aRet[0] = 0 Then
$iError = 3
Else
$aFontDetails[0] = Round((-1 * DllStructGetData($tFONT, 'Height')) * 72 / _WinAPI_GetDeviceCaps($hDC, 90), 1)
$aRet = DllCall("gdi32.dll", "int", "GetTextFaceW", "handle", $hDC, "int", 0, "ptr", 0)
Local $iCount = $aRet[0]
Local $tBuffer = DllStructCreate("wchar[" & $iCount & "]")
Local $pBuffer = DllStructGetPtr($tBuffer)
$aRet = DllCall("Gdi32.dll", "int", "GetTextFaceW", "handle", $hDC, "int", $iCount, "ptr", $pBuffer)
If @error Then
$iError = 4
Else
$aFontDetails[1] = DllStructGetData($tBuffer, 1)
EndIf
EndIf
_WinAPI_SelectObject($hDC, $hObjOrg)
_WinAPI_ReleaseDC($hLVHandle, $hDC)
EndIf
EndIf
Return SetError($iError, 0, $aFontDetails)
EndFunc
Func __GUIListViewEx_EditProcess($iLV_Index, $aLocation, $iDelta_X, $iDelta_Y, $iEditMode, $iForce = False)
Local $hTemp_Combo = 9999, $hTemp_Edit = 9999, $hTemp_List = 9999, $iKey_Code, $fCombo_State, $aSplit, $sInsert
Local $iEditType, $fEdit, $fCombo, $fRead_Only, $fAuto_Drop, $fDTP, $fClick_Move = False, $cUpDown, $hUpDown
Local $hPrevCurrGUI = GUISwitch(_WinAPI_GetParent($hGLVEx_SrcHandle))
_GUICtrlListView_SetItemSelected($hGLVEx_SrcHandle, $aLocation[0], False)
Local $aEdited[1][4] = [[0]]
$hGLVEx_SrcHandle = $aGLVEx_Data[$iLV_Index][0]
$cGLVEx_SrcID = $aGLVEx_Data[$iLV_Index][1]
$hGLVEx_Editing = $hGLVEx_SrcHandle
Local $cEditingID = $cGLVEx_SrcID
Local $aKeys[7] = [0x09, 0x0D, 0x1B, 0x25, 0x27, 0x26, 0x28]
Local $fReset_Edits = False
If $iEditMode < 0 Then
$fReset_Edits = True
$iEditMode = Abs($iEditMode)
EndIf
Local $iEditRow = 0, $iEditCol = 0
If $iEditMode Then
$aSplit = StringSplit(StringFormat("%02s", $iEditMode), "")
$iEditRow = $aSplit[1]
$iEditCol = $aSplit[2]
EndIf
Local $aEditable = $aGLVEx_Data[$iLV_Index][7]
If $aGLVEx_Data[$iLV_Index][9] Then
$fClick_Move = True
EndIf
Local $tLVPos = DllStructCreate("struct;long X;long Y;endstruct")
__GUIListViewEx_GetLVCoords($hGLVEx_Editing, $tLVPos)
Local $aLVClient = WinGetClientSize($hGLVEx_Editing)
Local $aLV_FontDetails = __GUIListViewEx_GetLVFont($hGLVEx_Editing)
WinSetState($hGLVEx_Editing, "", @SW_DISABLE)
Local $aWidth = ($aGLVEx_Data[$iLV_Index][14])
If Not IsArray($aWidth) Then Local $aWidth[_GUICtrlListView_GetColumnCount($aGLVEx_Data[$iLV_Index][0])]
Local $iWidth, $fExitLoop, $tMouseClick = DllStructCreate($tagPOINT)
Local $iOldMouseOpt = Opt("MouseCoordMode", 1)
Local $iOldESC = Opt("GUICloseOnESC", 0)
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
While 1
$fEdit = False
$fCombo = False
$fRead_Only = False
$fAuto_Drop = False
$fDTP = False
$iEditType = $aEditable[0][$aLocation[1]]
Switch $iEditType
Case 0, 1
$fEdit = True
If $iForce Then
$iEditType = 1
EndIf
Case 2
$fCombo = True
Local $sCombo_Data = $aEditable[1][$aLocation[1]]
$fRead_Only = (BitAND($aEditable[2][$aLocation[1]], 1) = 1)
$fAuto_Drop = (BitAND($aEditable[2][$aLocation[1]], 2) = 2)
Case 3
$fDTP = True
Local $sDTP_Default = $aEditable[1][$aLocation[1]]
If StringRight($sDTP_Default, 1) = "#" Then
$sDTP_Default = StringTrimRight($sDTP_Default, 1)
$fAuto_Drop = True
EndIf
If $sDTP_Default = Default Then
$sDTP_Default = @YEAR & "/" & @MON & "/" & @MDAY
EndIf
Local $sDTP_Format = $aEditable[2][$aLocation[1]]
If $sDTP_Format = Default Then
$sDTP_Format = ""
EndIf
EndSwitch
Local $sItemOrgText = _GUICtrlListView_GetItemText($hGLVEx_Editing, $aLocation[0], $aLocation[1])
Local $aEdit_Pos = __GUIListViewEx_EditCoords($hGLVEx_Editing, $cEditingID, $aLocation, $tLVPos, $aLVClient[0] - 5, $iDelta_X, $iDelta_Y)
$iWidth = Number($aWidth[$aLocation[1]])
If $iWidth > $aEdit_Pos[2] Then
If $fRead_Only Then
If $iWidth < 0 Then
$aEdit_Pos[2] = Abs($iWidth)
EndIf
Else
$aEdit_Pos[2] = Abs($iWidth)
EndIf
EndIf
Switch $iEditType
Case 1
$cGLVEx_EditID = GUICtrlCreateInput($sItemOrgText, $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 128)
If $aGLVEx_Data[$iLV_Index][19] Then
GUICtrlSetBkColor($cGLVEx_EditID, $aGLVEx_Data[$iLV_Index][26])
EndIf
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
If $aEditable[1][$aLocation[1]] = 1 Then
Local $iWrap = -1
If $aEditable[2][$aLocation[1]] Then
$aSplit = StringSplit($aEditable[2][$aLocation[1]], "|")
If UBound($aSplit) = 4 Then
$iWrap = (($aSplit[3] = 1) ? (0x05) : (-1))
EndIf
EndIf
$cUpDown = GUICtrlCreateUpdown($cGLVEx_EditID, $iWrap)
$hUpDown = GUICtrlGetHandle($cUpDown)
If UBound($aSplit) = 4 Then
GUICtrlSetLimit($cUpDown, $aSplit[2], $aSplit[1])
EndIf
_WinAPI_RedrawWindow($hUpDown)
EndIf
Case 2
If $fRead_Only Then
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 0x00200043)
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data, $sItemOrgText)
Else
$cGLVEx_EditID = GUICtrlCreateCombo("", $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3], 0x00200042)
GUICtrlSetData($cGLVEx_EditID, $sCombo_Data)
EndIf
Local $tInfo = DllStructCreate("dword Size;struct;long EditLeft;long EditTop;long EditRight;long EditBottom;endstruct;" &  "struct;long BtnLeft;long BtnTop;long BtnRight;long BtnBottom;endstruct;dword BtnState;hwnd hCombo;hwnd hEdit;hwnd hList")
Local $iInfo = DllStructGetSize($tInfo)
DllStructSetData($tInfo, "Size", $iInfo)
Local $hCombo = GUICtrlGetHandle($cGLVEx_EditID)
If $fRead_Only And Abs($iWidth) > $aEdit_Pos[2] Then
_SendMessage($hCombo, 0x160, Abs($iWidth))
EndIf
_SendMessage($hCombo, 0x164, 0, $tInfo, 0, "wparam", "struct*")
$hTemp_Edit = DllStructGetData($tInfo, "hEdit")
$hTemp_List = DllStructGetData($tInfo, "hList")
$hTemp_Combo = DllStructGetData($tInfo, "hCombo")
Case 3
$cGLVEx_EditID = GUICtrlCreateDate($sDTP_Default, $aEdit_Pos[0], $aEdit_Pos[1], $aEdit_Pos[2], $aEdit_Pos[3])
$hTemp_Edit = GUICtrlGetHandle($cGLVEx_EditID)
If $sDTP_Format Then
GUICtrlSendMsg($cGLVEx_EditID, 0x1032, 0, $sDTP_Format)
EndIf
EndSwitch
GUICtrlSetFont($cGLVEx_EditID, $aLV_FontDetails[0], Default, Default, $aLV_FontDetails[1])
_WinAPI_SetFocus($hTemp_Edit)
If Not $aGLVEx_Data[$iLV_Index][11] Then
GUICtrlSendMsg($cGLVEx_EditID, 0xB1, 0, -1)
EndIf
If $fAuto_Drop Then
Switch $iEditType
Case 2
_SendMessage($hCombo, 0x14F, True)
Case 3
_SendMessage($hTemp_Edit, 0x0201, 1, $aEdit_Pos[2] - 10)
EndSwitch
EndIf
$aGLVEx_SrcArray = $aGLVEx_Data[$iLV_Index][2]
$iKey_Code = 0
$fCombo_State = (($fAuto_Drop) ? (True) : (False))
While 1
$fExitLoop = False
If $aGLVEx_Data[0][9] Then
$fExitLoop = True
$aGLVEx_Data[0][9] = False
EndIf
_WinAPI_GetAsyncKeyState(0x01)
If _WinAPI_GetAsyncKeyState(0x01) Then
DllStructSetData($tMouseClick, "x", MouseGetPos(0))
DllStructSetData($tMouseClick, "y", MouseGetPos(1))
Switch _WinAPI_WindowFromPoint($tMouseClick)
Case $hTemp_Combo, $hTemp_Edit, $hTemp_List, $hUpDown
Case Else
If Not $fDTP Then
$fExitLoop = True
EndIf
EndSwitch
_WinAPI_GetAsyncKeyState(0x01)
While _WinAPI_GetAsyncKeyState(0x01)
Sleep(10)
WEnd
EndIf
If $fExitLoop Then
If $fEdit Then
If $fClick_Move Then
$iKey_Code = 0x02
Else
$iKey_Code = 0x01
EndIf
EndIf
ExitLoop
EndIf
If $fCombo Then
Switch _SendMessage($hCombo, 0x157)
Case 0
If $fCombo_State = True Then
If GUICtrlRead($cGLVEx_EditID) = "" Then
$fCombo_State = False
Else
$iKey_Code = 0x0D
ExitLoop
EndIf
EndIf
Case 1
If Not $fCombo_State Then
$fCombo_State = True
EndIf
EndSwitch
EndIf
For $i = 0 To 2
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
For $i = 3 To 6
_WinAPI_GetAsyncKeyState($aKeys[$i])
If _WinAPI_GetAsyncKeyState($aKeys[$i]) And _WinAPI_GetAsyncKeyState(0x11) Then
$iKey_Code = $aKeys[$i]
ExitLoop 2
EndIf
Next
If _WinAPI_GetFocus() <> $hTemp_Edit Then
ExitLoop
EndIf
Sleep(10)
WEnd
Switch $iKey_Code
Case 0x25, 0x26, 0x27, 0x28
If $fEdit Then
ContinueCase
EndIf
Case 0x02, 0x09, 0x0D
Local $sItemNewText = GUICtrlRead($cGLVEx_EditID)
If $sItemNewText <> $sItemOrgText Then
_GUICtrlListView_SetItemText($hGLVEx_Editing, $aLocation[0], $sItemNewText, $aLocation[1])
$aGLVEx_SrcArray[$aLocation[0] + 1][$aLocation[1]] = $sItemNewText
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
$aEdited[0][0] += 1
ReDim $aEdited[$aEdited[0][0] + 1][4]
$aEdited[$aEdited[0][0]][0] = $aLocation[0]
$aEdited[$aEdited[0][0]][1] = $aLocation[1]
$aEdited[$aEdited[0][0]][2] = $sItemOrgText
$aEdited[$aEdited[0][0]][3] = $sItemNewText
EndIf
EndSwitch
GUICtrlDelete($cGLVEx_EditID)
GUICtrlDelete($cUpDown)
$cGLVEx_EditID = 9999
Opt("MouseCoordMode", $iOldMouseOpt)
If $iEditMode = 0 Then
ExitLoop
Else
Switch $iKey_Code
Case 0x02
$iKey_Code = 0x01
ContinueCase
Case 0x00, 0x01, 0x0D
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
ExitLoop
Case 0x1B
If $fReset_Edits Then
For $i = $aEdited[0][0] To 1 Step -1
_GUICtrlListView_SetItemText($hGLVEx_Editing, $aEdited[$i][0], $aEdited[$i][2], $aEdited[$i][1])
Switch UBound($aGLVEx_SrcArray, 0)
Case 1
$aSplit = StringSplit($aGLVEx_SrcArray[$aEdited[$i][0] + 1], $aGLVEx_Data[0][24])
$aSplit[$aEdited[$i][1] + 1] = $aEdited[$i][2]
$sInsert = ""
For $j = 1 To $aSplit[0]
$sInsert &= $aSplit[$j] & $aGLVEx_Data[0][24]
Next
$aGLVEx_SrcArray[$aEdited[$i][0] + 1] = StringTrimRight($sInsert, 1)
Case 2
$aGLVEx_SrcArray[$aEdited[$i][0] + 1][$aEdited[$i][1]] = $aEdited[$i][2]
EndSwitch
Next
$aGLVEx_Data[$iLV_Index][2] = $aGLVEx_SrcArray
Local $aEdited[1][4] = [[0]]
EndIf
_WinAPI_GetAsyncKeyState(0x1B)
While _WinAPI_GetAsyncKeyState(0x1B)
Sleep(10)
WEnd
ExitLoop
Case 0x09, 0x27
While 1
If $iEditCol <> 0 Then
$aLocation[1] += 1
If $aLocation[1] = _GUICtrlListView_GetColumnCount($hGLVEx_Editing) Then
Switch $iEditCol
Case 1
ExitLoop 2
Case 2
$aLocation[1] -= 1
ExitLoop
Case 3
$aLocation[1] = 0
EndSwitch
EndIf
If $aEditable[0][$aLocation[1]] <> 0 Then
ExitLoop
Else
ExitLoop 2
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x25
While 1
If $iEditCol <> 0 Then
$aLocation[1] -= 1
If $aLocation[1] < 0 Then
Switch $iEditCol
Case 1
ExitLoop 2
Case 2
$aLocation[1] += 1
ExitLoop
Case 3
$aLocation[1] = _GUICtrlListView_GetColumnCount($hGLVEx_Editing) - 1
EndSwitch
EndIf
If $aEditable[0][$aLocation[1]] <> 0 Then
ExitLoop
Else
ExitLoop 2
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x28
While 1
If $iEditRow <> 0 Then
$aLocation[0] += 1
If $aLocation[0] = _GUICtrlListView_GetItemCount($hGLVEx_Editing) Then
Switch $iEditRow
Case 1
ExitLoop 2
Case 2
$aLocation[0] -= 1
ExitLoop
Case 3
$aLocation[0] = -1
EndSwitch
Else
ExitLoop
EndIf
Else
ExitLoop 2
EndIf
WEnd
Case 0x26
While 1
If $iEditRow <> 0 Then
$aLocation[0] -= 1
If $aLocation[0] < 0 Then
Switch $iEditRow
Case 1
ExitLoop 2
Case 2
$aLocation[0] += 1
ExitLoop
Case 3
$aLocation[0] = _GUICtrlListView_GetItemCount($hGLVEx_Editing)
EndSwitch
Else
ExitLoop
EndIf
Else
ExitLoop 2
EndIf
WEnd
EndSwitch
_WinAPI_GetAsyncKeyState($iKey_Code)
While _WinAPI_GetAsyncKeyState($iKey_Code)
Sleep(10)
WEnd
EndIf
WEnd
$aGLVEx_SrcArray = 0
WinSetState($hGLVEx_Editing, "", @SW_ENABLE)
_GUICtrlListView_SetItemState($hGLVEx_Editing, $aLocation[0], $LVIS_SELECTED, $LVIS_SELECTED)
SetExtended($iKey_Code)
Opt("GUICloseOnESC", $iOldESC)
GUISwitch($hPrevCurrGUI)
_WinAPI_SetFocus($hGLVEx_Editing)
Return $aEdited
EndFunc
Func __GUIListViewEx_EditCoords($hLV_Handle, $cLV_CID, $aLocation, $tLVPos, $iLVWidth, $iDelta_X, $iDelta_Y)
Local $aEdit_Data[4]
_GUICtrlListView_EnsureVisible($hLV_Handle, $aLocation[0])
Local $aRect = _GUICtrlListView_GetSubItemRect($hLV_Handle, $aLocation[0], $aLocation[1])
$aEdit_Data[3] = $aRect[3] - $aRect[1] + 1
$aEdit_Data[2] = _GUICtrlListView_GetColumnWidth($hLV_Handle, $aLocation[1])
If $aRect[0] < 0 Or $aRect[2] > $iLVWidth Then
_GUICtrlListView_Scroll($hLV_Handle, $aRect[0], 0)
$aRect = _GUICtrlListView_GetSubItemRect($hLV_Handle, $aLocation[0], $aLocation[1])
If $aRect[0] + $aEdit_Data[2] > $iLVWidth Then
$aEdit_Data[2] = $iLVWidth - $aRect[0]
EndIf
EndIf
If $cLV_CID Then
$iDelta_Y += 1
EndIf
$aEdit_Data[0] = DllStructGetData($tLVPos, "X") + $aRect[0] + $iDelta_X + 2
$aEdit_Data[1] = DllStructGetData($tLVPos, "Y") + $aRect[1] + $iDelta_Y
Return $aEdit_Data
EndFunc
Func __GUIListViewEx_ReWriteLV($hLVHandle, ByRef $aLV_Array, ByRef $aCheck_Array, $iLV_Index, $fCheckBox = True, $fRetainWidth = True)
Local $iVertScroll, $iColCount
Local $iLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $aGLVEx_Data[$iLV_Index][10] Then
$iVertScroll = $aGLVEx_Data[$iLV_Index][10]
Else
Local $aRect = _GUICtrlListView_GetItemRect($hLVHandle, 0)
$aGLVEx_Data[$iLV_Index][10] = $aRect[3] - $aRect[1]
If $iVertScroll = 0 Then
$iVertScroll = 20
EndIf
EndIf
Local $iTopIndex_Org = _GUICtrlListView_GetTopIndex($hLVHandle)
If $fRetainWidth And $iLV_CID Then
$iColCount = _GUICtrlListView_GetColumnCount($hGLVEx_SrcHandle)
Local $aCol_Width[$iColCount]
For $i = 1 To $iColCount - 1
$aCol_Width[$i] = _GUICtrlListView_GetColumnWidth($hGLVEx_SrcHandle, $i)
Next
EndIf
_GUICtrlListView_BeginUpdate($hLVHandle)
_GUICtrlListView_DeleteAllItems($hLVHandle)
If UBound($aLV_Array, 2) Then
Local $aArray = $aLV_Array
_ArrayDelete($aArray, 0)
Local $cLV_CID = $aGLVEx_Data[$iLV_Index][1]
If $cLV_CID Then
Local $sLine, $iLastCol = UBound($aArray, 2) - 1
For $i = 0 To UBound($aArray) - 1
$sLine = ""
For $j = 0 To $iLastCol
$sLine &= $aArray[$i][$j] & $aGLVEx_Data[0][24]
Next
GUICtrlCreateListViewItem(StringTrimRight($sLine, 1), $cLV_CID)
Next
Else
_GUICtrlListView_AddArray($hLVHandle, $aArray)
EndIf
For $i = 1 To $aLV_Array[0][0]
If $fCheckBox And $aCheck_Array[$i] Then
_GUICtrlListView_SetItemChecked($hLVHandle, $i - 1)
EndIf
Next
Local $iTopIndex_Curr = _GUICtrlListView_GetTopIndex($hLVHandle)
While $iTopIndex_Curr < $iTopIndex_Org
_GUICtrlListView_Scroll($hLVHandle, 0, $iVertScroll)
If _GUICtrlListView_GetTopIndex($hLVHandle) = $iTopIndex_Curr Then
ExitLoop
Else
$iTopIndex_Curr = _GUICtrlListView_GetTopIndex($hLVHandle)
EndIf
WEnd
EndIf
If $fRetainWidth And $iLV_CID Then
For $i = 1 To $iColCount - 1
$aCol_Width[$i] = _GUICtrlListView_SetColumnWidth($hGLVEx_SrcHandle, $i, $aCol_Width[$i])
Next
EndIf
_GUICtrlListView_EndUpdate($hLVHandle)
EndFunc
Func __GUIListViewEx_GetLVCoords($hLV_Handle, ByRef $tLVPos)
Local $aWnd = DllCall("user32.dll", "hwnd", "GetParent", "hwnd", $hLV_Handle)
Local $hWnd = $aWnd[0]
Local $aLVPos = WinGetPos($hLV_Handle)
DllStructSetData($tLVPos, "X", $aLVPos[0])
DllStructSetData($tLVPos, "Y", $aLVPos[1])
_WinAPI_ScreenToClient($hWnd, $tLVPos)
EndFunc
Func __GUIListViewEx_GetCursorWnd()
Local $iOldMouseOpt = Opt("MouseCoordMode", 1)
Local $tMPos = DllStructCreate("struct;long X;long Y;endstruct")
DllStructSetData($tMPos, "X", MouseGetPos(0))
DllStructSetData($tMPos, "Y", MouseGetPos(1))
Opt("MouseCoordMode", $iOldMouseOpt)
Return _WinAPI_WindowFromPoint($tMPos)
EndFunc
Func __GUIListViewEx_Array_Add(ByRef $avArray, $vAdd, $fMultiRow = False, $bCount = True)
Local $iIndex_Max = UBound($avArray)
Local $iAdd_Dim
Switch UBound($avArray, 0)
Case 1
If UBound($vAdd, 0) = 2 Or $fMultiRow Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim]
Else
ReDim $avArray[$iIndex_Max + 1]
EndIf
Case 2
Local $iDim2 = UBound($avArray, 2)
If UBound($vAdd, 0) = 2 Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim][$iDim2]
$avArray[0][0] += $iAdd_Dim
Local $iAdd_Max = UBound($vAdd, 2)
For $i = 0 To $iAdd_Dim - 1
For $j = 0 To $iDim2 - 1
If $j > $iAdd_Max - 1 Then
$avArray[$iIndex_Max + $i][$j] = ""
Else
$avArray[$iIndex_Max + $i][$j] = $vAdd[$i][$j]
EndIf
Next
Next
ElseIf $fMultiRow Then
$iAdd_Dim = UBound($vAdd, 1)
ReDim $avArray[$iIndex_Max + $iAdd_Dim][$iDim2]
$avArray[0][0] += $iAdd_Dim
For $i = 0 To $iAdd_Dim - 1
$avArray[$iIndex_Max + $i][0] = $vAdd[$i]
Next
Else
ReDim $avArray[$iIndex_Max + 1][$iDim2]
If $bCount Then
$avArray[0][0] += 1
EndIf
If IsArray($vAdd) Then
Local $vAdd_Max = UBound($vAdd)
For $j = 0 To $iDim2 - 1
If $j > $vAdd_Max - 1 Then
$avArray[$iIndex_Max][$j] = ""
Else
$avArray[$iIndex_Max][$j] = $vAdd[$j]
EndIf
Next
Else
For $j = 0 To $iDim2 - 1
$avArray[$iIndex_Max][$j] = $vAdd
Next
EndIf
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Insert(ByRef $avArray, $iIndex, $vInsert, $fMultiRow = False, $bCount = True)
Local $iIndex_Max = UBound($avArray)
Local $iInsert_Dim = UBound($vInsert, 1)
Switch UBound($avArray, 0)
Case 1
If UBound($vInsert, 0) = 2 Or $fMultiRow Then
ReDim $avArray[$iIndex_Max + $iInsert_Dim]
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + 1 Step -1
$avArray[$i] = $avArray[$i - 1]
Next
Else
ReDim $avArray[$iIndex_Max + 1]
For $i = $iIndex_Max To $iIndex + 1 Step -1
$avArray[$i] = $avArray[$i - 1]
Next
$avArray[$iIndex] = $vInsert
EndIf
Case 2
If $iIndex > $iIndex_Max - 1 Then
__GUIListViewEx_Array_Add($avArray, $vInsert, $fMultiRow, $bCount)
Return
EndIf
Local $iDim2 = UBound($avArray, 2)
If UBound($vInsert, 0) = 2 Then
$iInsert_Dim = UBound($vInsert, 1)
ReDim $avArray[$iIndex_Max + $iInsert_Dim][$iDim2]
If $bCount Then
$avArray[0][0] += $iInsert_Dim
EndIf
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + $iInsert_Dim Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - $iInsert_Dim][$j]
Next
Next
Local $iInsert_Max = UBound($vInsert, 2)
For $i = 0 To $iInsert_Dim - 1
For $j = 0 To $iDim2 - 1
If $j > $iInsert_Max - 1 Then
$avArray[$iIndex + $i][$j] = ""
Else
$avArray[$iIndex + $i][$j] = $vInsert[$i][$j]
EndIf
Next
Next
ElseIf $fMultiRow Then
$iInsert_Dim = UBound($vInsert, 1)
ReDim $avArray[$iIndex_Max + $iInsert_Dim][$iDim2]
$avArray[0][0] += $iInsert_Dim
For $i = $iIndex_Max + $iInsert_Dim - 1 To $iIndex + $iInsert_Dim Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - $iInsert_Dim][$j]
Next
Next
For $i = 0 To $iInsert_Dim - 1
$avArray[$iIndex + $i][0] = $vInsert[$i]
Next
Else
ReDim $avArray[$iIndex_Max + 1][$iDim2]
$avArray[0][0] += 1
For $i = $iIndex_Max To $iIndex + 1 Step -1
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i - 1][$j]
Next
Next
If IsArray($vInsert) Then
Local $vInsert_Max = UBound($vInsert)
For $j = 0 To $iDim2 - 1
If $j > $vInsert_Max - 1 Then
$avArray[$iIndex][$j] = ""
Else
$avArray[$iIndex][$j] = $vInsert[$j]
EndIf
Next
Else
For $j = 0 To $iDim2 - 1
$avArray[$iIndex][$j] = $vInsert
Next
EndIf
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Delete(ByRef $avArray, $iIndex, $bDelCount = False)
Local $iIndex_Max = UBound($avArray)
If $iIndex_Max = 0 Then Return
If Not $bDelCount Then
If $iIndex = 0 Then $iIndex = 1
EndIf
Switch UBound($avArray, 0)
Case 1
For $i = $iIndex To $iIndex_Max - 2
$avArray[$i] = $avArray[$i + 1]
Next
ReDim $avArray[$iIndex_Max - 1]
Case 2
Local $iDim2 = UBound($avArray, 2)
For $i = $iIndex To $iIndex_Max - 2
For $j = 0 To $iDim2 - 1
$avArray[$i][$j] = $avArray[$i + 1][$j]
Next
Next
ReDim $avArray[$iIndex_Max - 1][$iDim2]
If Not $bDelCount Then
$avArray[0][0] -= 1
EndIf
EndSwitch
EndFunc
Func __GUIListViewEx_Array_Swap(ByRef $avArray, $iIndex1, $iIndex2)
Local $vTemp
Switch UBound($avArray, 0)
Case 1
$vTemp = $avArray[$iIndex1]
$avArray[$iIndex1] = $avArray[$iIndex2]
$avArray[$iIndex2] = $vTemp
Case 2
Local $iDim2 = UBound($avArray, 2)
For $i = 0 To $iDim2 - 1
$vTemp = $avArray[$iIndex1][$i]
$avArray[$iIndex1][$i] = $avArray[$iIndex2][$i]
$avArray[$iIndex2][$i] = $vTemp
Next
EndSwitch
Return 0
EndFunc
Func __GUIListViewEx_ToolTipHide()
AdlibUnRegister("__GUIListViewEx_ToolTipHide")
ToolTip("")
EndFunc
Func __GUIListViewEx_MakeString($aArray)
If Not IsArray($aArray) Then Return SetError(1, 0, "")
Local $sRet = ""
Local $sDelim_Col = @CR
Local $sDelim_Row = @LF
Switch UBound($aArray, $UBOUND_DIMENSIONS)
Case 1
For $i = 0 To UBound($aArray, $UBOUND_ROWS) - 1
$sRet &= $aArray[$i] & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Col))
Case 2
For $i = 0 To UBound($aArray, $UBOUND_ROWS) - 1
For $j = 0 To UBound($aArray, $UBOUND_COLUMNS) - 1
$sRet &= $aArray[$i][$j] & $sDelim_Col
Next
$sRet = StringTrimRight($sRet, StringLen($sDelim_Col)) & $sDelim_Row
Next
Return StringTrimRight($sRet, StringLen($sDelim_Row))
Case Else
Return SetError(2, 0, "")
EndSwitch
EndFunc
Func __GUIListViewEx_MakeArray($sString)
If $sString = "" Then Return SetError(1, 0, "")
Local $aRetArray, $aRows, $aItems
Local $sRowDelimiter = @LF
Local $sColDelimiter = @CR
If StringInStr($sString, $sColDelimiter) Then
$aRows = StringSplit($sString, $sRowDelimiter)
StringReplace($aRows[1], $sColDelimiter, "")
Local $aRetArray[$aRows[0]][@extended + 1]
For $i = 1 To $aRows[0]
$aItems = StringSplit($aRows[$i], $sColDelimiter)
For $j = 1 To $aItems[0]
$aRetArray[$i - 1][$j - 1] = $aItems[$j]
Next
Next
Else
$aRetArray = StringSplit($sString, $sRowDelimiter, $STR_NOCOUNT)
EndIf
Return $aRetArray
EndFunc
Func __GUIListViewEx_ColSort($hLV, $iLV_Index, ByRef $vSortSense, $iCol, $hUserSortFunction = 0, $bToggleSense = True)
Local $aListViewContent = $aGLVEx_Data[$iLV_Index][2]
Local $aColourSettings = $aGLVEx_Data[$iLV_Index][18]
Local $iItemCount = $aListViewContent[0][0]
If $iItemCount Then
Local $iDescending = 0
If UBound($vSortSense) Then
$iDescending = $vSortSense[$iCol]
Else
$iDescending = $vSortSense
EndIf
Local $iColumnCount = UBound($aListViewContent, 2)
Local $fColourEnabled = ((IsArray($aGLVEx_Data[$iLV_Index][18])) ? (True) : (False))
If $fColourEnabled Then
ReDim $aListViewContent[UBound($aListViewContent)][($iColumnCount * 2) + 2]
For $i = 1 To $iItemCount
For $j = 0 To $iColumnCount - 1
$aListViewContent[$i][$iColumnCount + $j + 2] = $aColourSettings[$i][$j]
Next
Next
Else
ReDim $aListViewContent[UBound($aListViewContent)][$iColumnCount + 2]
EndIf
Local Enum $iIndexValue = $iColumnCount, $iItemParam
Local $sSelectedItems = _GUICtrlListView_GetSelectedIndices($hLV)
Local $aSelectedItems
If $sSelectedItems = "" Then
Local $aSelectedItems[2] = [1, $aGLVEx_Data[0][17]]
Else
$aSelectedItems = StringSplit($sSelectedItems, Opt('GUIDataSeparatorChar'))
EndIf
Local $aCheckedItems[$iItemCount + 1] = [0]
For $i = 0 To $iItemCount - 1
If _GUICtrlListView_GetItemChecked($hLV, $i) Then
$aCheckedItems[0] += 1
$aCheckedItems[$aCheckedItems[0]] = $i
EndIf
Next
ReDim $aCheckedItems[$aCheckedItems[0] + 1]
Local $iFocused = -1
For $i = 0 To $iItemCount - 1
If $iFocused = -1 Then
If _GUICtrlListView_GetItemFocused($hLV, $i) Then $iFocused = $i
EndIf
_GUICtrlListView_SetItemSelected($hLV, $i, False)
_GUICtrlListView_SetItemChecked($hLV, $i, False)
$aListViewContent[$i + 1][$iIndexValue] = $i
$aListViewContent[$i + 1][$iItemParam] = _GUICtrlListView_GetItemParam($hLV, $i)
Next
If IsFunc($hUserSortFunction) Then
$hUserSortFunction($aListViewContent, $iDescending, 1, 0, $iCol)
ElseIf $hUserSortFunction = -1 Then
Else
_ArraySort($aListViewContent, $iDescending, 1, 0, $iCol)
EndIf
For $i = 1 To $iItemCount
For $j = 0 To $iColumnCount - 1
_GUICtrlListView_SetItemText($hLV, $i - 1, $aListViewContent[$i][$j], $j)
If $fColourEnabled Then
$aColourSettings[$i][$j] = $aListViewContent[$i][$iColumnCount + $j + 2]
EndIf
Next
_GUICtrlListView_SetItemParam($hLV, $i - 1, $aListViewContent[$i][$iItemParam])
For $j = 1 To $aSelectedItems[0]
If $aListViewContent[$i][$iIndexValue] = $aSelectedItems[$j] Then
$aGLVEx_Data[0][17] = $i - 1
$aGLVEx_Data[$iLV_Index][20] = $i - 1
If Not ($aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22]) Then
If $aListViewContent[$i - 1][$iIndexValue] = $iFocused Then
_GUICtrlListView_SetItemSelected($hLV, $i - 1, True, True)
Else
_GUICtrlListView_SetItemSelected($hLV, $i - 1, True)
EndIf
ExitLoop
EndIf
EndIf
Next
For $j = 1 To $aCheckedItems[0]
If $aListViewContent[$i][$iIndexValue] = $aCheckedItems[$j] Then
_GUICtrlListView_SetItemChecked($hLV, $i - 1, True)
ExitLoop
EndIf
Next
Next
If $bToggleSense Then
If UBound($vSortSense) Then
$vSortSense[$iCol] = Not $iDescending
Else
$vSortSense = Not $iDescending
EndIf
EndIf
ReDim $aListViewContent[UBound($aListViewContent)][$iColumnCount]
$aGLVEx_Data[$iLV_Index][2] = $aListViewContent
$aGLVEx_Data[$iLV_Index][18] = $aColourSettings
$aGLVEx_Data[0][19] = $iLV_Index
$aGLVEx_Data[0][22] = 1
EndIf
EndFunc
Func __GUIListViewEx_RedrawWindow($iLV_Index, $fForce = False)
If $fForce Or $aGLVEx_Data[$iLV_Index][19] Or $aGLVEx_Data[$iLV_Index][22] Then
$aGLVEx_Data[0][14] = 0
If $aGLVEx_Data[0][15] Then
_WinAPI_RedrawWindow($aGLVEx_Data[$iLV_Index][0])
EndIf
EndIf
EndFunc
Func __GUIListViewEx_CheckUserEditKey()
Local $aKey = StringSplit($aGLVEx_Data[0][23], ";"), $iKeyValue
Local $fCheck = True
For $i = 1 To $aKey[0]
$iKeyValue = Dec($aKey[$i])
If Not _WinAPI_GetAsyncKeyState($iKeyValue) Then
$fCheck = False
ExitLoop
EndIf
Next
Return $fCheck
EndFunc
Global $customList
Func CustomList($sCategory, ByRef $aCategory)
TraySetClick(0)
Local $guiCustom = GUICreate("Customize " & $sCategory,1060,1126,-1,-1,-1,-1)
GUISetIcon("helper2.ico")
GUICtrlCreateLabel("Customize the list of " & $sCategory &  ". This is like bookmarks or favorites for Stash. You paste the link from the address bar, then put a title for it, as the examples you see below."  &@crlf&"To edit the list, double-click on the item, type or paste the text then press enter.",80,50,882,196,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
$customList = GUICtrlCreatelistview("#|  Title|  Query Link",40,270,972,696,  BitOR($LVS_NOSCROLL, $LVS_SINGLESEL),  BitOR($LVS_EX_FULLROWSELECT, $LVS_EX_GRIDLINES, $LVS_EX_DOUBLEBUFFER))
GUICtrlSetFont(-1,10,400,0,"Tahoma")
_GUICtrlListView_SetColumnWidth($customList, 0, 50)
_GUICtrlListView_SetColumnWidth($customList, 1, 300)
_GUICtrlListView_SetColumnWidth($customList, 2, 700)
Local $btnSave = GUICtrlCreateButton("Save",773,993,238,47,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Save the list and apply the changes.")
local $btnDelete = GUICtrlCreateButton("Delete",47,993,238,47,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Delete the highlighted row.")
Local $aList[$iMaxSubItems]
For $i = 0 to $iMaxSubItems -1
$aList[$i] = String($i + 1)
Next
For $i = 0 to UBound($aCategory) -1
$aList[$i] &= "|" & $aCategory[$i][$ITEM_TITLE] & "|" & $aCategory[$i][$ITEM_LINK]
Next
For $i = 0 to $iMaxSubItems -1
_GUICtrlListView_AddItem($customList, $i + 1)
Next
For $i = 0 to UBound($aCategory) -1
_GUICtrlListView_AddSubItem($customList, $i, $aCategory[$i][$ITEM_TITLE], 1)
_GUICtrlListView_AddSubItem($customList, $i, $aCategory[$i][$ITEM_LINK], 2)
Next
GUISetState(@SW_SHOW, $guiCustom)
Local $iLV_Index = _GUIListViewEx_Init($customList, $aList, 0, 0, True, 2)
_GUIListViewEx_SetEditStatus($iLV_Index, "1;2", 1, Default)
_GUIListViewEx_MsgRegister(True, False, False)
While True
Local $nTrayMsg = TrayGetMsg()
Switch $nTrayMsg
Case $TRAY_EVENT_PRIMARYDOWN, $TRAY_EVENT_SECONDARYDOWN
WinActivate($guiCustom)
EndSwitch
Local $nMsg = GUIGetMsg()
Switch $nMsg
Case 0
Case $customList
Case $btnSave
Local $aRead =  _GUIListViewEx_ReturnArray($iLV_Index)
Local $str = $aRead[0]
For $i = 1 to $iMaxSubItems-1
$str &= "@@@" & $aRead[$i]
Next
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", $sCategory & "List", "REG_SZ", $str)
ReloadMenu($sCategory)
ExitLoop
Case $btnDelete
If _GUICtrlListView_GetSelectedCount($customList) = 0 Then
MsgBox(0, "No item is selected", "Please select a row first.")
ContinueLoop
EndIf
_GUIListViewEx_SetActive($iLV_Index)
_GUIListViewEx_Delete()
_GUIListViewEx_InsertSpec($iLV_Index, -1, "")
_GUICtrlListView_SetItemSelected ($customList, $iMaxSubItems-1, False )
For $i = 0 to $iMaxSubItems -1
_GUICtrlListView_SetItemText($customList, $i, $i + 1)
Next
Case $GUI_EVENT_CLOSE
ExitLoop
EndSwitch
_GUIListViewEx_EventMonitor()
Wend
_GUIListViewEx_Close($iLV_Index)
GUIDelete($guiCustom)
$customList = 0
TraySetClick(9)
EndFunc
Global $sScraperPath, $aScraperArray[0], $aScraperFiles[0]
Local $sScraperBaseURL = "https://raw.githubusercontent.com/stashapp/CommunityScrapers/master/scrapers/"
Func ScrapersManager()
$sScraperPath = GetScraperPath()
Local $aItemID[0][0]
Local $iCurrentSearchIndex = 0
If @error Then Return
SetScraperArray()
If @error Then Return
TraySetClick(0)
Global $guiScrapers = GUICreate("Scrapers Management",1700,1030,-1,-1,$WS_SIZEBOX,-1)
GUISetIcon("helper2.ico")
Global $scraperList = GUICtrlCreatelistview("Website|Scraper|Scene|Gallery|Movie|Performers|Installed|ExtraReq|Contents",40,290,1620,680,-1,BitOr($LVS_EX_FULLROWSELECT,$LVS_EX_GRIDLINES,$LVS_EX_CHECKBOXES,$LVS_EX_DOUBLEBUFFER,$WS_EX_CLIENTEDGE))
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetResizing(-1,102)
_GUICtrlListView_SetColumnWidth($scraperList, 0, 400)
_GUICtrlListView_SetColumnWidth($scraperList, 1, 400)
_GUICtrlListView_SetColumnWidth($scraperList, 2, 100)
_GUICtrlListView_JustifyColumn($scraperList, 2, 2)
_GUICtrlListView_SetColumnWidth($scraperList, 3, 100)
_GUICtrlListView_JustifyColumn($scraperList, 3, 2)
_GUICtrlListView_SetColumnWidth($scraperList, 4, 100)
_GUICtrlListView_JustifyColumn($scraperList, 4, 2)
_GUICtrlListView_SetColumnWidth($scraperList, 5, 130)
_GUICtrlListView_JustifyColumn($scraperList, 5, 2)
_GUICtrlListView_SetColumnWidth($scraperList, 6, 130)
_GUICtrlListView_JustifyColumn($scraperList, 6, 2)
_GUICtrlListView_JustifyColumn($scraperList, 7, 2)
_GUICtrlListView_JustifyColumn($scraperList, 8, 2)
GUICtrlCreateLabel("Scrapers can fetch information about your scenes, studios, performers, tags...etc. With scrapers, you don't need to type in the information manually any more."&@crlf&" * For performers, you can fetch the info by her/his name."&@crlf&" * For scenes, you put in the URL for that scene, and the scraper can get all the details, including performers, tags, front cover... for that scene."&@crlf&"Therefore, managing scrapers are important for Stash. You don't want too many scrapers, yet you need them to categorize and label your videos quickly.",54,30,1597,205,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
GUICtrlSetResizing(-1,38)
Local $btnInstall = GUICtrlCreateButton("Install",1065,212,167,49,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Install the scrapers with check marks.")
GUICtrlSetResizing(-1,804)
Local $btnRemove = GUICtrlCreateButton("Remove",1298,212,167,49,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Remove the scrapers with check marks.")
GUICtrlSetResizing(-1,804)
GUISetState(@SW_SHOW, $guiScrapers)
Local $inputFind = GUICtrlCreateInput("",42,218,570,35,-1,$WS_EX_CLIENTEDGE)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetResizing(-1,550)
Local $btnFind = GUICtrlCreateButton("Find",640,220,148,33,-1,-1)
GUICtrlSetFont(-1,10,400,0,"Tahoma")
GUICtrlSetResizing(-1,804)
Local $btnUpdate = GUICtrlCreateButton("Update",1494,212,167,49,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Update the installed scrapers.")
GUICtrlSetResizing(-1,804)
ReDim $aItemID[UBound($aScraperArray)][2]
For $i = 0 to UBound($aScraperArray) -1
$aItemID[$i][0] = GUICtrlCreateListViewItem($aScraperArray[$i], $scraperList)
$aItemID[$i][1] = False
Next
Local $aFiles[0]
While True
Local $nTrayMsg = TrayGetMsg()
Switch $nTrayMsg
Case $TRAY_EVENT_PRIMARYDOWN, $TRAY_EVENT_SECONDARYDOWN
WinActivate($guiScrapers)
EndSwitch
Local $nMsg = GUIGetMsg()
Switch $nMsg
Case 0
Case $inputFind, $btnFind
Local $sText = GUICtrlRead($inputFind)
Local $iFound = _GUICtrlListView_FindInText($scraperList, $sText, $iCurrentSearchIndex, False )
If $iFound = -1 Then
$iCurrentSearchIndex = 0
MsgBox(48,"Not found","Search reach the end and Cannot find your search of " & $sText,0)
Else
$iCurrentSearchIndex = $iFound
_GUICtrlListView_EnsureVisible($scraperList, $iFound )
_GUICtrlListView_SetItemSelected($scraperList, $iFound)
GUICtrlSetState($scraperList, $GUI_FOCUS)
EndIf
Case $btnInstall
Local $iCount = _GUICtrlListView_GetItemCount($scraperList)
Local $iTotalInstalled = 0
ReDim $aFiles[0]
For $i = 0 To $iCount -1
If _GUICtrlListView_GetItemChecked($scraperList, $i) Then
Local $sScraperFile = _GUICtrlListView_GetItemText($scraperList, $i, 1)
If _ArraySearch($aFiles, $sScraperFile) = -1 Then
$i = UBound($aFiles)
ReDim $aFiles[$i + 1]
$aFiles[$i] = $sScraperFile
EndIf
_GUICtrlListView_SetItemChecked($scraperList, $i, False)
_GUICtrlListView_SetItemText($scraperList, $i, "Yes", 6)
EndIf
Next
For $i = 0 To UBound($aFiles) -1
FetchScraper($aFiles[$i])
If @error Then
MsgBox(48,"Error downloading file","Sorry, cannot download this file from GitHub:" & $sScraperFile,0)
Else
$iTotalInstalled += 1
EndIf
Next
If $iTotalInstalled > 0 Then
ReloadScrapers()
MsgBox(64,$iTotalInstalled & " Scrapers Installed",$iTotalInstalled & " Scrapers are now installed and working. If not, please go to Settings->Scraping->Reload scrapers.",20)
EndIf
Case $btnRemove
$iCount = _GUICtrlListView_GetItemCount($scraperList)
Local $iTotalRemoved = 0
ReDim $aFiles[0]
For $i = 0 To $iCount -1
If _GUICtrlListView_GetItemChecked($scraperList, $i) Then
$sScraperFile = _GUICtrlListView_GetItemText($scraperList, $i, 1)
If _ArraySearch($aFiles, $sScraperFile) = -1 Then
$i = UBound($aFiles)
ReDim $aFiles[$i + 1]
$aFiles[$i] = $sScraperFile
EndIf
_GUICtrlListView_SetItemChecked($scraperList, $i, False)
_GUICtrlListView_SetItemText($scraperList, $i, "No", 6)
EndIf
Next
For $i = 0 To UBound($aFiles)-1
FileDelete($sScraperPath & $sScraperFile)
Local $sPyFile = Stringleft($sScraperFile, stringinstr($sScraperFile, ".", 2, -1) -1) & ".py"
If FileExists($sScraperPath & $sPyFile) Then
FileDelete($sScraperPath & $sPyFile)
EndIf
$iTotalRemoved += 1
Next
If $iTotalRemoved > 0 Then
ReloadScrapers()
MsgBox(64,$iTotalRemoved & " Scrapers removed",$iTotalRemoved & " Scrapers are now removed.",20)
EndIf
Case $btnUpdate
UpdateScrapers()
Case $GUI_EVENT_CLOSE
ExitLoop
Case Else
For $i = 0 to UBound($aItemID)-1
If $nMsg = $aItemID[$i][0] Then
$iCurrentSearchIndex = $i
Local $bItemChecked = _GUICtrlListView_GetItemChecked($scraperList, $i)
If $bItemChecked <> $aItemID[$i][1] Then
$aItemID[$i][1] = $bItemChecked
Local $sYMLfile = StringStripWS( _GUICtrlListView_GetItemText($scraperList, $i, 1), 3)
For $j = 0 To UBound($aScraperArray) -1
Local $aStr = StringSplit($aScraperArray[$j], "|")
If StringStripWS($aStr[2], 3) = $sYMLfile Then
_GUICtrlListView_SetItemChecked($scraperList, $j, $bItemChecked)
$aItemID[$j][1] = $bItemChecked
EndIf
Next
EndIf
ExitLoop
EndIf
Next
EndSwitch
Wend
GUIDelete($guiScrapers)
TraySetClick(9)
EndFunc
Func UpdateScrapers()
Local $iTotalUpdated = 0
Local $aScraperFiles = _FileListToArray($sScraperPath, "*.yml", $FLTA_FILES)
For $i = 1 to UBound($aScraperFiles)-1
Local $sLocalFile = FileRead($sScraperPath & $aScraperFiles[$i])
Local $sLastLine = StringMid( $sLocalFile, StringInStr($sLocalFile, "# Last Updated", 2, -1) )
$sLastLine = StringStripWS($sLastLine, 3)
Local $sContentBinary = InetRead($sScraperBaseURL & $aScraperFiles[$i])
Local $sContent = BinaryToString($sContentBinary)
If $sContent = "" Then
Local $reply = MsgBox(276,"Error getting scraper file","Error in downloading " & $aScraperFiles[$i] & " from the repo. Maybe it's no longer] in use. Do you want to delete the local scraper file too?",0)
If $reply = $IDYES Then
FileDelete($sScraperPath & $aScraperFiles[$i])
EndIf
ContinueLoop
EndIf
Local $sLastLine2 = StringMid( $sContent, StringInStr($sContent, "# Last Updated", 2 ,-1 ) )
$sLastLine2 = StringStripWS($sLastLine2, 3)
local $sLocalDate = stringstripws( stringmid($sLastLine, 15), 3 )
Local $iLocalDate = Int( _Date_Time_Convert($sLocalDate, "MMMM dd, yyyy", "yyyyMMdd" ) )
Local $sRemoteDate =StringStripWS( stringmid($sLastLine2, 15), 3)
Local $iRemoteDate =Int( _Date_Time_Convert($sRemoteDate, "MMMM dd, yyyy", "yyyyMMdd" ) )
If $iRemoteDate > $iLocalDate Then
$reply = MsgBox(3, "Update this scraper?", "The current scraper: " & $aScraperFiles[$i] &  " was updated on " & $sLocalDate & ", and the new one is " & $sRemoteDate & ". Do you want to update this one?", 0)
If $reply = $IDNO Then
ContinueLoop
ElseIf $reply = $IDCANCEL Then
ExitLoop
EndIf
Local $hFile = FileOpen($sScraperPath & $aScraperFiles[$i], $FO_OVERWRITE)
Local $result = FileWrite($hFile, $sContent)
If $result = 0 Then
MsgBox(0, "Error writing files", "Error in writing the scraper file:" & $aScraperFiles[$i])
FileClose($hFile)
ContinueLoop
EndIf
FileClose($hFile)
$iTotalUpdated += 1
If StringInStr($sContent, "- python", 2) <>0 And StringInStr($sContent, "action: script") <> 0  Then
Local $sPyFile = Stringleft($aScraperFiles[$i], stringinstr($aScraperFiles[$i], ".", 2, -1) -1) & ".py"
InetGet( $sScraperBaseURL & $sPyFile, $sScraperPath & $sPyFile)
EndIf
EndIf
Next
ReloadScrapers()
If @error Then Return SetError(1)
MsgBox(64,"Scraper Update Done!","Totally scanned " & UBound($aScraperFiles ) & " files and updated "  & $iTotalUpdated & " of them.",0)
EndFunc
Func GetScraperPath()
Local $stashPath = StringLeft( $stashFilePath, StringInStr($stashFilePath, "\", 2, -1) )
Local $hFile = FileOpen($stashPath & "config.yml")
If $hFile = -1 Then
MsgBox(16,"Error open config.yml","Error opening the Stash's config file: config.yml",0)
Return SetError(1)
EndIf
Local $sLine
While True
$sLine =  FileReadLine($hFile)
If @error = -1 Then
$sLine = "scrapers_path: scrapers"
ExitLoop
ElseIf @error Then
MsgBox(16,"Error reading config.yml","Error reading the Stash's config file: config.yml",0)
FileClose($hFile)
Return SetError(1)
EndIf
If StringLeft($sLine, 14) = "scrapers_path:" Then ExitLoop
Wend
FileClose($hFile)
Local $sPath = $stashPath & StringMid($sLine, 16 ) & "\"
If Not FileExists($sPath) Then
DirCreate($sPath)
EndIf
Return $sPath
EndFunc
Func FetchScraper($sFile)
Local $result = InetGet( $sScraperBaseURL & $sFile, $sScraperPath & $sFile)
If $result = 0 Then
Return SetError(1)
EndIf
$sFile = FileRead($sScraperPath & $sFile)
If StringInStr($sFile, "- python", 2) <>0 And StringInStr($sFile, "action: script") <> 0  Then
Local $sPyFile = Stringleft($sFile, stringinstr($sFile, ".", 2, -1) -1) & ".py"
InetGet( $sScraperBaseURL & $sPyFile, $sScraperPath & $sPyFile)
Return
EndIf
EndFunc
Func SetScraperArray()
Local $iCount = 0
Local $bGetList = True, $sLine
$aScraperFiles = _FileListToArray($sScraperPath, "*.yml", $FLTA_FILES)
If FileExists($sScraperPath & "SCRAPERS-LIST.md") Then
Local $sTime = FileGetTime($sScraperPath & "SCRAPERS-LIST.md", $FT_CREATED, $FT_STRING)
If stringleft($sTime, 8) = @YEAR & @MON & @MDAY Then
$bGetList = False
EndIf
EndIf
If $bGetList Then
InetGet("https://raw.githubusercontent.com/stashapp/CommunityScrapers/master/SCRAPERS-LIST.md",  $sScraperPath & "SCRAPERS-LIST.md")
If @error Then
MsgBox(16,"Error downloading scrapers list","Error downloading the Stash's scraper list from its repo.",0)
Return SetError(1)
EndIf
EndIf
Local $hFile = FileOpen($sScraperPath & "SCRAPERS-LIST.md")
If $hFile = -1 Then
MsgBox(16,"Error open SCRAPERS-LIST.md","Error opening stash's scraper list file.",0)
Return SetError(1)
EndIf
While True
$sLine = FileReadLine($hFile)
If stringleft($sLine, 10) = "----------" Then
ExitLoop
ElseIf @error Then
MsgBox(16,"Error reading SCRAPERS-LIST.md","Error reading stash's scraper list file.",0)
Return SetError(1)
EndIf
WEnd
While True
$sLine = FileReadLine($hFile)
If @error = -1 Then
ExitLoop
ElseIf @error Then
MsgBox(16,"Error reading SCRAPERS-LIST lines","Error reading scraper list lines.",0)
Return SetError(1)
EndIf
Local $aData = StringSplit($sLine, "|")
$sLine = StringReplace($sLine, ":heavy_check_mark:", "", 0, 2)
$sLine = StringReplace($sLine, ":x:", "x", 0, 2)
Local $iPos1 = StringInStr($sLine, "|", 2, 1), $iPos2 = StringInStr($sLine, "|", 2, 2)
Local $sYml = StringMid($sLine, $iPos1 + 1, $iPos2-$iPos1-1 )
Local $result = _ArraySearch($aScraperFiles, $sYml, 0, 0, 0, 2)
Local $sInstalled = ($result= -1 )? "No|" : "Yes|"
Local $iPos = StringInStr($sLine, "|", 2, -2)
Local $sFinalLine = StringLeft($sLine, $iPos) & $sInstalled & StringMid($sLine, $iPos + 1)
ReDim $aScraperArray[$iCount + 1]
$aScraperArray[$iCount] = $sFinalLine
$iCount += 1
Wend
FileClose($hFile)
EndFunc
Func Scene2Movie()
Global $mInfo
SwitchToTab("scenes")
If @error Then Return SetError(1)
Local $sURL = _WD_Action($sSession, "url")
Local $nScene = GetNumber($sURL, "scenes")
If @error Then Return SetError(1)
GetSceneInfo($nScene)
If @error Then Return SetError(1)
Global $guiScene2Movie = GUICreate("Copy Scene Info To Movie",766,968,-1,-1,$WS_SIZEBOX,-1)
GUICtrlCreateLabel("Please choose the information you like to transfer to the movie.",80,19,698,80,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetBkColor(-1,"-2")
GUICtrlSetResizing(-1,550)
Global $lvValues = GUICtrlCreatelistview("#|Properties|Value",32,110,703,282,$LVS_SINGLESEL,BitOr($LVS_EX_FULLROWSELECT,$LVS_EX_CHECKBOXES,$WS_EX_STATICEDGE))
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetResizing(-1,550)
_GUICtrlListView_SetColumnWidth($lvValues, 0, 40)
_GUICtrlListView_SetColumnWidth($lvValues, 1, 200)
_GUICtrlListView_SetColumnWidth($lvValues, 2, 450)
GUICtrlCreateListViewItem("1|Title|" & $mInfo.Item("Title"), $lvValues)
GUICtrlCreateListViewItem("1|URL|" & $mInfo.Item("URL"), $lvValues)
GUICtrlCreateListViewItem("1|Date|" & $mInfo.Item("Date"), $lvValues)
GUICtrlCreateListViewItem("1|Duration|" & TimeConvert($mInfo.Item("Duration")), $lvValues)
GUICtrlCreateListViewItem("1|Details|" & $mInfo.Item("Details"), $lvValues)
GUICtrlCreateListViewItem("1|Studio|" & $mInfo.Item("StudioName"), $lvValues)
For $i = 0 To 5
_GUICtrlListView_SetItemChecked($lvValues, $i)
Next
Local $btnOK = GUICtrlCreateButton("OK",548,448,184,54,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetResizing(-1,804)
Local $btnCancel = GUICtrlCreateButton("Cancel",548,516,184,54,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetResizing(-1,804)
local $btnBatchCreateStudio = GUICtrlCreateButton("Create movies for scenes in same Studio",100,780,555,51,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Create movies for all other scenes in the same studio that don't link to a movie yet.")
GUICtrlSetResizing(-1,836)
Local $btnBatchCreate = GUICtrlCreateButton("Create movies for all other scenes",100,846,555,51,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Create movies for all other scenes which have no movies yet. Following the checked items here.")
GUICtrlSetResizing(-1,836)
Local $sExt = StringMid($mInfo.Item("ScreenShot"), stringinstr($mInfo.Item("ScreenShot"), ".", 2, -1))
Local $sTempPicFile = @TempDir & "\temp" & $sExt
InetGet($mInfo.Item("ScreenShot"), $sTempPicFile)
Local $imgCover = GUICtrlCreatePic($sTempPicFile,29,448,455,314,-1,$WS_EX_STATICEDGE)
GUICtrlSetResizing(-1,102)
Local $chkCover = GUICtrlCreateCheckbox("Cover",39,405,150,33,-1,-1)
GUICtrlSetState($chkCover, $GUI_CHECKED)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetResizing(-1,802)
TraySetClick(0)
GUISetState(@SW_SHOW, $guiScene2Movie)
While True
Local $nTrayMsg = TrayGetMsg()
Switch $nTrayMsg
Case $TRAY_EVENT_PRIMARYDOWN, $TRAY_EVENT_SECONDARYDOWN
WinActivate($guiScene2Movie)
EndSwitch
Local $nMsg = GUIGetMsg()
Switch $nMsg
Case $btnOK
CreateSingleMovie($lvValues, $chkCover)
ExitLoop
Case $btnBatchCreate
BatchCreate($lvValues, $chkCover)
ExitLoop
Case $btnBatchCreateStudio
If $mInfo.Item("StudioID") = Null Then
MsgBox(0, "No Studio", "This scene doesn't have a studio.")
ContinueLoop
EndIf
BatchCreate($lvValues, $chkCover, ",studios:{value:"& $mInfo.Item("StudioID") & ", modifier:INCLUDES}")
Case $GUI_EVENT_RESIZED
GUICtrlSetImage($imgCover, $sTempPicFile)
Case $GUI_EVENT_CLOSE, $btnCancel
ExitLoop
EndSwitch
Wend
GUIDelete($guiScene2Movie)
TraySetClick(9)
EndFunc
Func BatchCreate($lvValues, $chkCover, $sFilter = "")
Local $reply = MsgBox(262449,"Warning.","This function will create one movie for every scene that's not linked to a movie yet."  & @CRLF & "Also it will follow the check boxes here to only retrieve the information you specified."  & @CRLF & "However, it might create a lot of movies in the process. The problem is more serious when you have multiple scenes meant for the same movie."  & @CRLF & "So are you sure you want to continue?",0)
If $reply = 2 Then Return
Local $bGetTitle = _GUICtrlListView_GetItemChecked($lvValues, 0)
Local $bGetUrl = _GUICtrlListView_GetItemChecked($lvValues, 1)
Local $bGetDate = _GUICtrlListView_GetItemChecked($lvValues, 2)
Local $bGetDuration = _GUICtrlListView_GetItemChecked($lvValues, 3)
Local $bGetDetails = _GUICtrlListView_GetItemChecked($lvValues, 4)
Local $bGetStudio = _GUICtrlListView_GetItemChecked($lvValues, 5)
Local $bGetCover = (GUICtrlRead($chkCover) = $GUI_CHECKED )
If Not $bGetTitle Then
MsgBox(48,"Must have title checked.","The check box next to 'Title' must be checked, because in this batch mode, title is mandatory.",0)
Return
EndIf
local $sQuery = '{ "query": "{findScenes(scene_filter:{is_missing: \"movie\"'  & $sFilter & '}filter:{per_page:-1}){count,scenes{id}}}" }'
Local $sResult = Query($sQuery)
If @error Then Return SetError(1)
Local $oResult = Json_Decode($sResult)
Local $oData = Json_ObjGet($oResult, "data.findScenes")
Local $iCount = $oData.Item("count")
If $iCount = "" Or $iCount = 0 Then
MsgBox(0, "No scenes", "There is no scenes to create movies.")
Return
EndIf
Local $aScenes = Json_ObjGet($oData, "scenes")
If @error Then
MsgBox(0, "error decoding", "Error in decoding data from the query")
Return SetError(1)
EndIf
$iCount = UBound($aScenes)
Local $aIDs[$iCount]
For $i = 0 To $iCount-1
$aIDs[$i] = $aScenes[$i].Item("id")
Next
Local $old_cursor = MouseGetCursor()
GUISetCursor(15, 1, $guiScene2Movie)
Local $iMovieCreated = 0
For $i = 0 to $iCount-1
GetSceneInfo($aIDs[$i])
If Not $bGetURL Then $mInfo.Item("Url") = Null
If Not $bGetDate Then $mInfo.Item("Date") = Null
If Not $bGetDuration Then $mInfo.Item("Duration") = Null
If Not $bGetDetails Then $mInfo.Item("Details") = Null
If Not $bGetStudio Then $mInfo.Item("StudioID") = Null
If Not $bGetCover Then $mInfo.Item("ScreenShot") = Null
$sQuery =  '{"query": "mutation{ movieCreate(input:{name: \"' & $mInfo.Item("Title") & '\",' &  ($mInfo.Item("Date") = Null ? "" : 'date: \"' & $mInfo.Item("Date") & '\",' ) &  ($mInfo.Item("Details") = Null ? "" : 'synopsis: \"'& $mInfo.Item("Details") & '\",' ) &  ($mInfo.Item("URL") = Null ? "" : 'url: \"' & $mInfo.Item("URL") & '\",' ) &  ($mInfo.Item("StudioID") = Null ? "" : 'studio_id:' & $mInfo.Item("StudioID") & ',' )&  ($mInfo.Item("ScreenShot") = Null ? "" : 'front_image:\"' & $mInfo.Item("ScreenShot") & '\",' )&  ($mInfo.Item("Duration") = 0 ? "" : 'duration: ' & $mInfo.Item("Duration") ) &  '}){id} }"}'
$sResult = Query($sQuery)
If @error Then ExitLoop
$oResult = Json_Decode($sResult)
$mInfo.Item("MovieID") = Json_ObjGet($oResult, "data.movieCreate.id")
$sQuery = '{"query":"mutation{sceneUpdate(input:{id:' & $mInfo.Item("SceneID") & ',movies:{movie_id:'  & $mInfo.Item("MovieID") & '}}){id}}"}'
$sResult = Query($sQuery)
If @error Then ExitLoop
$iMovieCreated += 1
Next
GUISetCursor($old_cursor, 1, $guiScene2Movie)
_WD_Action($sSession, 'refresh')
MsgBox(0, "Job Done", "Total movie created: " & $iMovieCreated)
EndFunc
Func CreateSingleMovie($lvValues, $chkCover)
Local $bGetTitle = _GUICtrlListView_GetItemChecked($lvValues, 0)
Local $bGetUrl = _GUICtrlListView_GetItemChecked($lvValues, 1)
Local $bGetDate = _GUICtrlListView_GetItemChecked($lvValues, 2)
local $bGetDuration = _GUICtrlListView_GetItemChecked($lvValues, 3)
Local $bGetDetails = _GUICtrlListView_GetItemChecked($lvValues, 4)
Local $bGetStudio = _GUICtrlListView_GetItemChecked($lvValues, 5)
ConsoleWrite("check state:" & GUICtrlGetState($chkCover))
Local $bGetCover = ( GUICtrlRead($chkCover) = $GUI_CHECKED )
Local $input = ""
If Not $bGetTitle Then
While $input = ""
$input = InputBox("Must have a name", "The movie must have a title.", $mInfo.Item("Title") )
WEnd
$mInfo.Item("Title") = $input
EndIf
If Not $bGetURL Then $mInfo.Item("Url") = Null
If Not $bGetDate Then $mInfo.Item("Date") = Null
If Not $bGetDuration Then $mInfo.Item("Duration") = Null
If Not $bGetDetails Then $mInfo.Item("Details") = Null
If Not $bGetStudio Then $mInfo.Item("StudioID") = Null
If Not $bGetCover Then $mInfo.Item("ScreenShot") = Null
Local $sQuery =  '{"query": "mutation{ movieCreate(input:{name: \"' & $mInfo.Item("Title") & '\",' &  ($mInfo.Item("Date") = Null ? "" : 'date: \"' & $mInfo.Item("Date") & '\",' ) &  ($mInfo.Item("Details") = Null ? "" : 'synopsis: \"'& $mInfo.Item("Details") & '\",' ) &  ($mInfo.Item("URL") = Null ? "" : 'url: \"' & $mInfo.Item("URL") & '\",' ) &  ($mInfo.Item("StudioID") = Null ? "" : 'studio_id:' & $mInfo.Item("StudioID") & ',' )&  ($mInfo.Item("ScreenShot") = Null ? "" : 'front_image:\"' & $mInfo.Item("ScreenShot") & '\",' )&  ($mInfo.Item("Duration") = 0 ? "" : 'duration: ' & $mInfo.Item("Duration") ) &  '}){id} }"}'
Local $sResult = Query($sQuery)
If @error Then Return SetError(1)
Local $oResult = Json_Decode($sResult)
$mInfo.Item("MovieID") = Json_ObjGet($oResult, "data.movieCreate.id")
$sQuery = '{"query":"mutation{sceneUpdate(input:{id:' & $mInfo.Item("SceneID") & ',movies:{movie_id:' & $mInfo.Item("MovieID") & '}}){id}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
_WD_Action($sSession, 'refresh')
Sleep(1000)
OpenURL($stashURL & "movies/" & $mInfo.Item("MovieID") )
Sleep(2000)
Alert("Movie created.")
EndFunc
Func GetSceneInfo($nSceneNo)
Global $mInfo
$mInfo.RemoveAll
Local $sQuery = '{"query": "{findScene(id:' & $nSceneNo & '){title,details,url,date,paths{screenshot},file{duration},studio{id,name}}}" }'
Local $sResult = Query($sQuery)
If @error Then Return SetError(1)
Local $oResult = Json_Decode($sResult)
If not IsObj($oResult) Then Return SetError(1)
Local $oData = Json_ObjGet($oResult, "data.findScene")
If @error Then Return SetError(1)
$mInfo.Add("SceneID", $nSceneNo)
$mInfo.Add("Title", $oData.Item("title") )
$mInfo.Add("Details", $oData.Item("details") )
$mInfo.Add("URL", $oData.Item("url") )
$mInfo.Add("Date", $oData.Item("date") )
$mInfo.Add("Duration", Floor( $oData.Item("file").Item("duration") ) )
If $oData.Item("studio") = Null Then
$mInfo.Add("StudioID", Null)
$mInfo.Add("StudioName", Null)
Else
$mInfo.Add("StudioID", $oData.Item("studio").Item("id") )
$mInfo.Add("StudioName", $oData.Item("studio").Item("name") )
EndIf
$mInfo.Add("ScreenShot", $oData.Item("paths").Item("screenshot") )
EndFunc
Func ManagePlayList()
Global $guiManagePlayList = GUICreate("Manage Play List",1034,1037,-1,-1,$WS_SIZEBOX,-1)
Global $lvPlayList = GUICtrlCreatelistview("#|Title|Duration|File/Path",30,60,959,864,-1,$WS_EX_CLIENTEDGE + $LVS_EX_FULLROWSELECT + $LVS_EX_GRIDLINES)
_GUICtrlListView_SetTextBkColor($lvPlayList, $CLR_CREAM )
GUICtrlSetResizing(-1,102)
_GUICtrlListView_SetColumnWidth($lvPlayList, 0, 40)
_GUICtrlListView_SetColumnWidth($lvPlayList, 1, 300)
_GUICtrlListView_SetColumnWidth($lvPlayList, 2, 100)
_GUICtrlListView_SetColumnWidth($lvPlayList, 3, 500)
_GUICtrlListView_JustifyColumn($lvPlayList, 0, 2)
_GUICtrlListView_JustifyColumn($lvPlayList, 2, 2)
Local $btnDelete = GUICtrlCreateButton("Delete",30,936,161,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Delete the current selected item from the list.")
GUICtrlSetResizing(-1,834)
Local $btnLoad = GUICtrlCreateButton("Load",621,937,161,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Load a play list file (.m3u) from a folder.")
GUICtrlSetResizing(-1,836)
Local $btnSave = GUICtrlCreateButton("Save",830,937,161,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Save the current list to a M3U file.")
GUICtrlSetResizing(-1,836)
Local $btnPlay = GUICtrlCreateButton("Play",236,937,161,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Play this list in external media player.")
GUICtrlSetResizing(-1,834)
Local $btnClear = GUICtrlCreateButton("Clear",422,937,161,42,-1,-1)
GUICtrlSetFont(-1,12,400,0,"Tahoma")
GUICtrlSetTip(-1,"Clear the play list.")
GUICtrlSetResizing(-1,960)
For $i = 0 To UBound($aPlayList)-1
Local $iRow = _GUICtrlListView_AddItem($lvPlayList, $i+1)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, $aPlayList[$i][$LIST_TITLE], 1)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, TimeConvert($aPlayList[$i][$LIST_DURATION]), 2)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, $aPlayList[$i][$LIST_FILE], 3)
Next
TraySetClick(0)
GUISetState(@SW_SHOW, $guiManagePlayList)
While True
Local $nTrayMsg = TrayGetMsg()
Switch $nTrayMsg
Case $TRAY_EVENT_PRIMARYDOWN, $TRAY_EVENT_SECONDARYDOWN
WinActivate($guiManagePlayList)
EndSwitch
Local $nMsg = GUIGetMsg()
Switch $nMsg
Case $btnDelete
_GUICtrlListView_DeleteItemsSelected($lvPlayList)
Case $btnLoad
LoadList($lvPlayList)
Case $btnSave
SaveList($lvPlayList)
Case $btnPlay
SendPlayerList()
Case $btnClear
ClearPlayList()
_GUICtrlListView_DeleteAllItems($lvPlayList)
Case $GUI_EVENT_CLOSE
ExitLoop
EndSwitch
Wend
GUIDelete($guiManagePlayList)
TraySetClick(9)
EndFunc
Func SaveList($lvPlayList)
Local $sFileSaveDialog = FileSaveDialog("Save the m3u list file as:", @DocumentsCommonDir,  "M3U Play List File (*.m3u)", 16, "MyPlaylist.m3u" )
If @error Then
MsgBox($MB_SYSTEMMODAL, "", "No file was saved.")
Return SetError(1)
EndIf
Local $sFileName = StringTrimLeft($sFileSaveDialog, StringInStr($sFileSaveDialog, "\", 2, -1))
Local $iExtension = StringInStr($sFileName, ".", 2, -1)
If $iExtension Then
If StringTrimLeft($sFileName, $iExtension - 1) <> ".m3u" Then $sFileSaveDialog &= ".m3u"
Else
$sFileSaveDialog &= ".m3u"
EndIf
$sFileName = StringTrimLeft($sFileSaveDialog, StringInStr($sFileSaveDialog, "\", 2, -1))
Local $hFile = FileOpen($sFileSaveDialog, $FO_OVERWRITE)
If $hFile = -1 Then
MsgBox($MB_SYSTEMMODAL, "", "An error occurred when creating the file.")
Return SetError(1)
EndIf
FileWriteLine($hFile, "#EXTM3U")
Local $iCount = UBound($aPlayList)
Local $sTitle, $sFile
For $i = 0 to $iCount-1
$sTitle = $aPlayList[$i][$LIST_TITLE]
Local $iDuration = $aPlayList[$i][$LIST_DURATION]
$sFile = $aPlayList[$i][$LIST_FILE]
Local $line = "#EXTINF:" & $iDuration & "," & $sTitle
FileWriteLine($hFile, $line )
FileWriteLine($hFile, $sFile)
Next
FileClose($hFile)
MsgBox($MB_ICONINFORMATION, "File Saved.", "This file:" & $sFileName & " was saved.")
EndFunc
Func LoadList($lvPlayList)
Local $sFileOpenDialog = FileOpenDialog("Open the m3u list file:", @DocumentsCommonDir,  "M3U Play List File (*.m3u)", 3 )
If @error Then
MsgBox($MB_SYSTEMMODAL, "", "No file was opened.")
Return SetError(1)
EndIf
If StringInStr($sFileOpenDialog, "|") <> 0 Then
MsgBox($MB_SYSTEMMODAL, "", "Only one file is allowed.")
Return SetError(1)
EndIf
Local $hFile = FileOpen($sFileOpenDialog, $FO_READ)
If $hFile = -1 Then
MsgBox($MB_SYSTEMMODAL, "", "An error occurred when opening the file.")
Return SetError(1)
EndIf
_GUICtrlListView_DeleteAllItems($lvPlayList)
Global $aPlayList[0][3]
Local $EOF = False
While Not $EOF
Local $sLine = FileReadLine($hFile)
If @error Then
$EOF = True
ExitLoop
EndIf
If StringLeft($sLine, 8) = "#EXTINF:" then
$i = UBound($aPlayList)
ReDim $aPlayList[$i+1][3]
Local $iPos = StringInStr($sLine, ",", 2)
Local $sTitle = stringmid($sLine, $iPos + 1 )
Local $iDuration = Int( StringMid($sLine, 9, $iPos-9) )
$aPlayList[$i][$LIST_TITLE] = $sTitle
$aPlayList[$i][$LIST_DURATION] = $iDuration
$aPlayList[$i][$LIST_FILE] = StringStripWS( FileReadLine($hFile), 3)
Local $iRow = _GUICtrlListView_AddItem($lvPlayList, $i+1)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, $sTitle, 1)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, TimeConvert($iDuration), 2)
_GUICtrlListView_SetItemText($lvPlayList, $iRow, $aPlayList[$i][$LIST_FILE], 3)
EndIf
WEnd
FileClose($hFile)
EndFunc
Global $iStashPID
$stashURL = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "StashURL")
If $stashURL = "" Then
$iStashPID = ProcessExists("stash-win.exe")
If $iStashPID <> 0 Then ProcessClose($iStashPID)
$iStashPID = Run($stashFilePath & $sNoBrowser, $stashPath, @SW_HIDE, $STDERR_MERGED)
Local $hTimer = TimerInit()
While True
Local $sLine = StdoutRead($iStashPID)
If @error Then
Exit
EndIf
If $sLine <> "" Then
c("*" & $sLine)
EndIf
Select
Case StringInStr($sLine, "stash version:", 2)
$stashVersion = StringMid($sLine, StringInStr($sLine, "stash version:", 2))
$stashVersion = StringStripWS($stashVersion, $STR_STRIPTRAILING)
Case StringInStr($sLine, "stash is running at ")
Local $iPos1 = StringInStr($sLine, "http", 2)
Local $iPos2 = StringInStr($sLine, " ", 2, 1, $iPos1 + 7)
$stashURL = StringMid($sLine, $iPos1, $iPos2 -$iPos1)
$stashURL = StringStripWS($stashURL, $STR_STRIPTRAILING)
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "StashURL", "REG_SZ", $stashURL)
ExitLoop
EndSelect
If TimerDiff($hTimer)> 10000 Then
MsgBox(48,"Error launching StashApp", "It takes too long to get StashApp ready. Something is wrong. Exiting.",20)
Exit
EndIf
Sleep(100)
Wend
Else
Local $aStr = StringRegExp($stashURL, "\:\/\/(.*)\:(\d+)", $STR_REGEXPARRAYMATCH )
Local $sHost = $aStr[0], $sPort = $aStr[1]
If $sHost = "localhost" Then
$iStashPID = ProcessExists("stash-win.exe")
If $iStashPID = 0 Then
If $showStashConsole Then
$iStashPID = Run($stashFilePath & $sNoBrowser, $stashPath, @SW_SHOW)
Else
$iStashPID = Run($stashFilePath & $sNoBrowser, $stashPath, @SW_HIDE)
EndIf
Else
Local $iPid = Run(@ComSpec & ' /C netstat -ano|find "0.0.0.0:' & $sPort & '"',"",@SW_HIDE, $STDOUT_CHILD )
ProcessWaitClose($iPid)
Local $sReadOut = StdoutRead($iPid)
$aStr = StringRegExp($sReadOut, "LISTENING\s+(\d+)", $STR_REGEXPARRAYMATCH)
If @error Then
$iStashPID = 0
Else
$iStashPID = Int( $aStr[0] )
EndIf
EndIf
Else
$iStashPID = 0
EndIf
EndIf
Func URLtoQuery($sURL, $sQueryType = "id")
Local $aResult[1]
Local $sStr = StringMid($sURL, StringLen($stashURL) +1 )
If StringLeft($sStr, 1) = "/" Then $sStr = StringTrimLeft($sStr, 1)
$aStr = StringSplit($sStr, "?&/")
Local $iCount = $aStr[0]
Local $sSortby = "", $sSortDir = "ASC", $sQuickQuery = ""
Local $aCQuery[0]
For $i = 1 to $iCount-1
Switch PairName($aStr[$i])
Case "sortby", "qsort"
$sSortby = PairValue( $aStr[$i])
_ArrayDelete($aStr, $i)
$iCount -= 1
Case "sortdir", "qsortd"
$sSortDir = StringUpper( PairValue($aStr[$i]) )
_ArrayDelete($aStr, $i)
$iCount -= 1
Case "disp", "p", "perPage"
_ArrayDelete($aStr, $i)
$iCount -= 1
Case "q"
$sQuickQuery = PairValue($aStr[$i])
_ArrayDelete($aStr, $i)
$iCount -= 1
Case "c"
Local $iU = UBound($aCQuery)
ReDim $aCQuery[ $iU + 1]
$aCQuery[$iU] = PairValue($aStr[$i])
EndSwitch
Next
Local $sFilter = "filter:{per_page:-1 "
If $sQuickQuery <> "" Then $sFilter &= "q: " & QueryQ($sQuickQuery) & " "
If $sSortby <> "" Then $sFilter &= "sort:" & $sSortby & " direction:" & $sSortDir
$sFilter &= "}"
c("sFilter:" & $sFilter & " icount:" & $iCount)
c("c query ubound:" & UBound($aCQuery))
If $iCount = 1 Then
Switch $aStr[1] & $sQueryType
Case "id", "count"
return "home"
Case "scenescount"
Return '{findScenes(scene_filter:{title:{value: \".+\" modifier: MATCHES_REGEX }}){count}}'
Case "scenesid"
Return '{findScenes(scene_filter:{title:{value: \".+\"modifier: MATCHES_REGEX }} ' & $sFilter & '){count, scenes {id}}}'
Case "imagescount"
Return '{findImages(image_filter:{title:{value: \".+\" modifier: MATCHES_REGEX}}){count}}'
Case "imagesid"
Return '{findImages(image_filter:{title:{value: \".+\"modifier: MATCHES_REGEX }} ' & $sFilter & '){count, images {id}}}'
Case "moviescount"
Return '{findMovies(movie_filter:{name:{value: \".+\" modifier: MATCHES_REGEX }}){count}}'
Case "moviesid"
Return '{findMovies(movie_filter:{name:{value: \".+\"modifier: MATCHES_REGEX }} ' & $sFilter & '){count, movies {id}}}'
Case "galleriescount"
Return '{findGalleries(gallery_filter:{title:{value: \".+\" modifier: MATCHES_REGEX}}){count}}'
Case "galleriesid"
Return '{findGalleries(gallery_filter:{title:{value: \".+\"modifier: MATCHES_REGEX }} ' & $sFilter & '){count,galleries {id}}}'
Case Else
Return 'not support'
EndSwitch
EndIf
If StringIsDigit($aStr[2]) Then
Switch $aStr[1] & $sQueryType
Case "scenescount", "imagescount", "moviescount", "galleriescount"
Return "1"
Case "scenesid", "imagesid", "moviesid", "galleriesid"
Return 'id='& $aStr[2]
Case Else
Return "not support"
EndSwitch
EndIf
Local $sCriteria = ""
If UBound($aCQuery) > 0 Then
For $sCQuery In $aCQuery
c("$sCQuery:" & $sCQuery)
Local $oCriteria =  Json_Decode($sCQuery)
If @error Or ( Not IsObj($oCriteria)) Then
ContinueLoop
Else
Switch $oCriteria.item("type")
Case "sceneChecksum", "movieChecksum", "galleryChecksum", "imageChecksum"
$sCriteria &= MakeCriteria("checksum", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "details"
$sCriteria &= MakeCriteria("details", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "duration"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
Local $sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("duration", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("duration", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
Case "hasMarkers"
$sCriteria &= MakeCriteria2( "has_markers", QueryQ($oCriteria.Item("value")) )
Case "oshash"
$sCriteria &= MakeCriteria("oshash", QueryQ($oCriteria.Item("value")) , $oCriteria.Item("modifier") )
Case "interactive"
$sCriteria &= MakeCriteria2("interactive", $oCriteria.Item("value"))
Case "sceneIsMissing", "movieIsMissing", "galleryIsMissing", "imageIsMissing"
$sCriteria &= MakeCriteria2("is_missing", QueryQ($oCriteria.Item("value")) )
Case "movies"
Switch $oCriteria.item("modifier")
Case "IS_NULL", "NOT_NULL"
$sCriteria &= MakeCriteria("movies", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case Else
Local $aMovies = $oCriteria.item("value")
Local $sIDs = "["
If UBound($aMovies)> 0 Then
For $oMovie In $aMovies
If $sIDs = "[" Then
$sIDs &= $oMovie.Item("id")
Else
$sIDs &= "," & $oMovie.Item("id")
EndIf
Next
$sIDs &= "]"
EndIf
$sCriteria &= MakeCriteria("movies", $sIDs, $oCriteria.Item("modifier") )
EndSwitch
Case "o_counter"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
$sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("o_counter", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("o_counter", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
Case "organized"
$sCriteria &= MakeCriteria2("organized", $oCriteria.Item("value"))
Case "path"
$sCriteria &= MakeCriteria("path", QueryQ( $oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "performer_count"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
$sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("performer_count", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("performer_count", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
Case "performerTags"
Switch $oCriteria.item("modifier")
Case "IS_NULL", "NOT_NULL"
$sCriteria &= MakeCriteria("performer_tags", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case Else
Local $aTags = $oCriteria.item("value").item("items")
Local $sIDs = "["
If UBound($aTags)> 0 Then
For $oTag In $aTags
If $sIDs = "[" Then
$sIDs &= $oTag.item("id")
Else
$sIDs &= "," & $oTag.item("id")
EndIf
Next
$sIDs &= "]"
EndIf
$sIDs &= " depth:" & $oCriteria.item("value").item("depth")
$sCriteria &= MakeCriteria("performer_tags", $sIDs, $oCriteria.Item("modifier") )
EndSwitch
Case "performers"
Switch $oCriteria.item("modifier")
Case "IS_NULL", "NOT_NULL"
$sCriteria &= MakeCriteria("performers", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case Else
Local $aPerformers = $oCriteria.item("value")
Local $sIDs = "["
If UBound($aPerformers)> 0 Then
For $oPerformer In $aPerformers
If $sIDs = "[" Then
$sIDs &= $oPerformer.item("id")
Else
$sIDs &= "," & $oPerformer.item("id")
EndIf
Next
$sIDs &= "]"
EndIf
$sCriteria &= MakeCriteria("performers", $sIDs, $oCriteria.Item("modifier") )
EndSwitch
Case "phash"
$sCriteria &= MakeCriteria("phash", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "rating"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
$sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("rating", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("rating", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
Case "resolution"
$sCriteria &= MakeCriteria("resolution", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case "stash_id"
$sCriteria &= MakeCriteria("stash_id", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "studios"
Switch $oCriteria.item("modifier")
Case "IS_NULL", "NOT_NULL"
$sCriteria &= MakeCriteria("studios", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case Else
Local $aStudios = $oCriteria.item("value").item("items")
Local $sIDs = "["
If UBound($aStudios)> 0 Then
For $oStudio In $aStudios
If $sIDs = "[" Then
$sIDs &= $oStudio.item("id")
Else
$sIDs &= "," & $oStudio.item("id")
EndIf
Next
$sIDs &= "]"
EndIf
$sIDs &= " depth:" & $oCriteria.item("value").item("depth")
$sCriteria &= MakeCriteria("studios", $sIDs, $oCriteria.Item("modifier") )
EndSwitch
Case "tag_count"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
$sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("tag_count", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("tag_count", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
Case "tags"
Switch $oCriteria.item("modifier")
Case "IS_NULL", "NOT_NULL"
$sCriteria &= MakeCriteria("tags", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case Else
Local $aTags = $oCriteria.item("value").item("items")
Local $sIDs = "["
If UBound($aTags)> 0 Then
For $oTag In $aTags
If $sIDs = "[" Then
$sIDs &= $oTag.item("id")
Else
$sIDs &= "," & $oTag.item("id")
EndIf
Next
$sIDs &= "]"
EndIf
$sIDs &= " depth:" & $oCriteria.item("value").item("depth")
$sCriteria &= MakeCriteria("tags", $sIDs, $oCriteria.Item("modifier") )
EndSwitch
Case "title"
$sCriteria &= MakeCriteria("title", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "url"
$sCriteria &= MakeCriteria("url", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "director"
$sCriteria &= MakeCriteria("director", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "name"
$sCriteria &= MakeCriteria("name", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "synopsis"
$sCriteria &= MakeCriteria("synopsis", QueryQ($oCriteria.Item("value")), $oCriteria.Item("modifier") )
Case "average_resolution"
$sCriteria &= MakeCriteria("average_resolution", $oCriteria.Item("value"), $oCriteria.Item("modifier") )
Case "image_count"
Switch $oCriteria.item("modifier")
Case "BETWEEN", "NOT_BETWEEN"
$sValues = $oCriteria.Item("value").Item("value") & " value2:" & $oCriteria.Item("value").Item("value2")
$sCriteria &= MakeCriteria("image_count", $sValues, $oCriteria.Item("modifier") )
Case Else
$sCriteria &= MakeCriteria("image_count", $oCriteria.Item("value").Item("value"), $oCriteria.Item("modifier") )
EndSwitch
EndSwitch
EndIf
Next
EndIf
Local $sQString
Switch $aStr[1] & $sQueryType
Case "scenescount"
$sQString = '{findScenes('
If $sCriteria <> "" Then $sQString &= "scene_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count}}'
Return $sQString
Case "scenesid"
$sQString = '{findScenes('
If $sCriteria <> "" Then $sQString &= "scene_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count,scenes{id}}}'
Return $sQString
Case "moviescount"
$sQString = '{findMovies('
If $sCriteria <> "" Then $sQString &= "movie_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count}}'
Return $sQString
Case "moviesid"
$sQString = '{findMovies('
If $sCriteria <> "" Then $sQString &= "movie_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count,movies{id}}}'
Return $sQString
Case "imagescount"
$sQString = '{findImages('
If $sCriteria <> "" Then $sQString &= "image_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count}}'
Return $sQString
Case "imagesid"
$sQString = '{findImages('
If $sCriteria <> "" Then $sQString &= "image_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count,images{id}}}'
Return $sQString
Case "galleriescount"
$sQString = '{findGalleries('
If $sCriteria <> "" Then $sQString &= "gallery_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count}}'
Return $sQString
Case "galleriesid"
$sQString = '{findGalleries('
If $sCriteria <> "" Then $sQString &= "gallery_filter: {" & $sCriteria & "} "
$sQString &= $sFilter & '){count,galleries{id}}}'
Return $sQString
Case Else
Return 'not support'
EndSwitch
EndFunc
Func GetResultProperty($sJson, $sProperty)
Local $aStr = StringRegExp($sJson, Q($sProperty) & ':\s*"?(.+?)["},\n\r]', $STR_REGEXPARRAYMATCH )
If @error Then Return ""
Return $aStr[0]
EndFunc
Func QueryQ($str)
Return '\"' & $str & '\"'
EndFunc
Func MakeCriteria2($type, $value)
Return " " & $type & ":" & $value & " "
EndFunc
Func MakeCriteria($type, $value, $modifier)
If $value = "" Then
Return " " & $type & ":{modifier : " & $modifier & "}"
Else
Return " " & $type & ":{value:" & $value & " modifier : " & $modifier & "}"
EndIf
EndFunc
Func PairName($str, $separator = "=")
Return stringleft( $str, stringinstr($str, $separator, 2) -1 )
EndFunc
Func PairValue($str, $separator = "=")
Return stringmid( $str, stringinstr($str, $separator, 2) + 1 )
EndFunc
Opt("TrayMenuMode", 3)
Local $sResult = Query('{"query":"{version{version,hash}}"}')
If Not @error Then
Local $oResult = Json_Decode($sResult)
Local $oVersion = Json_ObjGet($oResult, "data.version")
$stashVersion = $oVersion.Item("version")
Local $stashVersionHash = $oVersion.Item("hash")
$sResult = Query('{"query":"{latestversion{shorthash,url}}"}')
If Not @error Then
$oResult = Json_Decode($sResult)
Local $oLatestVersion = Json_ObjGet($oResult, "data.latestversion")
Local $sLatestVersionHash = $oLatestVersion.Item("shorthash")
Local $sLatestVersionURL = $oLatestVersion.Item("url")
Local $sIgnoreHash = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "IgnoreHash")
If $sLatestVersionHash <> $stashVersionHash And $sLatestVersionHash <> $sIgnoreHash Then
Local $aMatchStr = StringRegExp($sLatestVersionURL, '\/download\/(.+)\/stash-win.exe', $STR_REGEXPARRAYMATCH)
Local $sNewVersion = $aMatchStr[0]
Local $hAskUpgrade = MsgBox(266787,"A new stash version:" & $sNewVersion & " is available.","There is a new version of Stash: " & $sNewVersion & " Do you want to update the current stash to the new one?" & @CRLF & "If you hit 'Yes', the new version will automatically replace the old one." & @CRLF & "If you hit 'No', this new version will be ignored." & @CRLF & "If you hit 'Cancel', Stash_Helper will ask you again next time.",0)
switch $hAskUpgrade
case 6
ProcessClose($iStashPID)
InetGet($sLatestVersionURL, @TempDir & "\stash-win.exe" )
If Not @error Then
FileDelete($stashFilePath)
FileMove(@TempDir & "\stash-win.exe", $stashFilePath, $FC_OVERWRITE)
If $showStashConsole Then
$iStashPID = Run($stashFilePath & $sNoBrowser, $stashPath, @SW_SHOW)
Else
$iStashPID = Run($stashFilePath & $sNoBrowser, $stashPath, @SW_HIDE)
EndIf
EndIf
case 7
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", "IgnoreHash", "REG_SZ", $sLatestVersionHash)
case 2
endswitch
EndIf
EndIf
Else
EndIf
If $stashVersion <> "" Then
TrayTip("Stash is Active", $stashVersion, 5, $TIP_ICONASTERISK+$TIP_NOSOUND  )
EndIf
TrayCreateItem("Stash Helper " & $currentVersion )
TrayCreateItem("")
Global $trayMenuScenes = TrayCreateMenu("Scenes")
_TrayMenuAddImage($hIcons[0], 2)
Global $trayMenuImages = TrayCreateMenu("Images")
_TrayMenuAddImage($hIcons[1], 3)
Global $trayMenuMovies = TrayCreateMenu("Movies")
_TrayMenuAddImage($hIcons[2], 4)
Global $trayMenuMarkers = TrayCreateMenu("Markers")
_TrayMenuAddImage($hIcons[3], 5)
Global $trayMenuGalleries = TrayCreateMenu("Galleries")
_TrayMenuAddImage($hIcons[4], 6)
Global $trayMenuPeformers = TrayCreateMenu("Performers")
_TrayMenuAddImage($hIcons[5], 7)
Global $trayMenuStudios = TrayCreateMenu("Studios")
_TrayMenuAddImage($hIcons[6], 8)
Global $trayMenuTags = TrayCreateMenu("Tags")
_TrayMenuAddImage($hIcons[7], 9)
Global $trayMenuBookmark = TrayCreateItem("Bookmark    Ctrl-Alt-B")
_TrayMenuAddImage($hIcons[17], 10)
TrayCreateItem("")
Global $trayPlayScene = TrayCreateItem("Play Current Scene")
_TrayMenuAddImage($hIcons[12], 12)
Global $trayPlayMovie = TrayCreateItem("Play Current Movie")
_TrayMenuAddImage($hIcons[13], 13)
Global $trayScrapers = TrayCreateItem("Scrapers Manager")
_TrayMenuAddImage($hIcons[8], 14)
Global $trayScan = TrayCreateItem("Scan New Files")
_TrayMenuAddImage($hIcons[14], 15)
Global $trayMovie2Scene = TrayCreateItem("Create movie from scene...")
_TrayMenuAddImage($hIcons[15], 16)
Global $trayOpenFolder =  TrayCreateItem("Open Media Folder   Ctrl-Alt-O")
_TrayMenuAddImage($hIcons[18], 17)
Global $trayMenuCSS = TrayCreateMenu("CSS Magic")
_TrayMenuAddImage($hIcons[19], 18)
Global $aCSSItems[0][4]
Global Enum $CSS_TITLE, $CSS_CONTENT, $CSS_ENABLE, $CSS_HANDLE
CreateCSSMenu()
Global $trayMenuPlayList = TrayCreateMenu("Play List")
_TrayMenuAddImage($hIcons[16], 19)
Global $trayAddItemToList = TrayCreateItem("Add Scene/Movie/Image/Gallery to Play List         Ctrl-Alt-A", $trayMenuPlayList)
Global $trayManageList = 			TrayCreateItem("Manage Current Play List                     Ctrl-Alt-M", $trayMenuPlayList)
Global $trayListPlay = 				TrayCreateItem("Send the Current Play List to Media Player   Ctrl-Alt-P", $trayMenuPlayList)
Global $trayClearList = 			TrayCreateItem("Clear the Play List                          Ctrl-Alt-C", $trayMenuPlayList)
TrayCreateItem("")
Global $traySettings = TrayCreateItem("Settings")
_TrayMenuAddImage($hIcons[9], 21)
Global $trayAbout = TrayCreateItem("About")
_TrayMenuAddImage($hIcons[10], 22)
Global $trayExit = TrayCreateItem("Exit")
_TrayMenuAddImage($hIcons[11], 23)
_IconDestroy($hIcons)
Global $traySceneLinks[$iMaxSubItems][3]
Global $trayImageLinks[$iMaxSubItems][3]
Global $trayMovieLinks[$iMaxSubItems][3]
Global $trayMarkerLinks[$iMaxSubItems][3]
Global $trayGalleryLinks[$iMaxSubItems][3]
Global $trayPerformerLinks[$iMaxSubItems][3]
Global $trayStudioLinks[$iMaxSubItems][3]
Global $trayTagLinks[$iMaxSubItems][3]
Global $customScenes, $customImages, $customMovies, $customMarkers, $customGalleries
Global $customPerformers, $customStudios, $customTags
If Not $showWDConsole Then
$_WD_DEBUG = $_WD_DEBUG_None
EndIf
Switch $stashBrowser
Case "Firefox"
SetupFirefox()
Case "Chrome"
SetupChrome()
Case "Edge"
SetupEdge()
Case Else
$stashBrowser = "Edge"
SetupEdge()
EndSwitch
Sleep(1000)
Global $iConsolePID = _WD_Startup()
If @error <> $_WD_ERROR_Success Then BrowserError(@extended)
$sSession = _WD_CreateSession($sDesiredCapabilities)
If @error <> $_WD_ERROR_Success Then BrowserError(@extended)
Global $sBrowserHandle
#EndRegion Globals
#Region Tray Menu Handling
CreateSubMenu()
TraySetState($TRAY_ICONSTATE_SHOW)
OpenURL($stashURL)
HotKeySet("^{ENTER}", "CloseSession")
HotKeySet("^!a", "AddItemToList")
HotKeySet("^!c", "ClearPlayList")
HotKeySet("^!m", "ManagePlayList")
HotKeySet("^!p", "SendPlayerList")
HotKeySet("^!b", "BookmarkCurrentTab")
HotKeySet("^!o", "OpenMediaFolder")
While True
Local $nMsg = TrayGetMsg()
Switch $nMsg
Case 0
Case $trayAbout
MsgBox(64,"Stash Helper " & $currentVersion,"Stash helper " & $currentVersion & ", written by Philip Wang." & @CRLF & "Hopefully this little program will make you navigate the powerful Stash App more easily." & @CRLF & "Kudos to the great Stash App team ! kermieisinthehouse, WithoutPants, bnkai ... and all other great contributors working for this huge project." & @CRLF & "Kudos also go to Christian Faderl's ISN AutoIt Studio! It's such a powerful AutoIt IDE, which making this program much easier to write." & @CRLF & "Also thanks to InstallForge.net for providing me such an easy-to-build installer!" & @CRLF & "Special thanks to BViking78 for the numerous pieces of advice," & @CRLF & "and thank you gamerjax for your play list suggestions.!"	,20)
Case $trayExit
ExitScript()
Case $traySettings
ShowSettings()
Case $trayScrapers
ScrapersManager()
Case $customScenes
CustomList("Scenes", $traySceneLinks)
Case $customImages
CustomList("Images", $trayImageLinks)
Case $customMovies
CustomList("Movies", $trayMovieLinks)
Case $customMarkers
CustomList("Markers", $trayMarkerLinks)
Case $customGalleries
CustomList("Galleries", $trayGalleryLinks)
Case $customPerformers
CustomList("Performers", $trayPerformerLinks)
Case $customStudios
CustomList("Studios", $trayStudioLinks)
Case $customTags
CustomList("Tags", $trayTagLinks)
Case $trayPlayScene
PlayScene()
Case $trayPlayMovie
PlayMovie()
Case $trayScan
ScanFiles()
Case $trayMovie2Scene
Scene2Movie()
Case $trayAddItemToList
AddItemToList()
Case $trayClearList
ClearPlayList()
Case $trayManageList
ManagePlayList()
Case $trayListPlay
SendPlayerList()
Case $trayMenuBookmark
BookmarkCurrentTab()
Case $trayOpenFolder
OpenMediaFolder()
Case Else
For $i = 0 to UBound($traySceneLinks)-1
If $traySceneLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($traySceneLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayImageLinks)-1
If $trayImageLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayImageLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayMovieLinks)-1
If $trayMovieLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayMovieLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayMarkerLinks)-1
If $trayMarkerLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayMarkerLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayGalleryLinks)-1
If $trayGalleryLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayGalleryLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayPerformerLinks)-1
If $trayPerformerLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayPerformerLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayStudioLinks)-1
If $trayStudioLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayStudioLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 to UBound($trayTagLinks)-1
If $trayTagLinks[$i][$ITEM_HANDLE] = $nMsg Then
OpenURL($trayTagLinks[$i][$ITEM_LINK])
ContinueLoop 2
EndIf
Next
For $i = 0 To UBound($aCSSItems) -1
If $aCSSItems[$i][$CSS_HANDLE] = $nMsg Then
Local $sQuery = "{configuration{interface{cssEnabled}}}"
$sResult = Query2($sQuery)
If @error Then ContinueLoop
If StringInStr($sResult, "true", 2) = 0 Then
MsgBox(0, "Need to enable custom css feature.", 'You need to enable custom css in "Settings->Interface->Custom CSS" first.' )
ContinueLoop
EndIf
Local $sFile = $stashPath & "custom.css"
Local $sCSS =  FileRead($sFile)
If @error Then $sCSS = ""
If $aCSSItems[$i][$CSS_ENABLE] = 1 Then
Local $sSearchStart = "/* Start:" & $aCSSItems[$i][$CSS_TITLE] & " */"
Local $sSearchEnd = "/* End:" & $aCSSItems[$i][$CSS_TITLE] & " */"
Local $iPos1 = StringInStr($sCSS, $sSearchStart, 2)
Local $iPos2 = StringInStr($sCSS, $sSearchEnd, 2)
If $iPos2 > $iPos1 and $iPos1 <> 0 Then
$iPos2 += StringLen($sSearchEnd)
$sCSS = StringLeft($sCSS, $iPos1-1) & StringMid($sCSS, $iPos2)
EndIf
ApplyCSS($sCSS)
$aCSSItems[$i][$CSS_ENABLE] = 0
TrayItemSetState($aCSSItems[$i][$CSS_HANDLE], $TRAY_UNCHECKED)
Else
Local $sStart = "/* Start:" & $aCSSItems[$i][$CSS_TITLE] & " */"
Local $sEnd = "/* End:" & $aCSSItems[$i][$CSS_TITLE] & " */"
If StringRight($sCSS, 1) <> @LF Then $sCSS &= @LF
$sCSS &= $sStart & @LF & $aCSSItems[$i][$CSS_CONTENT] & @LF & $sEnd
ApplyCSS($sCSS)
$aCSSItems[$i][$CSS_ENABLE] = 1
TrayItemSetState($aCSSItems[$i][$CSS_HANDLE], $TRAY_CHECKED)
EndIf
_WD_Action($sSession, "refresh")
EndIf
Next
EndSwitch
Wend
Exit
#EndRegion Tray menu
#Region Functions
Func ApplyCSS($str)
$str = StringReplace($str, @CRLF, "\\n", 0, 2)
$str = StringReplace($str, @LF, "\\n", 0, 2)
If StringLeft($str, 3) = "\\n" Then
$str = StringMid($str, 4)
EndIf
$sQuery = 'mutation{configureInterface(input:{css:\"' & $str & '\" cssEnabled: true }){css}}'
Query2($sQuery)
if @error then return SetError(1)
EndFunc
Func CreateCSSMenu()
If UBound($aCSSItems) = 0 Then InitCSSArray($aCSSItems)
For $i = 0 To UBound($aCSSItems) -1
$aCSSItems[$i][$CSS_HANDLE] = TrayCreateItem($aCSSItems[$i][$CSS_TITLE], $trayMenuCSS)
If $aCSSItems[$i][$CSS_ENABLE] = 1 Then
TrayItemSetState($aCSSItems[$i][$CSS_HANDLE], $TRAY_CHECKED)
EndIf
Next
EndFunc
Func InitCSSArray(ByRef $a)
ReDim $a[18][4]
$a[0][0] = "Scene - Fit More Thumbnails on Each Row."
$a[0][1] = ".grid { padding: 0px !important; }"
$a[1][0] = "Scene - Longer Studio Text in Scene Cards"
$a[1][1] = ".scene-studio-overlay { font-weight: 600 !important; opacity: 1 !important; width: 60% !important; text-overflow: ellipsis !important;}"
$a[2][0] = "Scene - Hide Scene Specs from Scene Cards"
$a[2][1] = ".scene-specs-overlay{display: none;}"
$a[3][0] = "Scene - Hide Studio from Scene Cards"
$a[3][1] = ".scene-studio-overlay{display: none;}"
$a[4][0] = "Scene - Tags use less width"
$a[4][1] = ".bs-popover-bottom{max-width: 500px}"
$a[5][0] = "Scene - Swap Studio and Specs in Scene Cards"
$a[5][1] = ".scene-studio-overlay{bottom: 1rem; right: 0.7rem; height: inherit; top: inherit;}" & @LF & ".scene-specs-overlay { right: 0.7rem; top: 0.7rem; bottom: inherit;}"
$a[6][0] = "Scene - Adjust Mouse Over Behavior in Wall Mode"
$a[6][1] = "@media (min-width: 576px) { .wall-item:hover::before { opacity: 0; }" & @LF & ".wall-item:hover .wall-item-container { transform: scale(1.5); }}"
$a[7][0] = "Scene - Disable Zoom on Hover in Wall Mode"
$a[7][1] = ".wall-item:hover .wall-item-container {transform: none;} " & @LF & ".wall-item:before { opacity: 0 !important;}"
$a[8][0] = "Scene - Hide the Scene Scrubber"
$a[8][1] = ".scrubber-wrapper { display: none;}" & @LF & "#jwplayer-container > div:first-child { height: 100%;}"
$a[9][0] = "Performer - Show Entire Performer's Image"
$a[9][1] = ".performer.image { background-size: contain !important;}"
$a[10][0] = "Performer - Move Edit Buttons to the Top"
$a[10][1] = "form#performer-edit {display: flex; flex-direction: column;}" & @LF & "#performer-edit > .row { order: 1;}" & @LF & "#performer-edit > .row:last-child { order: 0; margin-bottom: 1rem;}"
$a[11][0] = "Gallery - Grid View for Galleries"
$a[11][1] = ".col.col-sm-6.mx-auto.table .d-none.d-sm-block { display: none !important;}" & @LF & ".col.col-sm-6.mx-auto.table .w-100.w-sm-auto { width: 175px !important; background-color: rgba(0, 0, 0, .45); box-shadow: 0 0 2px rgba(0, 0, 0, .35);}" & @LF & ".col.col-sm-6.mx-auto.table tr { display: inline-table;}"
$a[12][0] = "Images - Disable Lightbox Animation"
$a[12][1] = ".Lightbox-carousel { transition: none;}"
$a[13][0] = "Images - Don't Crop Preview Thumbnails"
$a[13][1] = ".flexbin > * > img { object-fit: inherit; max-width: none; min-width: initial;}"
$a[14][0] = "Movies - Better Layout for Desktops 1 - Regular Posters"
$a[14][1] = ".movie-details.mb-3.col.col-xl-4.col-lg-6 { flex: 0 0 70%; max-width: 70%}" & @LF & ".col-xl-8.col-lg-6{ flex: 0 0 30%; max-width: 30% }" & @LF & ".movie-images{  flex-wrap: wrap}" & @LF & ".movie-image-container { flex: 0 0 500px}"
$a[15][0] = "Movies - Better Layout for Desktops 2 - Larger Posters"
$a[15][1] = ".movie-details.mb-3.col.col-xl-4.col-lg-6 { flex:0 0 70%; max-width: 70%}" & @LF & ".col-xl-8.col-lg-6{ flex: 0 0 30%; max-width: 30% }" & @LF & ".movie-images{ flex-direction: column; flex-wrap: wrap}" & @LF & ".movie-image-container { flex: 1 1 700px}"
$a[16][0] = "Global - Hide the Donation Button"
$a[16][1] = ".btn-primary.btn.donate.minimal { display: none;}"
$a[17][0] = "Global - Blur NSFW Images"
$a[17][1] = ".scene-card-preview-video, .scene-card-preview-image, .image-card-preview-image, .image-thumbnail, .gallery-card-image," & @LF & ".performer-card-image, img.performer, .movie-card-image, .gallery .flexbin img, .wall-item-media, .scene-studio-overlay .image-thumbnail," & @LF & ".image-card-preview-image, #scene-details-container .text-input, #scene-details-container .scene-header, #scene-details-container .react-select__single-value," & @LF & ".scene-details .pre, #scene-tabs-tabpane-scene-file-info-panel span.col-8.text-truncate > a, .gallery .flexbin img, .movie-details .logo " & @LF & "{filter: blur(8px);}" & @LF & ".scene-card-video {filter: blur(13px);}" & @LF & ".jw-video, .jw-preview, .jw-flag-floating, .image-container, .studio-logo, .scene-cover { filter: blur(20px);}" & @LF & ".movie-card .text-truncate, .scene-card .card-section { filter: blur(4px); }"
Local $sFile = $stashPath & "custom.css"
Local $sCSS =  FileRead($sFile)
If @error Then $sCSS = ""
For $i = 0 To UBound($a) -1
Local $sSearch = "/* Start:" & $a[$i][0] & " */"
$a[$i][$CSS_ENABLE] = (StringInStr($sCSS, $sSearch, 2) <> 0) ? 1 : 0
Next
EndFunc
Func AlreadyRunning()
Local $aPID = ProcessList("AutoIt3.exe")
If @error or $aPID[0][0] = 0 then Return False
For $i = 1 to $aPID[0][0]
If $aPID[$i][1] = @AutoItPID Then ContinueLoop
Local $sPath = _WinAPI_GetProcessFileName($aPID[$i][1])
If StringInStr($sPath, "Stash Helper") <> 0 Then Return True
Next
Return False
EndFunc
Func OpenMediaFolder()
$sResult = GetCurrentTabCategoryAndNumber()
If @error Then Return SetError(1)
If StringInStr($sResult, "-") = 0 Then
MsgBox(0, "Need specific item", "The current browser is showing a collection, need to show specific scene/movie/image/gallery." )
Return
EndIf
Local $aStr = StringSplit($sResult, "-")
Switch $aStr[1]
Case "performers"
MsgBox(0, "Cannot be a performer", "No folder location for performers.")
Return
Case "studios"
MsgBox(0, "Cannot be a studio", "No folder location for studios.")
Return
Case "markers"
MsgBox(0, "Cannot be markers", "Sorry, no support for markers yet.")
Return
Case "movies"
$sQuery = '{ "query": "{findMovie(id: ' & $aStr[2] & '){name,scene_count,scenes{id}}}" }'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oMovieData = Json_ObjGet($oResult, "data.findMovie")
Local $iCount = Int( $oMovieData.Item("scene_count") )
If $iCount = 0 Then
MsgBox(0, "No scene", "There is no scene in this movie.")
Return SetError(1)
EndIf
Local $nSceneID = $oMovieData.Item("scenes")[0].Item("id")
$sQuery = '{"query":"{findScene(id:' & $nSceneID & '){path}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oSceneData = Json_ObjGet($oResult, "data.findScene")
Local $sFilePath = $oSceneData.Item("path")
Local $iPos =  StringInStr($sFilePath, "\", 2, -1)
Local $sPath = StringLeft($sFilePath, $iPos)
ShellExecute($sPath)
Case "scenes"
$sQuery = '{"query":"{findScene(id:' & $aStr[2] & '){path}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
$oSceneData = Json_ObjGet($oResult, "data.findScene")
$sFilePath = $oSceneData.Item("path")
$iPos =  StringInStr($sFilePath, "\", 2, -1)
$sPath = StringLeft($sFilePath, $iPos)
ShellExecute($sPath)
Case "images"
$sQuery = '{"query":"{findImage(id:' & $aStr[2] & '){path}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
$oSceneData = Json_ObjGet($oResult, "data.findImage")
$sFilePath = $oSceneData.Item("path")
$iPos =  StringInStr($sFilePath, "\", 2, -1)
$sPath = StringLeft($sFilePath, $iPos)
ShellExecute($sPath)
Case "galleries"
$sQuery = '{"query":"{findGallery(id:' & $aStr[2] & '){path}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
$oSceneData = Json_ObjGet($oResult, "data.findGallery")
$sFilePath = $oSceneData.Item("path")
$iPos =  StringInStr($sFilePath, "\", 2, -1)
$sPath = StringLeft($sFilePath, $iPos)
ShellExecute($sPath)
EndSwitch
EndFunc
Func ReloadScrapers()
$sQuery = '{"query":"mutation{reloadScrapers}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
Local $sHandle = _WD_Window($sSession, "Window")
If $sHandle <> "" Then
_WD_Action($sSession, "refresh")
EndIf
EndFunc
Func GetCategory($sURL)
Local $sStr = StringMid($sURL, StringLen($stashURL) +1 )
If $sStr = "" Then
MsgBox(0, "This is home page", "The current browser is showing the home page of stash.")
Return SetError(1)
EndIf
If StringLeft($sStr, 1) = "/" Then
$sStr = StringTrimLeft($sStr, 1)
EndIf
$aStr = StringSplit($sStr, "/?=" )
If $aStr[0] = 0 Then
MsgBox(0, "Error processing page", "The current browser is unknown.")
Return SetError(1)
EndIf
Return $aStr[1]
EndFunc
Func GetCurrentTabCategoryAndNumber()
Local $sURL = GetURL()
If @error then Return SetError(1)
Local $sStr = StringMid($sURL, StringLen($stashURL) +1 )
If $sStr = "" Then
MsgBox(0, "This is home page", "The current browser is showing the home page of stash.")
Return SetError(1)
EndIf
If StringLeft($sStr, 1) = "/" Then
$sStr = StringTrimLeft($sStr, 1)
EndIf
$aStr = StringSplit($sStr, "/?=" )
If $aStr[0] = 0 Then
MsgBox(0, "Error processing page", "The current browser is unknown.")
Return SetError(1)
EndIf
If $aStr[0] >= 2 and StringIsDigit($aStr[2]) Then
Return $aStr[1] & "-" & $aStr[2]
Else
Return $aStr[1]
EndIf
EndFunc
Func GetURL()
Local $aHandles =  _WD_Window($sSession, 'Handles')
Switch  UBound($aHandles)
case 0
MsgBox(0, "No Stash browser", "Currently no Stash browser is opened. Please open one by using the bookmarks.")
Return SetError(1)
case 1
Local $sResult = _WD_Action($sSession, "url")
If @error <> $_WD_ERROR_Success Then
Local $sHandle =  $aHandles[UBound($aHandles)-1]
_WD_Window($sSession, "Switch", '{"handle":"'& $sHandle & '"}')
$sResult = _WD_Action($sSession, "url")
EndIf
case Else
Local $sHandle =  $aHandles[0]
_WD_Window($sSession, "Switch", '{"handle":"'& $sHandle & '"}')
$sResult = _WD_Action($sSession, "url")
EndSwitch
Return _URLDecode($sResult)
EndFunc
Func BookmarkCurrentTab()
Local $sResult = GetCurrentTabCategoryAndNumber()
If @error Then Return SetError(1)
Local $sURL = GetURL()
If @error Then Return SetError(1)
local $sThing = "thing"
$aStr = StringSplit($sResult, "-")
Local $sCategory = $aStr[1]
If $aStr[0] = 2 Then
If StringIsDigit($aStr[2]) Then
$sThing = StringTrimRight($sCategory, 1)
ElseIf $aStr[2] = "c" Then
$sThing = StringTrimRight($sCategory, 1) & " collection"
EndIf
EndIf
Local $sDescription = InputBox("Title required", "Please enter a brief description/title for this " & $sThing & ".")
If $sDescription = "" Then Return
$sDescription = StringLeft($sDescription, 50)
$sURL = _URLEncode($sURL, 2)
Switch $sCategory
Case "scenes"
Local $iRow = AddBookmarkToArray($sDescription, $sURL, $traySceneLinks )
TrayItemDelete($customScenes)
$traySceneLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuScenes )
$customScenes = TrayCreateItem("Customize...", $trayMenuScenes)
SaveMenuItems($sCategory, $traySceneLinks)
Case "images"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayImageLinks )
TrayItemDelete($customImages)
$trayImageLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuImages )
$customImages = TrayCreateItem("Customize...", $trayMenuImages)
SaveMenuItems($sCategory, $trayImageLinks)
Case "movies"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayMovieLinks )
TrayItemDelete($customMovies)
$trayMovieLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuMovies )
$customMovies = TrayCreateItem("Customize...", $trayMenuMovies)
SaveMenuItems($sCategory, $trayMovieLinks)
Case "markers"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayMarkerLinks )
TrayItemDelete($customMarkers)
$trayMarkerLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuMarkers )
$customMarkers = TrayCreateItem("Customize...", $trayMenuMarkers)
SaveMenuItems($sCategory, $trayMarkerLinks)
Case "galleries"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayGalleryLinks )
TrayItemDelete($customGalleries)
$trayGalleryLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuGalleries )
$customGalleries = TrayCreateItem("Customize...", $trayMenuGalleries)
SaveMenuItems($sCategory, $trayGalleryLinks)
Case "performers"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayPerformerLinks )
TrayItemDelete($customPerformers)
$trayPerformerLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuPeformers )
$customPerformers = TrayCreateItem("Customize...", $trayMenuPeformers)
SaveMenuItems($sCategory, $trayPerformerLinks)
Case "Studios"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayStudioLinks )
TrayItemDelete($customStudios)
$trayStudioLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuStudios )
$customStudios = TrayCreateItem("Customize...", $trayMenuStudios)
SaveMenuItems($sCategory, $trayStudioLinks)
Case "tags"
$iRow = AddBookmarkToArray($sDescription, $sURL, $trayTagLinks )
TrayItemDelete($customTags)
$trayTagLinks[$iRow][$ITEM_HANDLE] = TrayCreateItem($sDescription, $trayMenuTags )
$customTags = TrayCreateItem("Customize...", $trayMenuTags)
SaveMenuItems($sCategory, $trayTagLinks)
EndSwitch
MsgBox(0, "Bookmark added.", "Successfully added '" & $sDescription & "' to the " & $sCategory & " category.")
EndFunc
Func SaveMenuItems($sCategory, ByRef $aArray)
Local $sCat = StringUpper(stringleft($sCategory, 1)) & stringmid($sCategory, 2)
Local $str = "1|" & $aArray[0][$ITEM_TITLE] & "|" & $aArray[0][$ITEM_LINK]
For $i = 1 to $iMaxSubItems-1
$str &= "@@@" & String($i+1) & "|" & $aArray[$i][$ITEM_TITLE] & "|" & $aArray[$i][$ITEM_LINK]
Next
RegWrite("HKEY_CURRENT_USER\Software\Stash_Helper", $sCat & "List", "REG_SZ", $str)
EndFunc
Func AddBookmarkToArray($sTitle, $sLink, ByRef $aArray )
For $i = 0 to $iMaxSubItems -1
If $aArray[$i][$ITEM_TITLE] = "" Then ExitLoop
Next
If $i = 19 Then
If $aArray[19][$ITEM_HANDLE] <> Null Then
TrayItemDelete($aArray[19][$ITEM_HANDLE])
EndIf
EndIf
$aArray[$i][$ITEM_TITLE] = $sTitle
$aArray[$i][$ITEM_LINK] = $sLink
Return $i
EndFunc
Func ClearPlayList()
ReDim $aPlayList[0][3]
MsgBox(0, "Playlist cleared", "OK, now the play list is empty.", 10)
EndFunc
Func AddItemToList()
Local $sURL = GetURL()
If @error Then Return SetError(1)
Local $sCategory = GetCategory($sURL)
if @error Then Return SetError(1)
Local $sQueryCount = URLtoQuery($sURL, "count")
c("sQueryCount: " & $sQueryCount)
Local $iItemCount
Switch $sQueryCount
Case "not support"
MsgBox(0, "Not support", "Sorry but this kind of collection is not supported yet.")
Return
Case  "home"
MsgBox(0, "Stash HOme Page", "This is Stash's home page. Nothing to add to the play list.")
Return
Case "1"
$iItemCount = 1
Case Else
$sResult = Query2($sQueryCount)
If @error Then Return SetError(1)
c("result:" & $sResult)
Local $aStr = StringRegExp($sResult, '"count":\s*(\d+)', $STR_REGEXPARRAYMATCH )
$iItemCount = Int($aStr[0])
EndSwitch
If $iItemCount <> 1 Then
Local $hConfirm = MsgBox(65,"Confirm","Totally " & $iItemCount & " " & $sCategory & " to add to the play list." & @CRLF & "Some of them might contain multiple items." & @CRLF & "Are you sure to add them to the play list?",0)
if $hConfirm = 2 then Return
EndIf
$sQuery = URLtoQuery($sURL, "id")
if @error then Return SetError(1)
If StringLeft($sQuery, 3) = "id=" Then
Local $sID = PairValue($sQuery), $iNo
Switch $sCategory
Case "scenes"
AddSceneToList($sID)
If @error then Return
MsgBox(0, "Done", "One scene was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
Case "images"
AddImageToList($sID)
If @error then Return
MsgBox(0, "Done", "One image was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
Case "movies"
$iNo = AddMovieToList($sID)
If @error then Return
MsgBox(0, "Done", "One movie with " & $iNo & " scenes was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
Case "galleries"
$iNo = AddGalleryToList($sID)
If @error then Return
MsgBox(0, "Done", "One gallery with " & $iNo & " images was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
EndSwitch
Return
ElseIf $sQuery = "not support" Then
MsgBox(0, "Not support", "Too bad, this kind of query is not support.")
Return
EndIf
$sResult = Query2($sQuery)
if @error Then Return SetError(1)
Local $oData = Json_Decode($sResult)
Switch $sCategory
Case "scenes"
Local $aScenes = Json_ObjGet($oData, "data.findScenes.scenes")
If UBound($aScenes) = 0 Then
MsgBox(0, "strange", "Weird, program error. There is nothing to add to the list.")
Return SetError(1)
EndIf
Local $i = 0
For $oScene in $aScenes
$i += AddSceneToList($oScene.item("id"))
Next
MsgBox(0, "Done", "Totally "& $i & " scenes was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
Case "images"
Local $aImages = Json_ObjGet($oData, "data.findImages.images")
If UBound($aImages) = 0 Then
MsgBox(0, "strange", "Weird, program error. There is nothing to add to the list.")
Return SetError(1)
EndIf
Local $i = 0
For $oImage in $aImages
$i += AddImageToList($oImage.item("id"))
Next
MsgBox(0, "Done", "Totally "& $i & " images was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList) & @CRLF & "Beware: Most media players do not support playing images stored in .zip files." )
Case "movies"
Local $aMovies = Json_ObjGet($oData, "data.findMovies.movies")
If UBound($aMovies) = 0 Then
MsgBox(0, "strange", "Weird, program error. There is nothing to add to the list.")
Return SetError(1)
EndIf
Local $i = 0
For $oMovie in $aMovies
$i += AddMovieToList($oMovie.item("id"))
Next
MsgBox(0, "Done", "Totally "& UBound($aMovies) & " movies with "& $i & " scenes was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList))
Case "galleries"
Local $aGalleries = Json_ObjGet($oData, "data.findGalleries.galleries")
If UBound($aGalleries) = 0 Then
MsgBox(0, "strange", "Weird, program error. There is nothing to add to the list.")
Return SetError(1)
EndIf
Local $i = 0
For $oGallery in $aGalleries
$i += AddGalleryToList($oGallery.item("id"))
Next
MsgBox(0, "Done", "Totally "& UBound($aGalleries) & " galleries with "& $i & " images was added to the current play list." & @CRLF & "Total entities in play list:  " & UBound($aPlayList) & @CRLF & "Beware: Most media players do not support playing images stored in .zip files." )
Case Else
MsgBox(0, "Not supported", "Sorry, only scene/image/movie/gallery are supported.")
EndSwitch
EndFunc
Func AddImageToList($sID)
If $sID = "" then return 0
$sQuery = '{"query":"{findImage(id:' & $sID & '){title,path}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oData = Json_ObjGet($oResult, "data.findImage")
If Not IsObj($oData) Then Return 0
$i = UBound($aPlayList)
ReDim $aPlayList[$i+1][3]
$aPlayList[$i][$LIST_TITLE] = "Image: " & $oData.Item("title")
$aPlayList[$i][$LIST_DURATION] = $iSlideShowSeconds
$aPlayList[$i][$LIST_FILE] = FixPath($oData.Item("path"))
Return 1
EndFunc
Func AddGalleryToList($sID)
If $sID = "" then return 0
$sQuery = '{"query":"{findGallery(id:' & $sID & '){title,image_count,path,images{path}}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oData = Json_ObjGet($oResult, "data.findGallery")
If Not IsObj($oData) Then Return 0
Local $sPath = $oData.item("path")
if stringlower(StringRight($sPath, 4)) = ".zip" Then
Local $iReply = MsgBox(52,"Not Supported","This gallery is a zip file which contains images." & @CRLF & "Showing images in .zip files is not supported by most media players." & @CRLF & "So do you still want to add this gallery: " & $oData.Item("title")& "?",0)
if $iReply = 7 Then return 0
EndIf
Local $aImages = $oData.Item("images")
If UBound($aImages) = 0 Then Return 0
Local $iCount = 0
For $oImage In $aImages
$iCount += 1
$i = UBound($aPlayList)
ReDim $aPlayList[$i+1][3]
$aPlayList[$i][$LIST_TITLE] = "Gallery: " & $oData.Item("title") & " Image: " & $iCount
$aPlayList[$i][$LIST_DURATION] = $iSlideShowSeconds
$aPlayList[$i][$LIST_FILE] = FixPath($oImage.Item("path"))
Next
Return $iCount
EndFunc
Func SendPlayerList()
CheckMediaPlayer()
If @error Then Return SetError(1)
If UBound($aPlayList, $UBOUND_ROWS ) = 0 Then
MsgBox(48,"Play list is empty","There is nothing in the play list. Cannot play it.",10)
Return SetError(1)
EndIf
Local $sFileName = @TempDir & "\StashPlayList.m3u"
Local $hFile = FileOpen($sFileName, $FO_OVERWRITE)
If $hFile = -1 Then
MsgBox($MB_SYSTEMMODAL, "", "An error occurred when creating the file.", 10)
Return SetError(1)
EndIf
FileWriteLine($hFile, "#EXTM3U")
Local $iCount = UBound($aPlayList)
Local $sTitle, $sFile, $iDuration, $line
For $i = 0 to $iCount-1
$sTitle = $aPlayList[$i][$LIST_TITLE]
$iDuration = $aPlayList[$i][$LIST_DURATION]
$sFile = $aPlayList[$i][$LIST_FILE]
$line = "#EXTINF:" & $iDuration & "," & $sTitle
FileWriteLine($hFile, $line )
FileWriteLine($hFile, $sFile)
Next
FileClose($hFile)
Play(@TempDir & "\StashPlayList.m3u")
EndFunc
Func AddMovieToList($sID)
If $sID = "" Then Return 0
$sQuery = '{ "query": "{findMovie(id: ' & $sID & '){name,scene_count,scenes{id}}}" }'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oMovieData = Json_ObjGet($oResult, "data.findMovie")
If $oMovieData = "" Then Return 0
Local $iCount = Int( $oMovieData.Item("scene_count") )
If $iCount = 0 Then
Return 0
EndIf
For $i = 0 to $iCount-1
Local $nSceneID = $oMovieData.Item("scenes")[$i].Item("id")
$sQuery = '{"query":"{findScene(id:' & $nSceneID & '){path,file{duration} }}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oSceneData = Json_ObjGet($oResult, "data.findScene")
Local $j = UBound($aPlayList)
ReDim $aPlayList[$j+1][3]
$aPlayList[$j][$LIST_TITLE] = "Movie: " & $oMovieData.Item("name") & " - Scene " & ($i+1)
$aPlayList[$j][$LIST_DURATION] = Floor( $oSceneData.Item("file").Item("duration") )
$aPlayList[$j][$LIST_FILE] = FixPath($oSceneData.Item("path"))
Next
Return $iCount
EndFunc
Func AddSceneToList($sID)
If $sID = "" then return 0
$sQuery = '{"query":"{findScene(id:' & $sID & '){title,path,file{duration}}}"}'
$sResult = Query($sQuery)
If @error Then Return SetError(1)
$oResult = Json_Decode($sResult)
Local $oData = Json_ObjGet($oResult, "data.findScene")
If $oData = "" Then Return 0
$i = UBound($aPlayList)
ReDim $aPlayList[$i+1][3]
$aPlayList[$i][$LIST_TITLE] = "Scene: " & $oData.Item("title")
$aPlayList[$i][$LIST_DURATION] = Floor( $oData.Item("file").Item("duration") )
$aPlayList[$i][$LIST_FILE] = FixPath($oData.Item("path"))
Return 1
EndFunc
Func FixPath($sPath)
If stringmid($sPath, 2, 1) = ":" AND stringmid($sPath, 2, 2) <> ":\" Then
$sPath = StringLeft($sPath, 1) & ":\" & StringMid($sPath, 3)
EndIf
Return StringReplace($sPath, "\\", "\")
EndFunc
Func TimeConvert($i)
Local $iHour =  Floor($i / 3600)
Local $iMin = Floor( ($i - 3600 * $iHour) / 60)
Local $iSec = Mod($i, 60)
Return StringFormat('%01d:%02d:%02d', $iHour, $iMin, $iSec)
EndFunc
Func TimeConvertBack($str)
If StringInStr($str, ":", 2) = 0 Then Return 0
Local $aTime = StringSplit($str, ":")
Return Int($aTime[1]) * 3600 + Int($aTime[2]) * 60 + Int($aTime[3])
EndFunc
Func GetNumber($sURL, $sCategory)
$iPos1 = StringInStr($sURL, "/" & $sCategory & "/", 2) + StringLen($sCategory) +2
$iPos2 = StringInStr($sURL, "?", 2)
If  $iPos2 = 0 Then
return  StringMid($sURL, $iPos1)
Else
return  StringMid($sURL, $iPos1, $iPos2-$iPos1)
EndIf
EndFunc
Func ScanFiles()
Query('{"query": "mutation { metadataScan ( input: { useFileMetadata: true } ) } "}')
OpenURL("http://localhost:9999/settings?tab=tasks")
MsgBox(0, "Command sent", "The scan command is sent. You can check the progress in Settings->Tasks.", 10)
EndFunc
Func PlayMovie()
CheckMediaPlayer()
If @error Then Return SetError(1)
SwitchToTab("movies")
If @error then return SetError(1)
Local $sURL = GetURL()
If @error Then Return SetError(1)
Local $nMovie = GetNumber($sURL, "movies")
PlayMovieInCurrentTab($nMovie)
EndFunc
Func CheckMediaPlayer()
If $sMediaPlayerLocation = "" Then
MsgBox(48,"Media player missing.","You need to set the external media player in the 'Settings' first.",0)
Return SetError(1)
ElseIf Not FileExists($sMediaPlayerLocation) Then
MsgBox(48,"Media player missing.","The external media player in the 'Settings' is not valid.",0)
Return SetError(1)
EndIf
EndFunc
Func SwitchToTab($sCategory)
Local $sURL = GetURL()
If @error Then Return SetError(1)
Local $sSearchRegEx = "\/" & $sCategory & "\/\d+"
If StringRegExp($sURL, $sSearchRegEx) Then
Return
EndIf
Local $aHandles = _WD_WINDOW($sSession, "Handles")
If @error <> $_WD_ERROR_Success Or Not IsArray($aHandles) Then
MsgBox(48,"Error in browser.","Error retrieving browser handles.",0)
Return SetError(1)
EndIf
Local $iTabCount = UBound($aHandles)
Local $bFound = False, $i, $sURL
For $i = 0 To $iTabCount-1
_WD_Window($sSession, "Switch", '{"handle":"' & $aHandles[$i] & '"}' )
$sURL = _WD_Action($sSession, "url")
If StringRegExp($sURL, $sSearchRegEx) Then
$bFound = True
ExitLoop
EndIf
Next
If Not $bFound Then
Local $sItem = StringLeft($sCategory, stringlen($sCategory)-1)
MsgBox(48,"Cannot find the " & $sItem,"Sorry, but I cannot find the browser tab with the " & $sItem & " you want.",0)
Return SetError(1)
EndIf
EndFunc
Func PlayMovieInCurrentTab($nMovie)
$sResult = Query( '{"query": "{findMovie(id:' & $nMovie & '){scenes{path}}}"}' )
If @error Then Return
Local $oData = Json_Decode($sResult)
If Not Json_IsObject($oData) Then
MsgBox(0, "Data error.", "The data return from stash has errors.")
Return
EndIf
Local $aScenes = Json_ObjGet($oData, "data.findMovie.scenes")
c("aScenes:" & UBound($aScenes))
Switch UBound($aScenes)
Case 0
Case 1
Play( $aScenes[0].Item("path") )
Case Else
Local $hFile = FileOpen(@TempDir & "\StashMovie.m3u", $FO_OVERWRITE )
If $hFile = -1 Then
MsgBox(0, "m3u create error", "failed to create a m3u file for this movie.")
Return
EndIf
FileWriteLine($hFile, "#EXTM3U")
For $i = 0 to UBound($aScenes) - 1
FileWriteLine($hFile, "#EXTINF:-1,")
FileWriteLine($hFile, $aScenes[$i].Item("path") )
Next
FileClose($hFile)
Play(@TempDir & "\StashMovie.m3u")
EndSwitch
EndFunc
Func Play($sFile)
Local $sPath = StringLeft($sFile, StringInStr($sFile, "\", -1) )
$iMediaPlayerPID = ShellExecute($sMediaPlayerLocation, Q($sFile), Q($sPath), $SHEX_OPEN)
If $iMediaPlayerPID = -1 Then $iMediaPlayerPID = 0
EndFunc
Func QueryResultError($sResult)
Return StringLeft($sResult,10) = '{"errors":'
EndFunc
Func Query2($sQuery)
c("QueryString:" & '{"query":"'& $sQuery& '"}')
$sResult = Query('{"query":"'& $sQuery& '"}')
If @error Then Return SetError(1, 0, $sResult)
Return $sResult
EndFunc
Func Query($sQuery)
Local $hOpen = _WinHttpOpen()
Local $aMatch = StringRegExp( $stashURL, "http:\/\/(.+):(\d+)",1)
Local $hConnect = _WinHttpConnect($hOpen, $aMatch[0], Int($aMatch[1]))
If $hConnect = 0 Then
MsgBox(0, "error connect",  "error connecting to stash server.")
_WinHttpCloseHandle($hOpen)
Return SetError(1)
EndIf
Local $result = _WinHttpSimpleRequest($hConnect, "POST", "/graphql", Default, $sQuery, "Content-Type: application/json" )
_WinHttpCloseHandle($hConnect)
_WinHttpCloseHandle($hOpen)
If @error Then
MsgBox(0, "got data error",  "Error getting data from the stash server.")
Return SetError(1)
ElseIf QueryResultError($result) Then
MsgBox(0, "oops.", "Error in the query result:" & $result, 10)
Return SetError(1)
EndIf
Return $result
EndFunc
Func PlayScene()
CheckMediaPlayer()
If @error Then Return SetError(1)
SwitchToTab("scenes")
If @error Then Return SetError(1)
PlayCurrentScene()
EndFunc
Func PlayCurrentScene()
Local $sURL = GetURL()
If @error Then Return SetError(1)
Local $aMatch = StringRegExp($sURL, "\/scenes\/(\d+)\?", $STR_REGEXPARRAYMATCH )
c("scene id:" & $aMatch[0])
$sQuery = '{"query": "{findScene(id:' & $aMatch[0] & '){path}}"}'
c("scene query:" & $sQuery)
$sResult = Query( $sQuery )
If @error  Then Return SetError(1)
Local $oData = Json_Decode($sResult)
If Not Json_IsObject($oData) Then
MsgBox(0, "Data error.", "The data return from stash has errors.")
Return
EndIf
$sFile = Json_ObjGet($oData, "data.findScene.path")
Play( $sFile )
EndFunc
Func CloseSession()
_WD_DeleteSession($sSession)
If $iMediaPlayerPID <> 0 Then
ProcessClose($iMediaPlayerPID)
EndIf
EndFunc
Func SetupFirefox()
If Not FileExists(@AppDataDir & "\Webdriver\" & "geckodriver.exe") Then
Local $b64 = ( @CPUArch = "X64" )
Local $bGood = _WD_UPdateDriver ("firefox", @AppDataDir & "\Webdriver" , $b64, True)
If Not $bGood Then
MsgBox(48,"Error Getting Firefox Driver", "There is an error getting the driver for Firefox. Maybe your Internet is down?" & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Exit
EndIf
EndIf
_WD_Option('Driver', @AppDataDir & "\Webdriver\" & 'geckodriver.exe')
_WD_Option('DriverClose', True)
_WD_Option('DriverParams', '--log trace')
_WD_Option('Port', 4444)
$sDesiredCapabilities = '{"capabilities": {"alwaysMatch": {"browserName": "firefox", "acceptInsecureCerts":true}}}'
EndFunc
Func SetupChrome()
If Not FileExists( @AppDataDir & "\Webdriver\" & "chromedriver.exe") Then
Local $bGood = _WD_UPdateDriver ("chrome", @AppDataDir & "\Webdriver" , Default, True)
If Not $bGood Then
MsgBox(48,"Error Getting Firefox Driver", "There is an error getting the driver for Firefox. Maybe your Internet is down?" & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Exit
EndIf
EndIf
_WD_Option('Driver', @AppDataDir & "\Webdriver\" & 'chromedriver.exe')
_WD_Option('DriverClose', True)
_WD_Option('Port', 9515)
_WD_Option('DriverParams', '--verbose --log-path="' & @AppDataDir & "\Webdriver\chrome.log")
$sDesiredCapabilities = '{"capabilities": {"alwaysMatch": {"goog:chromeOptions": {"w3c": true, "excludeSwitches": [ "enable-automation"]}}}}'
EndFunc
Func SetupEdge()
If Not FileExists(@AppDataDir & "\Webdriver\" & "msedgedriver.exe") Then
Local $b64 = ( @CPUArch = "X64" )
Local $bGood = _WD_UPdateDriver ("msedge", @AppDataDir & "\Webdriver" , $b64 , True)
If Not $bGood Then
MsgBox(48,"Error Getting Firefox Driver", "There is an error getting the driver for Firefox. Maybe your Internet is down?" & @CRLF & "The program will try to get the driver again next time you launch it.",0)
Exit
EndIf
EndIf
_WD_Option('Driver', @AppDataDir & "\Webdriver\" & 'msedgedriver.exe')
_WD_Option('DriverClose', True)
_WD_Option('Port', 9515)
_WD_Option('DriverParams', '--verbose --log-path="' & @AppDataDir & "\Webdriver\msedge.log")
$sDesiredCapabilities = '{"capabilities": {"alwaysMatch": {"ms:edgeOptions": {"excludeSwitches": [ "enable-automation"]}}}}'
EndFunc
Func BrowserError($code)
MsgBox(48,"Oops !","Something wrong with the browser's driver. Cannot continue." & @CRLF & "WinHTTP status code:" & $code,0)
If $sSession Then _WD_DeleteSession($sSession)
_WD_Shutdown()
ExitScript()
EndFunc
Func OpenURL($url)
Local $aHandles =  _WD_Window($sSession, 'Handles')
If UBound($aHandles) = 0 Then
$sSession = _WD_CreateSession($sDesiredCapabilities)
_WD_Navigate($sSession, $url)
$sBrowserHandle = _WD_Window($sSession, "Window")
Else
$sBrowserHandle = $aHandles[UBound($aHandles)-1]
_WD_Window($sSession, "switch", '{"handle":"' & $sBrowserHandle & '"}' )
_WD_Navigate($sSession, $url)
EndIf
EndFunc
Func Alert($sMessage)
$sMessage = StringReplace($sMessage, "'", "`")
$sMessage = StringReplace($sMessage, '"', "`")
_WD_ExecuteScript($sSession, "prompt('" & $sMessage& "')", Default , True )
EndFunc
Func CreateSubMenu()
Local $i
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "ScenesList")
If @error Then
SetMenuItem($traySceneLinks,0, 0, "All Scenes", $stashURL & "scenes")
Else
DataToArray($sData, $traySceneLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "ImagesList")
If @error Then
SetMenuItem($trayImageLinks,0, 0, "All Images", $stashURL & "images")
Else
DataToArray($sData, $trayImageLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "MoviesList")
If @error Then
SetMenuItem($trayMovieLinks,0 , 0, "All Movies", $stashURL & "movies")
Else
DataToArray($sData, $trayMovieLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "MarkersList")
If @error Then
SetMenuItem($trayMarkerLinks,0, 0, "All Markers", $stashURL & "markers")
Else
DataToArray($sData, $trayMarkerLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "GalleriesList")
If @error Then
SetMenuItem($trayGalleryLinks,0, 0, "All Galleries", $stashURL & "galleries")
Else
DataToArray($sData, $trayGalleryLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "PerformersList")
If @error Then
SetMenuItem($trayPerformerLinks,0, 0, "All Performers", $stashURL & "performers")
Else
DataToArray($sData, $trayPerformerLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "StudiosList")
If @error Then
SetMenuItem($trayStudioLinks,0, 0, "All Studios", $stashURL & "studios")
Else
DataToArray($sData, $trayStudioLinks)
EndIf
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", "TagsList")
If @error Then
SetMenuItem($trayTagLinks,0, 0, "All Tags", $stashURL & "tags")
Else
DataToArray($sData, $trayTagLinks)
EndIf
For $i = 0 To UBound($traySceneLinks) -1
If $traySceneLinks[$i][$ITEM_TITLE] <> "" Then
$traySceneLinks[$i][$ITEM_HANDLE] = TrayCreateItem($traySceneLinks[$i][$ITEM_TITLE], $trayMenuScenes)
EndIf
Next
For $i = 0 To UBound($trayImageLinks) -1
If $trayImageLinks[$i][$ITEM_TITLE] <> "" Then
$trayImageLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayImageLinks[$i][$ITEM_TITLE], $trayMenuImages)
EndIf
Next
For $i = 0 To UBound($trayMovieLinks) -1
If $trayMovieLinks[$i][$ITEM_TITLE] <> "" Then
$trayMovieLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayMovieLinks[$i][$ITEM_TITLE], $trayMenuMovies)
EndIf
Next
For $i = 0 To UBound($trayMarkerLinks) -1
If $trayMarkerLinks[$i][$ITEM_TITLE] <> "" Then
$trayMarkerLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayMarkerLinks[$i][$ITEM_TITLE], $trayMenuMarkers)
EndIf
Next
For $i = 0 To UBound($trayGalleryLinks) -1
If $trayGalleryLinks[$i][$ITEM_TITLE] <> "" Then
$trayGalleryLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayGalleryLinks[$i][$ITEM_TITLE], $trayMenuGalleries)
EndIf
Next
For $i = 0 To UBound($trayPerformerLinks) -1
If $trayPerformerLinks[$i][$ITEM_TITLE] <> "" Then
$trayPerformerLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayPerformerLinks[$i][$ITEM_TITLE], $trayMenuPeformers)
EndIf
Next
For $i = 0 To UBound($trayStudioLinks) -1
If $trayStudioLinks[$i][$ITEM_TITLE] <> "" Then
$trayStudioLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayStudioLinks[$i][$ITEM_TITLE], $trayMenuStudios)
EndIf
Next
For $i = 0 To UBound($trayTagLinks) -1
If $trayTagLinks[$i][$ITEM_TITLE] <> "" Then
$trayTagLinks[$i][$ITEM_HANDLE] = TrayCreateItem($trayTagLinks[$i][$ITEM_TITLE], $trayMenuTags)
EndIf
Next
$customScenes = TrayCreateItem("Customize...", $trayMenuScenes)
$customImages = TrayCreateItem("Customize...", $trayMenuImages)
$customMovies = TrayCreateItem("Customize...", $trayMenuMovies)
$customMarkers = TrayCreateItem("Customize...", $trayMenuMarkers)
$customGalleries = TrayCreateItem("Customize...", $trayMenuGalleries)
$customPerformers = TrayCreateItem("Customize...", $trayMenuPeformers)
$customStudios = TrayCreateItem("Customize...", $trayMenuStudios)
$customTags = TrayCreateItem("Customize...", $trayMenuTags)
EndFunc
Func ReloadMenu($sCategory)
Switch $sCategory
Case "scenes"
TrayItemDelete($customScenes)
ReloadSubMenu($sCategory, $traySceneLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuScenes)
Case "images"
TrayItemDelete($customImages)
ReloadSubMenu($sCategory, $trayImageLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuImages)
Case "movies"
TrayItemDelete($customMovies)
ReloadSubMenu($sCategory, $trayMovieLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuMovies)
Case "markers"
TrayItemDelete($customMarkers)
ReloadSubMenu($sCategory, $trayMarkerLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuMarkers)
Case "galleries"
TrayItemDelete($customGalleries)
ReloadSubMenu($sCategory, $trayGalleryLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuGalleries)
Case "performers"
TrayItemDelete($customPerformers)
ReloadSubMenu($sCategory, $trayPerformerLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuPeformers)
Case "Studios"
TrayItemDelete($customStudios)
ReloadSubMenu($sCategory, $trayStudioLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuStudios)
Case "tags"
TrayItemDelete($customTags)
ReloadSubMenu($sCategory, $trayTagLinks)
$customScenes = TrayCreateItem("Customize...", $trayMenuTags)
EndSwitch
EndFunc
Func ReloadSubMenu($sCategory, ByRef $aArray)
Local $sCat = StringUpper(stringleft($sCategory, 1)) & StringMid($sCategory, 2)
For $i = 0 To UBound($aArray) -1
If $aArray[$i][$ITEM_HANDLE] <> Null Then
TrayItemDelete($aArray[$i][$ITEM_HANDLE])
EndIf
Next
Local $sData = RegRead("HKEY_CURRENT_USER\Software\Stash_Helper", $sCat & "List")
If @error Then
SetMenuItem($aArray,0, 0, "All " & $sCat, $stashURL & $sCategory)
Else
DataToArray($sData, $aArray)
EndIf
For $i = 0 To UBound($aArray) -1
If $aArray[$i][$ITEM_TITLE] <> "" Then
$aArray[$i][$ITEM_HANDLE] = TrayCreateItem($aArray[$i][$ITEM_TITLE], Execute("$trayMenu" & $sCat))
EndIf
Next
EndFunc
Func DeleteAllSubMenu()
For $i = 0 to UBound($traySceneLinks)-1
If $traySceneLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($traySceneLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customScenes)
For $i = 0 to UBound($trayImageLinks)-1
If $trayImageLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayImageLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customImages)
For $i = 0 to UBound($trayMovieLinks)-1
If $trayMovieLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayMovieLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customMovies)
For $i = 0 to UBound($trayMarkerLinks)-1
If $trayMarkerLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayMarkerLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customMarkers)
For $i = 0 to UBound($trayGalleryLinks)-1
If $trayGalleryLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayGalleryLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customGalleries)
For $i = 0 to UBound($trayPerformerLinks)-1
If $trayPerformerLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayPerformerLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customPerformers)
For $i = 0 to UBound($trayStudioLinks)-1
If $trayStudioLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayStudioLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customStudios)
For $i = 0 to UBound($trayTagLinks)-1
If $trayTagLinks[$i][$ITEM_HANDLE] Then
TrayItemDelete($trayTagLinks[$i][$ITEM_HANDLE])
EndIf
Next
TrayItemDelete($customTags)
EndFunc
Func DataToArray($sData, ByRef $aLink)
Local $aLines = StringSplit($sData, "@@@", $STR_ENTIRESPLIT + $STR_NOCOUNT)
Local $aItem
For $i = 0 To UBound($aLines)-1
$aItem = StringSplit($aLines[$i], "|", $STR_NOCOUNT)
$aLink[$i][$ITEM_TITLE] = $aItem[$ITEM_TITLE]
$aLink[$i][$ITEM_LINK] = $aItem[$ITEM_LINK]
Next
EndFunc
Func SetMenuItem(ByRef $aItem, $index, $handle, $Title, $Link)
$aItem[$index][$ITEM_HANDLE] = $handle
$aItem[$index][$ITEM_TITLE] = $Title
$aItem[$index][$ITEM_LINK] = $Link
EndFunc
Func Q($str)
Return '"' & $str & '"'
EndFunc
Func ExitScript()
If $iStashPID <> 0 Then
If ProcessExists($iStashPID) Then ProcessClose($iStashPID)
EndIf
if $sSession Then
_WD_DeleteSession($sSession)
_WD_Shutdown()
EndIf
Exit
EndFunc
Func c($str)
ConsoleWrite($str & @CRLF)
EndFunc
Func MsgExit($str)
MsgBox(16,"Error !",$str,0)
ExitScript()
EndFunc
#EndRegion Functions
